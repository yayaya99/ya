---
title: ' Java移位操作符'
tags:
  - Java
  - 移位操作符
  - Thinking in Java
abbrlink: 31914
date: 2019-08-04 18:43:07
---
### 移位运算符和按位运算符一样，同属于位运算符，因此移位运算符的位指的也是二进制位。它包括以下几种：

1.左移位（<<）：将操作符左侧的操作数向左移动操作符右侧指定的位数。移动的规则是在二进制的低位补0。

2.有符号右移位（>>）：将操作符左侧的操作数向右移动操作符右侧指定的位数。移动的规则是，如果被操作数的符号为正，则在二进制的高位补0；如果被操作数的符号为负，则在二进制的高位补1。

3.无符号右移位（>>>）：将操作符左侧的操作数向右移动操作符右侧指定的位数。移动的规则是，无论被操作数的符号是正是负，都在二进制位的高位补0。

<!--more-->

### 再来考虑一种情况，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，结果会是怎样呢？

1、byte、short、char在做移位运算之前，会被自动转换为int类型，然后再进行运算。

2、byte、short、int、char类型的数据经过移位运算后结果都为int型。

3、long经过移位运算后结果为long型。

4、在左移位（<<）运算时，如果要移位的位数大于被操作数对应数据类型所能表示的最大位数，那么先将要求移位数对该类型所能表示的最大位数求余后，再将被操作数移位所得余数对应的数值，效果不变。比如1<<35=1<<(35%32)=1<<3=8。

5、对于有符号右移位（>>）运算和无符号右移位（>>>）运算，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，那么先将要求移位数对该类型所能表示的最大位数求余后，再将被操作数移位所得余数对应的数值，效果不变。。比如100>>35=100>>(35%32)=100>>3=12。

### 在编程思想中有这么一句话：”移位“可与”等号“（<<=或>>=或>>>=）组合使用

但是在进行这样的移位赋值操作时，可能会遇到一个问题：如果byte或short值进行这样的移位运算，得到的可能不是正确的结果。

它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。

```
public class Test{
	public static void main(String[] args) {
		int i = -1;
		System.out.println(Integer.toBinaryString(i));
		i >>>=10;
		System.out.println(Integer.toBinaryString(i));
		long l = -1;
		System.out.println(Long.toBinaryString(l));
		l >>>= 10;
		System.out.println(Long.toBinaryString(l));
		short s = -1;
		System.out.println(Integer.toBinaryString(s));
		s >>>= 10;
		System.out.println(Integer.toBinaryString(s));
		byte b = -1;
		System.out.println(Integer.toBinaryString(b));
		b >>>= 10;
		System.out.println(Integer.toBinaryString(b));
		b = -1;
		System.out.println(Integer.toBinaryString(b));
		System.out.println(Integer.toBinaryString(b>>>10));
		
		
	}
}
```

>运行及结果：
>11111111111111111111111111111111
>1111111111111111111111
>1111111111111111111111111111111111111111111111111111111111111111
>111111111111111111111111111111111111111111111111111111
>11111111111111111111111111111111
>11111111111111111111111111111111
>11111111111111111111111111111111
>11111111111111111111111111111111
>11111111111111111111111111111111
>1111111111111111111111

运行会发现s>>>=10和b>>>=10的输出结果是错误的。
而没有赋值的b>>>=10的输出正确。

### 内容转载于 http://blog.sina.com.cn/s/blog_6ca0f5eb0102vlha.html

晚上纠结了很久这个问题，不懂为什么低5位才有用，怎么就2^5等于32位，跟int的32位挂上钩了，思考了很久终于明白了。

这段话有两个出处，一个是Java编程思想3.11移位操作符中出现，原话是“只有数值右端的低5位才有用”。一个是Java解惑中谜题27：变幻莫测的i值，原话是“移位操作符只使用其右操作数的低5位作为移位长度”。

弄清这句话首先需要弄清楚移位操作符，移位操作符是一个二元操作符，两个操作数分别位于移位操作两边形如：左操作数 移位操作符 右操作数 这样的结构，其含义是，将左操作数按照移位操作符指定的移位方向，进行右操作数指定的次数的移位。然后对照出处二，Java解惑中所描述的，就豁然开朗了。

首先，移位操作符能操作的数只有int类型和long类型，这个是指左操作数的类型。对于int类型而言，int在Java中占4字节，一共32位，也就是说，对于一个在Java中的int数据，做32次移位，那么这个int数据就完全变了，以左移为例，左移是补0，那么对于任意一个int类型数据，做32次移位，那么int数据变成32位全0的数据，Java不允许一次性移位左操作数的所有位，也就是右操作数不能大于32。于是回到上述的句子，其指的是右操作数的低5位，5位二进制所代表的最大值为2^5-1，为31，所以取右操作数的低5位，就是只看右操作数的二进制的低5位，其数值不会超过2^5次方，也就是int的32位。因此，移位操作符进行移位的实际次数，其实是右操作数2的次数。

对于Java编程思想中的翻译，“只有数值右端的低5位才有用”，真是莫名其妙了。其英语原文为：Only the five low-order bits of the right-hand side will be used.看到英文原文，可就明白了这句话的意思，鉴于现在的英译中的书籍参差不齐，建议阅读的时候配一本英文版的电子书在手边以备不时之需。

简而言之，移位操作符执行的次数，只取右操作数的低5位（其数值不会大于2^5=32，也就是移位次数不会超过32位，因为32位是int型的位数）作为移位的次数。

