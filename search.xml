<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github个人博客：绑定二级域名</title>
      <link href="/2019/09/15/Github%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9A%E7%BB%91%E5%AE%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/"/>
      <url>/2019/09/15/Github%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9A%E7%BB%91%E5%AE%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>Github个人博客：绑定二级域名</p><a id="more"></a><h2 id="购买域名，实名认证"><a href="#购买域名，实名认证" class="headerlink" title="购买域名，实名认证"></a>购买域名，实名认证</h2><p>购买的阿里云的域名，绑定博客可以不需要备案的。</p><h2 id="CNAME设置"><a href="#CNAME设置" class="headerlink" title="CNAME设置"></a>CNAME设置</h2><p>在blog/source目录下，新建名为CNAME的文件，没有后缀，添加blog.hongxigua.xyz</p><p>也可以直接编辑github中的文件</p><h2 id="设置GitHub-Pages"><a href="#设置GitHub-Pages" class="headerlink" title="设置GitHub Pages"></a>设置GitHub Pages</h2><p>进入博客的管理设置</p><p>向下拉会出现GitHub Pages设置的选项</p><p>Custom domain添加：</p><blockquote><p>blog.hongxigua.xyz</p></blockquote><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>在域名后选择解析</p><p>出现解析设置</p><p>添加记录：</p><blockquote><p>记录类型: CNAME- 将域名指向另外一个域名<br>主机记录： blog<br>解析路线：可默认<br>记录值：yayaya99.github.io<br>TTL：10</p></blockquote><p>(选择A时主机记录为www，记录值为ip地址，可通过pign博客的二级域名看到)</p><p>确定保存</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类是否可以继承其它类，是否可以实现接口</title>
      <link href="/2019/09/15/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E5%AE%83%E7%B1%BB%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/09/15/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E5%AE%83%E7%B1%BB%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>匿名内部类是否可以继承其它类，是否可以实现接口</p><a id="more"></a><p>匿名内部类：必须继承一个父类或实现一个接口</p><p><strong>实例1：不使用匿名内部类来实现抽象方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">abstract class Person&#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Person&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;eat something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Person p = new Child();</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：eat something</p><p>可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用</p><p>但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p><p>这个时候就引入了匿名内部类</p><p><strong>实例2：匿名内部类的基本实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abstract class Person &#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person() &#123;</span><br><span class="line">            @Override //此处方法重载 说明是实现父类 即内部类可以继承其他类 而且是必须</span><br><span class="line">            public void eat() &#123;</span><br><span class="line">                System.out.println(&quot;eat something&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：eat something</p><p>可以看到，我们直接将抽象类Person中的方法在大括号中实现了</p><p>这样便可以省略一个类的书写</p><p>并且，匿名内部类还能用于接口上</p><p><strong>实例3：在接口上使用匿名内部类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    public void eat();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person() &#123;</span><br><span class="line">            @Override //此处方法重载 说明是实现父类 即内部类可以实现其他类 而且是必须</span><br><span class="line">            public void eat() &#123;</span><br><span class="line">                System.out.println(&quot;eat something&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：eat something</p><p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p><p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 匿名内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java嵌套类</title>
      <link href="/2019/09/15/Java%E5%B5%8C%E5%A5%97%E7%B1%BB/"/>
      <url>/2019/09/15/Java%E5%B5%8C%E5%A5%97%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Java嵌套类</p><a id="more"></a><p>如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为其<strong>嵌套类</strong>。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它地外围类对象。然而，当内部类是static的时，就不是这样了。嵌套类意味着：</p><p>1、要创建嵌套类的对象，并不需要外围类的对象。</p><p>2、不能从嵌套类的对象中访问非静态的外围类对象。</p><p>嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel11&#123;</span><br><span class="line">private static class ParcelContents implements Contents&#123;</span><br><span class="line">private int i = 11;</span><br><span class="line">@Override</span><br><span class="line">public int value() &#123;return i;&#125;</span><br><span class="line">&#125;</span><br><span class="line">protected static class ParcelDestination implements Destination&#123;</span><br><span class="line">private String label;</span><br><span class="line">private ParcelDestination(String whereTo) &#123;</span><br><span class="line">label = whereTo;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String readLabel() &#123;</span><br><span class="line">return label;</span><br><span class="line">&#125;</span><br><span class="line">public static void f() &#123;&#125;</span><br><span class="line">static int x = 10;</span><br><span class="line">static class AnotherLevel&#123;</span><br><span class="line">public static void f() &#123;&#125;</span><br><span class="line">static int x = 10;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static Destination destination(String s) &#123;</span><br><span class="line">return new ParcelDestination(s);</span><br><span class="line">&#125;</span><br><span class="line">public static Contents contents() &#123;</span><br><span class="line">return new ParcelContents();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Contents c = contents();</span><br><span class="line">Destination d = destination(&quot;Tasmania&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main()中，没有任何Parcel11的对象是必需的；而是使用选取static成员的普通语法来调用方法——这些方法返回对Contents和Destination的引用。</p><p>就像你在本章前面看到的那样，在一个普通的（非static）内部类中，通过一个特殊的this引用可以链接到其外围类对象。嵌套类就没有这个特殊的this的引用，这使得它类似于一个static方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 嵌套类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java匿名内部类实现工厂化生产</title>
      <link href="/2019/09/15/Java%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%8E%82%E5%8C%96%E7%94%9F%E4%BA%A7/"/>
      <url>/2019/09/15/Java%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%8E%82%E5%8C%96%E7%94%9F%E4%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>Java匿名内部类实现工厂化生产</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">interface Service&#123;</span><br><span class="line">void method1();</span><br><span class="line">void method2();</span><br><span class="line">&#125;</span><br><span class="line">interface ServiceFactory&#123;</span><br><span class="line">Service getService();</span><br><span class="line">&#125;</span><br><span class="line">class Implementation1 implements Service&#123;</span><br><span class="line">private Implementation1()&#123;&#125;  //构造器私有，禁止new</span><br><span class="line">public void method1() &#123;System.out.println(&quot;Implementation1 method1&quot;);&#125;</span><br><span class="line">public void method2() &#123;System.out.println(&quot;Implementation1 method2&quot;);&#125;</span><br><span class="line">public static ServiceFactory factory = new ServiceFactory() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Service getService() &#123;</span><br><span class="line">return new Implementation1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Implementation2 implements Service&#123;</span><br><span class="line">private Implementation2()&#123;&#125;</span><br><span class="line">public void method1() &#123;System.out.println(&quot;Implementation2 method1&quot;);&#125;</span><br><span class="line">public void method2() &#123;System.out.println(&quot;Implementation2 method2&quot;);&#125;</span><br><span class="line">public static ServiceFactory factory = new ServiceFactory() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Service getService() &#123;</span><br><span class="line">return new Implementation2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class Factories&#123;</span><br><span class="line">public static void serviceConsumer(ServiceFactory fact) &#123;</span><br><span class="line">Service s = fact.getService();</span><br><span class="line">s.method1();</span><br><span class="line">s.method2();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">serviceConsumer(Implementation1.factory);</span><br><span class="line">serviceConsumer(Implementation2.factory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Implementation1 method1</span><br><span class="line">Implementation1 method2</span><br><span class="line">Implementation2 method1</span><br><span class="line">Implementation2 method2</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">interface Game&#123;boolean move();&#125;</span><br><span class="line">interface GameFactory&#123;Game getGame();&#125;</span><br><span class="line">class Checkers implements Game&#123;</span><br><span class="line">private Checkers() &#123;&#125;</span><br><span class="line">private int moves = 0;</span><br><span class="line">private static final int MOVES = 3;</span><br><span class="line">@Override</span><br><span class="line">public boolean move() &#123;</span><br><span class="line">System.out.println(&quot;Checkers move &quot;+moves);</span><br><span class="line">return ++moves!=MOVES;</span><br><span class="line">&#125;</span><br><span class="line">public static GameFactory factory  = new GameFactory() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Game getGame() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">return new Checkers();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Chess implements Game&#123;</span><br><span class="line">private Chess() &#123;&#125;</span><br><span class="line">private int moves = 0;</span><br><span class="line">private static final int MOVES =4;</span><br><span class="line">@Override</span><br><span class="line">public boolean move() &#123;</span><br><span class="line">System.out.println(&quot;Chess mpve &quot;+moves);</span><br><span class="line">return ++moves!=MOVES;</span><br><span class="line">&#125;</span><br><span class="line">public static GameFactory factory = new GameFactory() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Game getGame() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">return new Chess();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class Games&#123;</span><br><span class="line">public static void playGame(GameFactory factory) &#123;</span><br><span class="line">Game s = factory.getGame();</span><br><span class="line">while(s.move())</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">playGame(Checkers.factory);</span><br><span class="line">playGame(Chess.factory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Checkers move 0</span><br><span class="line">Checkers move 1</span><br><span class="line">Checkers move 2</span><br><span class="line">Chess mpve 0</span><br><span class="line">Chess mpve 1</span><br><span class="line">Chess mpve 2</span><br><span class="line">Chess mpve 3</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 匿名内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中类名+方法名（）{}什么意思</title>
      <link href="/2019/09/15/Java%E4%B8%AD%E7%B1%BB%E5%90%8D-%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%88%EF%BC%89-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
      <url>/2019/09/15/Java%E4%B8%AD%E7%B1%BB%E5%90%8D-%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%88%EF%BC%89-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p>发现问题并解决它</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel7b&#123;</span><br><span class="line">class MyContents implements Contents&#123;</span><br><span class="line">private int i = 11;</span><br><span class="line">public int value() &#123;return i;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Contents contents() &#123;  //1</span><br><span class="line">return new MyContents();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Parcel7b p = new Parcel7b();</span><br><span class="line">Contents c = p.contents();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码1处，使用了类名+方法名的方式创建方法，这样写有什么用？</p><p>—————————–分隔符—————————————————————————————————————————————————————</p><p>意思是这个方法的返回类型是某个类的实例。</p><p>上面的这种创建方式，说明此方法返回的是Contents的一个实例（对象）</p><p>那有什么好处？</p><p>可以通过类名+方法名调用的方法叫静态方法，属于类级别方法，类方法可在不实例化对象的前提下调用，一般类的静态方法和静态变量都是通过static关键字修饰的，而且静态方法体里不能应用任何实例变量和实例方法。至于你那段程序，调用那个方法和new一个对象效果是一样的。不过只是把实例的创建封装在方法里，通过类名加方法来调用而已,让实例化代码简洁点外，无任何差别。不过，有些时候，有些类的设计，出于某种需要，不希望类的构造方法是public的，也就是用户无法直接new出来的，通常就会通过这么一个静态方法来调用获取实例。而且这些方法体里除了直接return 一个实例之外，可能还会做某些处理,这在java里许多类都有这种设计。如，j2me中的Image类。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中静态代码块、构造代码块、构造函数、普通代码块</title>
      <link href="/2019/09/15/Java%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%99%AE%E9%80%9A%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2019/09/15/Java%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%99%AE%E9%80%9A%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>转自 <a href="https://www.cnblogs.com/ysocean/p/8194428.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/8194428.html</a></p><a id="more"></a><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p><strong>1、Java类中（方法中不能存在静态代码块）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行时机</strong></p><p>静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照书写顺序一次执行。</p><p><strong>3、静态代码块的作用</strong></p><p>一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放进静态代码块中。</p><p><strong>4、静态代码块不能存在任何方法体中</strong></p><p>这个应该很好理解，首先我们要明确静态代码块是在类加载的时候就要运行了。我们分情况讨论：</p><p>对于普通方法，由于普通方法是通过加载类，然后new出实例化对象，通过对象才能运行这个方法，而静态代码块只需要加载类之后就能运行了。</p><p>对于静态方法，在类加载的时候，静态方法也已经加载了，但是我们必须要通过类名或者对象名才能访问，也就是说相比于静态代码块，静态代码块是主动运行的，而静态方法是被动运行的。</p><p>不管是哪种方法，我们需要明确静态代码块的存在在类加载的时候就自动运行了，而放在不管是普通方法还是静态方法中，都是不能自动运行的。</p><p><strong>5、静态代码块不能访问普通变量</strong></p><p>这个理解思维同上，普通变量只能通过对象来调用，是不能放在静态代码块中的。</p><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><p><strong>1、格式</strong></p><p>Java类中使用{}声明的代码块（和静态代码块的区别是少了static关键字）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CodeBlock&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;构造代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行时机</strong></p><p>构造代码块在创建对象时被调出，每次创建对象都会调用一次，但是优先于构造函数执行。需要注意的是，听听名字我们就知道，构造代码块不是优先于构造函数执行，而是依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的。怎么理解呢？我们看看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;构造代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Test()&#123;</span><br><span class="line">        System.out.println(&quot;无参构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Test(String st)&#123;</span><br><span class="line">        System.out.println(&quot;有参构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> new Test();</span><br><span class="line"> new Test(&quot;t&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">构造代码块</span><br><span class="line">无参构造函数</span><br><span class="line">构造代码块</span><br><span class="line">有参构造函数</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>如果存在多个构造代码块，则执行顺序按照书写顺序依次执行。</p><p><strong>3、构造代码块的作用</strong></p><p>和构造函数的作用类似，都能对对象进行初始化，并且只要创建一个对象，构造代码块都会执行一次。但是反过来，构造函数则不一定每个对象建立时都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数）。</p><p>利用每次创建对象的时候都会提前调用一次构造代码块特性，我们可以做诸如统计创建对象的次数等功能。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>1、构造函数的命名必须和类名完全相同。在java中普通函数可以和构造函数同名，但是必须带有返回值；</p><p>2、构造函数的功能主要用于在类的对象创建时定义初始化的状态。它没有返回值，也不能用void来修饰。这就保证了它不仅什么也不用自动返回，而且根本不能有任何选择。而其他方法都有返回值，即使是void返回值。尽管方法体本身不会自动返回什么，但仍然可以让它返回一些东西，而这些东西可能是不安全的；</p><p>3、构造函数不能被直接调用，必须通过new运算符在创建对象时才会自动调用；而一般的方法是在程序执行到它的时候被调用的；</p><p>4、当定义一个类的时候，通常情况下都会显示该类的构造函数，并在函数中指定初始化的工作也可省略，不过Java编译器会提供一个默认的构造函数.此默认构造函数是不带参数的。而一般的方法不存在这一特点；</p><h2 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h2><p>普通代码块和构造代码块的区别是，构造代码块是在类中定义的，而普通代码块是在方法体中定义的。且普通代码块的执行顺序和书写顺序一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void sayHello()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>静态代码块&gt;构造代码块&gt;构造函数&gt;普通代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class CodeBlock &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;构造代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public CodeBlock()&#123;</span><br><span class="line">        System.out.println(&quot;无参构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;普通代码块&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;执行了main方法&quot;);</span><br><span class="line">         </span><br><span class="line">        new CodeBlock().sayHello();;</span><br><span class="line">        System.out.println(&quot;---------------&quot;);</span><br><span class="line">        new CodeBlock().sayHello();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">静态代码块</span><br><span class="line">执行了main方法</span><br><span class="line">构造代码块</span><br><span class="line">无参构造函数</span><br><span class="line">普通代码块</span><br><span class="line">---------------</span><br><span class="line">构造代码块</span><br><span class="line">无参构造函数</span><br><span class="line">普通代码块</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>我们创建了两个匿名对象，但是静态代码块只是调用了一次。</p><h2 id="父类和子类执行顺序"><a href="#父类和子类执行顺序" class="headerlink" title="父类和子类执行顺序"></a>父类和子类执行顺序</h2><p>对象的初始化顺序：</p><p>首先执行父类静态内容，父类静态的内容执行完毕后，接着去执行子类的静态的内容，当子类的静态内容执行完毕之后，再去看父类有没有构造代码块，如果有就执行父类的构造代码块，父类的构造代码块执行完毕，接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有构造代码块，如果有就执行子类的构造代码块。子类的构造代码块执行完毕再去执行子类的构造方法。</p><p>总之一句话，静态代码块内容先执行，接着执行父类构造代码块和构造方法，然后执行子类构造代码块和构造方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class SuperClass &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;父类静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;父类构造代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public SuperClass()&#123;</span><br><span class="line">        System.out.println(&quot;父类构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class SubClass extends SuperClass&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;子类静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子类构造代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public SubClass()&#123;</span><br><span class="line">        System.out.println(&quot;子类构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SubClass sb = new SubClass();</span><br><span class="line">        System.out.println(&quot;------------&quot;);</span><br><span class="line">        SubClass sb1 = new SubClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">父类静态代码块</span><br><span class="line">子类静态代码块</span><br><span class="line">父类构造代码块</span><br><span class="line">父类构造函数</span><br><span class="line">子类构造代码块</span><br><span class="line">子类构造函数</span><br><span class="line">------------</span><br><span class="line">父类构造代码块</span><br><span class="line">父类构造函数</span><br><span class="line">子类构造代码块</span><br><span class="line">子类构造函数</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 静态代码块 </tag>
            
            <tag> 构造代码块 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 普通代码块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 在方法和作用域内的内部类</title>
      <link href="/2019/09/15/Java-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2019/09/15/Java-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Java 在方法和作用域内的内部类</p><a id="more"></a><p>10.5 在方法和作用域内的内部类</p><p>自己很难搞懂一些代码的作用，所以内部类这一章进行的很慢很慢，看的我头大</p><p>所以</p><p>先mark以下</p><hr><p>在知乎上看到了这么一句话：</p><p>局部内部类是指内部类定义在方法或作用于内</p><ul><li>局部内部类不能有访问说明符</li><li>局部内部类可以访问当前代码块内的常量以及此外围类的所有成员</li></ul><hr><p>内部类的语法覆盖了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任意的作用域内定义内部类。这么做有两个理由：</p><p>1、实现了某个类型的接口，于是可以创建并返回对其的引用。</p><p>2、要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</p><p>在后面的例子中，以用来实现：</p><p>1、一个定义在方法中的类</p><p>2、一个定义在作用域内的类，此作用域在方法的内部</p><p>3、一个实现了接口的匿名类</p><p>4、一个匿名类，它扩展了有非默认构造器的类</p><p>5、一个匿名类，它执行字段初始化</p><p>6、一个匿名类，它通过实例化初始化实现构造（匿名类不可能有构造器）</p><p>第一个例子展示了在方法的作用域（而不是在其他类的作用域内）创建了一个完整的类。这被称作局部内部类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel5&#123;</span><br><span class="line">public Destination destination(String s) &#123;</span><br><span class="line">class PDestination implements Destination&#123;</span><br><span class="line">private String label;</span><br><span class="line">private PDestination(String whereTo) &#123;</span><br><span class="line">label = whereTo;</span><br><span class="line">&#125;</span><br><span class="line">public String readLabel() &#123;return label;&#125;</span><br><span class="line">&#125;</span><br><span class="line">return new PDestination(s);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Parcel5 p = new Parcel5();</span><br><span class="line">Destination d = p.destination(&quot;Tasmania&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中内部类PDestination实现了Destination,???</p><p>在网上没有找到这样写的原因，个人不太懂，唉</p><p>PDestination类是destination()方法的一部分，而不是Parcel5的一部分。所以，在destination()之外不能访问PDestination。注意出现在return语句中的向上转型——返回的是Destination的引用，它是PDestination的基类。当然，在destination()中定义了内部类PDestination，并不意味着一旦dest()方法执行完毕，PDestination就不可用了。</p><p>你可以在同一个子目录下的任意类中对某个内部类使用标识符PDestination，这并不会有命名冲突。</p><p>如何在任意的作用域内嵌入一个内部类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel6&#123;</span><br><span class="line">private void internalTracking(boolean b) &#123;</span><br><span class="line">if(b) &#123;</span><br><span class="line">class TrackingSlip&#123;</span><br><span class="line">private String id;</span><br><span class="line">TrackingSlip(String s)&#123;</span><br><span class="line">id = s;</span><br><span class="line">&#125;</span><br><span class="line">String getSlip() &#123;return id;&#125;</span><br><span class="line">&#125;</span><br><span class="line">TrackingSlip ts = new TrackingSlip(&quot;slip&quot;);</span><br><span class="line">String s = ts.getSlip();</span><br><span class="line">&#125;</span><br><span class="line">//Can&apos;t use it here! Out of scope;</span><br><span class="line">//!TrackingSlip ts = new TrackingSlip(&quot;x&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void track() &#123;internalTracking(true);&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Parcel6 p = new Parcel6();</span><br><span class="line">p.track();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TrackingSlip类被嵌入在if语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义TrackingSlip的作用域之外，它是不可用的；除此之外，它与普通的类一样。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当用protected访问修饰符修饰内部类时会怎样</title>
      <link href="/2019/09/15/%E5%BD%93%E7%94%A8protected%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BF%AE%E9%A5%B0%E5%86%85%E9%83%A8%E7%B1%BB%E6%97%B6%E4%BC%9A%E6%80%8E%E6%A0%B7/"/>
      <url>/2019/09/15/%E5%BD%93%E7%94%A8protected%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BF%AE%E9%A5%B0%E5%86%85%E9%83%A8%E7%B1%BB%E6%97%B6%E4%BC%9A%E6%80%8E%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<p>在第十章的练习6中，遇到了这个问题。</p><p>在查找问题时，发现了下面这篇博文，内容通俗易懂，看过之后很受启发，但我文笔不好，所以直接引用过来学习。</p><p>哈哈我好无耻。。</p><p>转自 <a href="https://blog.csdn.net/clarkdu/article/details/334925" target="_blank" rel="noopener">https://blog.csdn.net/clarkdu/article/details/334925</a></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// in SuperClass.java</span><br><span class="line">package com.duwei.SuperClass;</span><br><span class="line">        </span><br><span class="line">class SuperClass &#123;</span><br><span class="line">        protected class InnerClass&#123;  // 错误根源</span><br><span class="line">                                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// in SubClass.java</span><br><span class="line">package com.duwei.SubClass</span><br><span class="line"></span><br><span class="line">import com.duwei.SuperClass.*;</span><br><span class="line"></span><br><span class="line">class SubClass extends SuperClass &#123;</span><br><span class="line">        public void func() &#123;</span><br><span class="line">                InnerClass ic = new InnerClass();  // 导致错误</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对protected访问修饰符理解的还不是很深刻的朋友会觉得这没什么程序很正常. 程序行为都很合乎情理. 其实不然, 程序在编译的时候会报错, 错误信息为InnerClass() has protected access in com.duwei.SuperClass.InnerClass.</p><p>这是为什么? 我的SuperClass类里的内部类InnerClass已经被定义为protected了, 而且Java保证了被protected所修饰的东西都可以在其子类中使用呀!!! 但, 请再仔细看看错误信息的内容, 原来并不是InnerClass类有什么问题, 而是InnerClass类中的InnerClass()方法出现了问题, InnerClass()这不是InnerClass类的构造函数吗!!! 看来问题找到一半了, 我们在学习Java的时候都知道, 如果一个类没定义任何形式的构造函数时, Java编译器会自动为类加上一个, 但问题就在这, 很多人不会重视这个自动被加上的构造函数的访问级别为何! 不过在此提到了可能大家也就都想起来了, 事实上这个被自动加上的构造函数的访问级别与类相同! 我们在回到刚才的问题上, 这时我们会发现原来InnerClass类在定义时并没有写构造函数, 编译时被自动加入的构造函数访问级别与类相同, 也就是protected. 这时我想大家应该明白为什么程序会出问题了吧!!!</p><p>原来在SubClass类中的func()方法里实例化InnerClass类时出了问题, 当然单从InnerClass的访问级别为protected来讲这样做没什么问题, 但实例化就得调用构造函数, 也就是在调用了InnerClass类的构造函数时, 由于这个被编译器自动加上的构造函数沿袭了InnerClass类的访问级别为protected, 所以这个构造函数只能在InnerClass的子类中或者同一个包中被调用, 而此时只是简单的实例化InnerClass类而并不存在什么子类而且又是在另一个包中, 再说Java只允许在同一个类中的内部类继承另一个内部类, 而且这种操作的允许范围仅此而以, 所以问题的终于要水落石出了, 由于InnerClass类的构造函数只允许其子类调用而不允许其它形式的调用, 所以此时对于InnerClass类来讲无法调用其构造函数来实例化对象. 至此问题找到了. 解决问题的方法也很简单, 只要在InnerClass类中定义一个public访问级别的构造函数就可以了.</p><p>由此我们可以看出, 有时候程序的某些特征是深藏不露, 如果你不去那样想是很难发现它的.</p><p>本文链接：<a href="https://blog.csdn.net/clarkdu/article/details/334925" target="_blank" rel="noopener">https://blog.csdn.net/clarkdu/article/details/334925</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> protected </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 链接到外部类</title>
      <link href="/2019/09/15/Java-%E9%93%BE%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB/"/>
      <url>/2019/09/15/Java-%E9%93%BE%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Java 链接到外部类</p><a id="more"></a><p>当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。</p><p>内部类还拥有其外围类的所有元素的访问权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">interface Selector&#123;</span><br><span class="line">boolean end();Object current();void next();</span><br><span class="line">&#125;</span><br><span class="line">public class Sequence&#123;</span><br><span class="line">private Object[] items;</span><br><span class="line">private int next = 0;</span><br><span class="line">public Sequence(int size) &#123;items = new Object[size];&#125;</span><br><span class="line">public void add(Object x) &#123;</span><br><span class="line">if(next &lt; items.length)</span><br><span class="line">items[next++] = x;</span><br><span class="line">&#125;</span><br><span class="line">private class SequenceSelector implements Selector&#123;</span><br><span class="line">private int i = 0;</span><br><span class="line">public boolean end() &#123;return i == items.length;&#125;</span><br><span class="line">public Object current() &#123;return items[i];&#125;</span><br><span class="line">public void next() &#123;</span><br><span class="line">if(i &lt; items.length)</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Selector selector() &#123;</span><br><span class="line">return new SequenceSelector();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Sequence sequence = new Sequence(10);</span><br><span class="line">for(int i = 0;i&lt;10;i++) &#123;sequence.add(Integer.toString(i));&#125;  //1</span><br><span class="line">Selector selector = sequence.selector();</span><br><span class="line">while(!selector.end()) &#123;</span><br><span class="line">System.out.print(selector.current()+&quot; &quot;);</span><br><span class="line">selector.next();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中在1处的调用是这样写的，sequence.add(Integer.toString(i)，add函数为：public void add(Object x)。这里我有个疑问，如果写成sequence.add(1)结果是一样的，那么那样写是是那么意思呢？</p><p>依照疑问下面引入了网友的回答：</p><p>1、sequence.add(Interger.toString(1))表示s里面加入的是个string值，内容是1<br>sequence.add(1)表示s里面加入的是个int数字1<br>因为public void add(Object x)中参数是Object所以string和int都能传入</p><p>2、Interger.toString(1) 是把数字用字符串的形式表示出来<br>Object x 是所有java支持的对象<br>sequence.add(1),,因为不管1是数字还是字符,都是java支持的对象所以直接add也可以</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java toString() 方法</title>
      <link href="/2019/09/15/Java-toString-%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/15/Java-toString-%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Java toString() 方法</p><a id="more"></a><p>toString()方法用于返回以一个字符串表示的Number对象值。</p><p>如果方法使用了原生的数据类型作为参数，返回原生数据类型的String对象值。</p><p>如果方法有两个参数，返回用第二个参数指定基数表示的第一个参数的字符串表示形式。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>以String类为例，该方法有以下几种格式语法：</p><blockquote><p>String toString()<br>static String toString(int i)</p></blockquote><p>参数</p><ul><li>i–转换的整数</li></ul><p>返回值</p><ul><li>toString():返回表示Integer值的String对象</li><li>toString(int i):返回表示指定int的String对象</li></ul><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Integer x = 5;</span><br><span class="line">System.out.println(x.toString());</span><br><span class="line">System.out.println(Integer.toString(12));</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">5</span><br><span class="line">12</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>———————————————————————分割线——————————————————————————————- </p><p>以下引自 <a href="https://blog.csdn.net/u013309870/article/details/72158054" target="_blank" rel="noopener">https://blog.csdn.net/u013309870/article/details/72158054</a></p><h2 id="Integer类的toString的基本用法"><a href="#Integer类的toString的基本用法" class="headerlink" title="Integer类的toString的基本用法"></a>Integer类的toString的基本用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class IntegerDemo&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Integer OUT_MAX_VALUE = new Integer(Integer.MAX_VALUE);</span><br><span class="line">Integer MAX_VALUE = new Integer(Integer.MAX_VALUE);</span><br><span class="line">Integer MIN_VALUE = new Integer(Integer.MIN_VALUE);</span><br><span class="line">Integer NOR_VALUE = new Integer(-128);</span><br><span class="line">Integer OUT_MIN_VALUE = new Integer(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;max_val &quot;+MAX_VALUE.toString());</span><br><span class="line">System.out.println(&quot;max_val :&quot;+MAX_VALUE);</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;out_max :&quot;+OUT_MAX_VALUE.toString());</span><br><span class="line">        System.out.println(&quot;out_min :&quot;+OUT_MIN_VALUE.toString());</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);        </span><br><span class="line">        System.out.println(&quot;min_val :&quot;+MIN_VALUE.toString());</span><br><span class="line">        System.out.println(&quot;min_val :&quot;+MIN_VALUE);</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;nor_val :&quot;+NOR_VALUE.toString());</span><br><span class="line">        System.out.println(&quot;nor_val :&quot;+NOR_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">max_val 2147483647</span><br><span class="line">max_val :2147483647</span><br><span class="line">-------------------------</span><br><span class="line">out_max :2147483647</span><br><span class="line">out_min :-2147483648</span><br><span class="line">-------------------------</span><br><span class="line">min_val :-2147483648</span><br><span class="line">min_val :-2147483648</span><br><span class="line">-------------------------</span><br><span class="line">nor_val :-128</span><br><span class="line">nor_val :-128</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>由上面可知直接输出Integer的值和调用Integer类的toString方法是一样的，其实直接打印一个对象的时候就是调用了该对象的toString方法。调用toString方法的时候其实输出的是Integer的value值，toString方法就是把int类型的value值转化为string类型输出。注意一下几点：</p><p>1、Integer的value值从 Integer.MIN_VALUE 到 Integer.MAX_VALUE 如果超出了这个范围就会得到一些奇怪的结果。</p><p>2、在Integer.MAX_VALUE基础上加1输出的结果是个负值。</p><p>3、在Integer.MIN_VALUE基础上加1输出的结果是个正值。</p><h2 id="Integer类的toString的源码分析"><a href="#Integer类的toString的源码分析" class="headerlink" title="Integer类的toString的源码分析"></a>Integer类的toString的源码分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return toString(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//------------------------------</span><br><span class="line"></span><br><span class="line">public static String toString(int i) &#123;</span><br><span class="line">    if (i == Integer.MIN_VALUE)</span><br><span class="line">        return &quot;-2147483648&quot;;</span><br><span class="line">     //如果是最小值直接返回其字符串因为Integer.MIN_VALUE=-2147483648 ，这样可以节省下面计算时间</span><br><span class="line">     //①</span><br><span class="line">    int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);</span><br><span class="line">    //获取整数值的长度10进制</span><br><span class="line">    char[] buf = new char[size];</span><br><span class="line">    //②</span><br><span class="line">    getChars(i, size, buf);</span><br><span class="line">    //得到整数中的每一个字符</span><br><span class="line">    //③</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">    //返回字符串值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码做几点说明：<br>1、如果Integer的value值正好是 Integer.MIN_VALUE 直接返回 “-2147483648” 节省时间。<br>2、得到integer值的十进制的长度，如果负数先求出绝对值的长度，然后再长度加1，因为负数的符号位占一位。<br>3、得到integer的value值的每一个字符。<br>4、得到的字符新建字符串返回。 </p><p>…</p><p>先记到这里把，我脑子不够用了。。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> toString() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口与工厂</title>
      <link href="/2019/09/15/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/"/>
      <url>/2019/09/15/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82/</url>
      
        <content type="html"><![CDATA[<p>接口与工厂</p><a id="more"></a><p>接口是实现多重继承的途径，而生成遵循某个接口的对象的典例方式就是工厂方法设计模式。</p><p>工厂对象上调用的是创建方法，工厂对象将生成接口的某个实现的对象。</p><p>我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换为另一个实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">interface Service&#123;</span><br><span class="line">void method1();</span><br><span class="line">void method2();</span><br><span class="line">&#125;</span><br><span class="line">interface ServiceFactory&#123;</span><br><span class="line">Service getService();</span><br><span class="line">&#125;</span><br><span class="line">class Implementation1 implements Service&#123;</span><br><span class="line">Implementation1()&#123;&#125;</span><br><span class="line">public void method1() &#123;System.out.println(&quot;Implementation1 method1&quot;);&#125;</span><br><span class="line">public void method2() &#123;System.out.println(&quot;Implementation1 method2&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Implementation1Factory implements ServiceFactory&#123;</span><br><span class="line">public Service getService()&#123;</span><br><span class="line">return new Implementation1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Implementation2 implements Service&#123;</span><br><span class="line">Implementation2()&#123;&#125;</span><br><span class="line">public void method1() &#123;System.out.println(&quot;Implementation2 method1&quot;);&#125;</span><br><span class="line">public void method2() &#123;System.out.println(&quot;Implementation2 method2&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Implementation2Factory implements ServiceFactory&#123;</span><br><span class="line">public Service getService() &#123;</span><br><span class="line">return new Implementation2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Factories&#123;</span><br><span class="line">public static void serviceConsumer(ServiceFactory fact) &#123;</span><br><span class="line">Service s = fact.getService();</span><br><span class="line">s.method1();</span><br><span class="line">s.method2();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">serviceConsumer(new Implementation1Factory());</span><br><span class="line">serviceConsumer(new Implementation2Factory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Implementation1 method1</span><br><span class="line">Implementation1 method2</span><br><span class="line">Implementation2 method1</span><br><span class="line">Implementation2 method2</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>如果不是用工厂方法，你的代码就必须在某处指定将要创建地Service的确切类型，以便调用合适的构造器。</p><p>为什么想要添加这种额外级别的间接性呢？一个常见的原因是想要创建框架：假设你正在创建一个对弈游戏，例如，在相同的棋盘上下国际象棋和西洋跳棋：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">interface Game&#123;</span><br><span class="line">boolean move();</span><br><span class="line">&#125;</span><br><span class="line">interface GameFactory&#123;</span><br><span class="line">Game getGame();</span><br><span class="line">&#125;</span><br><span class="line">class Checkers implements Game&#123;</span><br><span class="line">private int moves = 0;</span><br><span class="line">private static final int MOVES = 3;</span><br><span class="line">public boolean move() &#123;</span><br><span class="line">System.out.println(&quot;Checkers move &quot;+moves);</span><br><span class="line">return ++moves != MOVES;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class CheckerFactory implements GameFactory&#123;</span><br><span class="line">public Game getGame() &#123;</span><br><span class="line">return new Checkers();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Chess implements Game&#123;</span><br><span class="line">private int moves = 0;</span><br><span class="line">private static final int MOVES = 4;</span><br><span class="line">public boolean move() &#123;</span><br><span class="line">System.out.println(&quot;Chess move &quot;+moves);</span><br><span class="line">return ++moves != MOVES;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChessFactory implements GameFactory&#123;</span><br><span class="line">public Game getGame() &#123;</span><br><span class="line">return new Chess();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Games&#123;</span><br><span class="line">public static void playGame(GameFactory factory) &#123;</span><br><span class="line">Game s = factory.getGame();</span><br><span class="line">while(s.move())</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">playGame(new CheckerFactory());</span><br><span class="line">playGame(new ChessFactory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Checkers move 0</span><br><span class="line">Checkers move 1</span><br><span class="line">Checkers move 2</span><br><span class="line">Chess move 0</span><br><span class="line">Chess move 1</span><br><span class="line">Chess move 2</span><br><span class="line">Chess move 3</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>如果Games类表示一段复杂的代码，那么这种方式就允许你在不同类型的游戏中复用这段代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 接口 </tag>
            
            <tag> 工厂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始化接口中的域</title>
      <link href="/2019/09/15/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%9F%9F/"/>
      <url>/2019/09/15/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>在接口中定义的域不能是“空final”，但是可以被非常量表达式初始化。</p><a id="more"></a><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">interface A&#123;</span><br><span class="line">Random RAND = new Random(47);</span><br><span class="line">int RANOOM_INT = RAND.nextInt(10);</span><br><span class="line">long RANOOM_LONG = RAND.nextLong()*10;</span><br><span class="line">float RANOOM_FLOAT = RAND.nextLong()*10;</span><br><span class="line">double RANOOM_DOUBLE = RAND.nextDouble()*10;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(A.RANOOM_INT);</span><br><span class="line">System.out.println(A.RANOOM_LONG);</span><br><span class="line">System.out.println(A.RANOOM_FLOAT);</span><br><span class="line">System.out.println(A.RANOOM_DOUBLE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然域是static的，就可以在类第一次被加载时初始化，这发生在任何首次被访问时。</p><p>这些域不是接口的一部分，它们的值被存储在该接口的静态存储区域内。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java接口中方法的默认访问修饰符为public</title>
      <link href="/2019/09/15/java%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%BApublic/"/>
      <url>/2019/09/15/java%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%BApublic/</url>
      
        <content type="html"><![CDATA[<p>java接口中方法的默认访问修饰符为public</p><a id="more"></a><p>接口，比抽象类还要抽象的类:</p><p>1、接口中的方法会被隐式的指定为  public abstract （只能是 public abstract，其他修饰符都会报错）。</p><p>2、接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）</p><p>3、接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p><p>注：</p><p>接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字。</p><p>接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字。</p><p>接口中的方法都是公有的( public ) ！！！ 不是 default 啦</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 默认修饰符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java模式(适配器模式)</title>
      <link href="/2019/09/15/Java%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/15/Java%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>学习到适配接口时不是很理解，书上的例子自己也看不懂，就找到博友的文章来学习一下吧。</p><p>转自 <a href="https://blog.csdn.net/elegant_shadow/article/details/5006175" target="_blank" rel="noopener">https://blog.csdn.net/elegant_shadow/article/details/5006175</a></p><a id="more"></a><p>首先，先来讲讲适配器。适配就是又“源”到“目标”的适配，而当中连接两者的关系就是适配。它负把“源”过度到“目标”。举个简单的例子，比如有一个“源”是一个对象人，他拥有2种技能分别是说日语和说英语，而某个岗位（目标）需要你同时回说日语、英语、和法语，好了，现在我们的任务就是要将人这个“源”适配的这个岗位中，如何适配呢？显而易见地我们需要为人添加一个说法语的方法，这样才能满足目标的需要。</p><p>接着讨论如何加说法语这个方法，也许你会说，为什么不直接在“源”中直接添加方法，我的理解是，适配是为了实现某种目的而为一个源类暂时性的加上某种方法，所以不能破坏原类的结构。同时不这么做也符合Java的高内聚，低耦合的原理。既然不能直接加，接着我们就来说该怎么来实现为人这个“源”添加一个方法，而又不破坏“源”的本身结构。</p><p>适配器模式有2种，第一种是“面向类的适配器模式”，第二种是“面向对象的适配器模式”。</p><p>先说“面向类的适配器模式”。顾名思义，这类适配器模式就是主要用于，单一的为某个类而实现适配的这样一种模式，为什么说只为某个类去实现，一会提到，我们先展示这种类适配模式的代码实现。</p><p>源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private String sex;</span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">public void speakJapanese()&#123;</span><br><span class="line">System.out.println(&quot;I can speak Japanese!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void speakEnglish()&#123;</span><br><span class="line">System.out.println(&quot;I can speak English!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">...//以下省略成员变量的get和set方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标接口的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Job &#123;</span><br><span class="line"></span><br><span class="line">public abstract void speakJapanese();</span><br><span class="line">public abstract void speakEnglish();</span><br><span class="line">public abstract void speakFrench();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Adapter extends Person implements Job&#123;</span><br><span class="line"></span><br><span class="line">public void speakFrench() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，代码看完然后要做一些说明了，之前遗留的一个问题，为什么称其为类适配模式呢？很显然的，Adapter类继承了Person类，而在Java这种单继承的语言中也就意味着，他不可能再去继承其他的类了，这样也就是这个适配器只为Person这一个类服务。所以称其为类适配模式。</p><p>说完类的适配模式，我们要开始说第2种对象的适配器模式了。对象适配器模式是把“源”作为一个对象聚合到适配器类中。同样的话不多说，贴上代码：</p><p>源的代码以及目标代码同上，再次不再赘述。</p><p>仅贴出适配器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Adapter implements Job &#123;</span><br><span class="line"></span><br><span class="line">Person person;</span><br><span class="line"></span><br><span class="line">public Adapter(Person person) &#123;</span><br><span class="line">this.person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void speakEnglish() &#123;</span><br><span class="line">person.speakEnglish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void speakJapanese() &#123;</span><br><span class="line">person.speakJapanese();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//new add</span><br><span class="line">public void speakFrench() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的适配器模式，把“源”作为一个构造参数传入适配器，然后执行接口所要求的方法。这种适配模式可以为多个源进行适配。弥补了类适配模式的不足。</p><p>现在来对2种适配模式做个分析：</p><p>1.类的适配模式用于单一源的适配，由于它的源的单一话，代码实现不用写选择逻辑，很清晰；而对象的适配模式则可用于多源的适配，弥补了类适配模式的不足，使得原本用类适配模式需要写很多适配器的情况不复存在，弱点是，由于源的数目可以较多，所以具体的实现条件选择分支比较多，不太清晰。</p><p>2.适配器模式主要用于几种情况：（1）系统需要使用现有的类，但现有的类不完全符合需要。（2）讲彼此没有太大关联的类引进来一起完成某项工作（指对象适配）。</p><p>最后，再来顺带谈谈默认适配器模式：这种模式的核心归结如下：当你想实现一个接口但又不想实现所有接口方法，只想去实现一部分方法时，就用中默认的适配器模式，他的方法是在接口和具体实现类中添加一个抽象类，而用抽象类去空实现目标接口的所有方法。而具体的实现类只需要覆盖其需要完成的方法即可。代码如下：</p><p>接口类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Job &#123;</span><br><span class="line"></span><br><span class="line">public abstract void speakJapanese();</span><br><span class="line">public abstract void speakEnglish();</span><br><span class="line">public abstract void speakFrench();</span><br><span class="line">public abstract void speakChinese();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class JobDefault implements Job&#123;</span><br><span class="line"></span><br><span class="line">public void speakChinese() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void speakEnglish() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void speakFrench() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void speakJapanese() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class JobImpl extends JobDefault&#123;</span><br><span class="line"></span><br><span class="line">public void speakChinese()&#123;</span><br><span class="line">System.out.println(&quot;I can speak Chinese!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接：<a href="https://blog.csdn.net/elegant_shadow/article/details/5006175" target="_blank" rel="noopener">https://blog.csdn.net/elegant_shadow/article/details/5006175</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过继承来扩展接口</title>
      <link href="/2019/09/15/%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/09/15/%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>通过继承，可以容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。</p><a id="more"></a><p>这两种情况都可以获得新的接口，就像在下例中所看到的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">interface Monster&#123;void menace();&#125;</span><br><span class="line"></span><br><span class="line">interface DangerousMonster extends Monster&#123;</span><br><span class="line">void destory();</span><br><span class="line">&#125;</span><br><span class="line">interface Lethal&#123;</span><br><span class="line">void Kill();</span><br><span class="line">&#125;</span><br><span class="line">class DragonZillz implements DangerousMonster&#123;</span><br><span class="line">public void menace() &#123;System.out.println(&quot;DragonZillz.menace() &quot;);&#125;</span><br><span class="line">public void destory() &#123;System.out.println(&quot;DragonZillz.destory() &quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Vampire extends DangerousMonster,Lethal&#123;</span><br><span class="line">void drinkBlood();</span><br><span class="line">&#125;</span><br><span class="line">class VerBadVampire implements Vampire&#123;</span><br><span class="line">public void menace() &#123;System.out.println(&quot;VerBadVampire.menace() &quot;);&#125;</span><br><span class="line">public void destory() &#123;System.out.println(&quot;VerBadVampire.destory() &quot;);&#125;</span><br><span class="line">public void Kill() &#123;System.out.println(&quot;VerBadVampire.kill() &quot;);&#125;</span><br><span class="line">public void drinkBlood() &#123;System.out.println(&quot;VerBadVampire.drinkBlood() &quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class HorrorShow&#123;</span><br><span class="line">static void u(Monster b) &#123;b.menace();&#125;</span><br><span class="line">static void v(DangerousMonster d) &#123;</span><br><span class="line">d.menace();d.destory();</span><br><span class="line">&#125;</span><br><span class="line">static void w(Lethal l) &#123;l.Kill();&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">DangerousMonster barney = new DragonZillz();</span><br><span class="line">u(barney);v(barney);</span><br><span class="line">Vampire vlad = new VerBadVampire();</span><br><span class="line">u(vlad);v(vlad);w(vlad);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">DragonZillz.menace() </span><br><span class="line">DragonZillz.menace() </span><br><span class="line">DragonZillz.destory() </span><br><span class="line">VerBadVampire.menace() </span><br><span class="line">VerBadVampire.menace() </span><br><span class="line">VerBadVampire.destory() </span><br><span class="line">VerBadVampire.kill() </span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>我看过之后有些许懵逼。。</p><p>DangerousMonster是Monster的直接扩展，它产生了一个新接口。DragonZilla中实现了这个接口。</p><p>在Vampire中使用的语法仅适用于接口继承。一般情况下，只可以将extends用于单一类，但是可以引用多个基类接口。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的多重继承</title>
      <link href="/2019/09/15/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/09/15/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>Java中的多重继承</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface CanFight&#123;</span><br><span class="line">void fight();</span><br><span class="line">&#125;</span><br><span class="line">interface CanSwim&#123;</span><br><span class="line">void swim();</span><br><span class="line">&#125;</span><br><span class="line">interface CanFly&#123;</span><br><span class="line">void fly();</span><br><span class="line">&#125;</span><br><span class="line">class ActionCharacter&#123;</span><br><span class="line">public void fight() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hero extends ActionCharacter implements CanFight,CanSwim,CanFly&#123;</span><br><span class="line">public void swim() &#123;&#125;</span><br><span class="line">public void fly() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Adventure&#123;</span><br><span class="line">public static void t(CanFight x) &#123;x.fight();&#125;</span><br><span class="line">public static void u(CanSwim x) &#123;x.swim();&#125;</span><br><span class="line">public static void v(CanFly x) &#123;x.fly();&#125;</span><br><span class="line">public static void w(ActionCharacter x) &#123;x.fight();&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Hero h = new Hero();</span><br><span class="line">t(h);</span><br><span class="line">u(h);</span><br><span class="line">v(h);</span><br><span class="line">w(h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class.getName()和class.getSimpleName()的区别</title>
      <link href="/2019/09/15/class-getName-%E5%92%8Cclass-getSimpleName-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/09/15/class-getName-%E5%92%8Cclass-getSimpleName-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>class.getName()和class.getSimpleName()的区别</p><a id="more"></a><p>Class.getName()：以String的形式，返回Class对象的“实体”名称；</p><p>Class.getSimpleName()：获取源代码中给出的“底层类”简称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">private static final String TAG1 = Main.class.getName();</span><br><span class="line">private static final String TAG2 = Main.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;getName ----- &quot; + TAG1 + &quot;\n&quot; + &quot;getSimpleName ----- &quot; + TAG2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">getName ---- com.se7en.test.Main</span><br><span class="line">getSimpleName ---- Main</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>getName —-“实体名称” —- com.se7en.test.Main</p><p>getSimpleName —- “底层类简称” —- Main</p><p>getName() 获取包名+类名;getSimpleName() 获取类名。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> getName() </tag>
            
            <tag> getSimpleName() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程思想第九章练习</title>
      <link href="/2019/09/15/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/09/15/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>编程思想第九章练习</p><a id="more"></a><h2 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a>练习1：</h2><p>（1）修改第八章练习9中的Rodnet，使其成为一个抽象类。只要有能，就将Rodent的方法声明为抽象方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         Rodent rodents[] = &#123;new Mouse(),new Gerbil(),new Hamster()&#125;;</span><br><span class="line">         for(Rodent r: rodents) &#123;</span><br><span class="line">             r.hop();</span><br><span class="line">             r.run();</span><br><span class="line">             System.out.println(r);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class Rodent&#123;</span><br><span class="line">    public abstract void hop();</span><br><span class="line">    public abstract void run();</span><br><span class="line">    public String toString() &#123;return &quot;Rodent&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Mouse extends Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Mouse hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Mouse run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Mouse&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Gerbil extends Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Gerbil hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Gerbil run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Gernil&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hamster extends Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Hamster hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Hamster run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Hamster&quot;;&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Mouse hop</span><br><span class="line">Mouse run</span><br><span class="line">Mouse</span><br><span class="line">Gerbil hop</span><br><span class="line">Gerbil run</span><br><span class="line">Gernil</span><br><span class="line">Hamster hop</span><br><span class="line">Hamster run</span><br><span class="line">Hamster</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h2><p>（1）创建一个不包含任何抽象方法的抽象类，并验证我们不能为该类创建任何实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Rodent r = new Rodent(); //不能实例化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class Rodent&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a>练习3：</h2><p>（2）创建一个基类，让它包含抽象方法print()，并在导出类中覆盖该方法。覆盖后的方法版本可以打印导出类中定义的某个整型变量的值。在定义该变量之处，赋予它非零值。在基类的构造器中调用这个方法。现在，在main()方法中，创建一个导出列对象，然后调用它的print()方法。请解释发生的情形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       B b =new B();</span><br><span class="line">       b.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class A&#123;</span><br><span class="line">abstract void print();</span><br><span class="line">A() &#123;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">int i = 2;</span><br><span class="line">void print() &#123;</span><br><span class="line">System.out.println(&quot;B.print() &quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">B.print() 0  //“构造器内部的多态方法的行为”一文中有解释</span><br><span class="line">B.print() 2</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习4："><a href="#练习4：" class="headerlink" title="练习4："></a>练习4：</h2><p>(3)创建一个不包含任何方法的抽象类，从它那里导出一个类，并添加一个方法。创建一个静态方法，它可以接受指向基类的引用，将其向下转型到导出类，然后再调用该静态方法。再main()中，展示它的运行情况。然后，为基类中的方法加上abstract声明，这样就不再需要进行向下转型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestAbstract &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Dog animal = new Dog();</span><br><span class="line">aniamlShout(animal);</span><br><span class="line">&#125;</span><br><span class="line">static void aniamlShout(Animal animal) &#123;</span><br><span class="line">Dog dog = (Dog)animal;</span><br><span class="line">dog.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">void eat() &#123;</span><br><span class="line">System.out.println(&quot;Dog.eat() food&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Dog.eat() food</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TestAbstract &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Dog animal = new Dog();</span><br><span class="line">aniamlShout(animal);</span><br><span class="line">&#125;</span><br><span class="line">static void aniamlShout(Animal animal) &#123;</span><br><span class="line">animal.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">void eat() &#123;</span><br><span class="line">System.out.println(&quot;Dog.eat() food&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Dog.eat() food</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习5："><a href="#练习5：" class="headerlink" title="练习5："></a>练习5：</h2><p>（2）在某个包内一个接口，内含三个方法，然后在另一个包中实现此接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.testone;</span><br><span class="line"></span><br><span class="line">public interface A&#123;</span><br><span class="line">void one();</span><br><span class="line">void two();</span><br><span class="line">void three();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package cn.testtwo;</span><br><span class="line">import cn.testone.*;</span><br><span class="line"></span><br><span class="line">public class Test implements A&#123;</span><br><span class="line">@Override</span><br><span class="line">public void one() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void two() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void three() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习6："><a href="#练习6：" class="headerlink" title="练习6："></a>练习6：</h2><p>(2)证明接口内所有的方法都自动是public的。</p><h2 id="练习7："><a href="#练习7：" class="headerlink" title="练习7："></a>练习7：</h2><p>(1)修改第8章中的练习9，使Rodent成为一个接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">interface Rodent&#123;</span><br><span class="line">    public void hop();</span><br><span class="line">    public void run();</span><br><span class="line">    public String toString();</span><br><span class="line">&#125;</span><br><span class="line">class Mouse implements Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Mouse hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Mouse run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Mouse&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Gerbil implements Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Gerbil hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Gerbil run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Gernil&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hamster implements Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Hamster hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Hamster run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Hamster&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         Rodent rodents[] = &#123;new Mouse(),new Gerbil(),new Hamster()&#125;;</span><br><span class="line">         for(Rodent r: rodents) &#123;</span><br><span class="line">             r.hop();</span><br><span class="line">             r.run();</span><br><span class="line">             System.out.println(r);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Mouse hop</span><br><span class="line">Mouse run</span><br><span class="line">Mouse</span><br><span class="line">Gerbil hop</span><br><span class="line">Gerbil run</span><br><span class="line">Gernil</span><br><span class="line">Hamster hop</span><br><span class="line">Hamster run</span><br><span class="line">Hamster</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习8："><a href="#练习8：" class="headerlink" title="练习8："></a>练习8：</h2><p>(2)在polymorphism.Sandwich.java中，创建接口FastFood并添加合适的方法，然后修改Sandwith以实现FastFood接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class Meal &#123;</span><br><span class="line">Meal() &#123;</span><br><span class="line">System.out.println(&quot;Meal()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bread &#123;</span><br><span class="line">Bread() &#123;</span><br><span class="line">System.out.println(&quot;Bread()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cheese &#123;</span><br><span class="line">Cheese() &#123;</span><br><span class="line">System.out.println(&quot;Cheese()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Lettuce &#123;</span><br><span class="line">Lettuce() &#123;</span><br><span class="line">System.out.println(&quot;Lettuce()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Lunch extends Meal &#123;</span><br><span class="line">Lunch() &#123;</span><br><span class="line">System.out.println(&quot;Lunch()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class PortableLunch extends Lunch &#123;</span><br><span class="line">PortableLunch() &#123;</span><br><span class="line">System.out.println(&quot;PortableLunch()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface FastFood &#123;</span><br><span class="line">void first();</span><br><span class="line">void second();</span><br><span class="line">void third();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test extends PortableLunch implements FastFood &#123;</span><br><span class="line">private Bread b = new Bread();</span><br><span class="line">private Cheese c = new Cheese();</span><br><span class="line">private Lettuce l = new Lettuce();</span><br><span class="line"></span><br><span class="line">// public Sandwich() &#123; print(&quot;Sandwich()&quot;); &#125;</span><br><span class="line">public void first() &#123;</span><br><span class="line">System.out.println(&quot;first()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void second() &#123;</span><br><span class="line">System.out.println(&quot;second()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void third() &#123;</span><br><span class="line">System.out.println(&quot;third()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test ja = new Test();</span><br><span class="line">ja.first();</span><br><span class="line">ja.second();</span><br><span class="line">ja.third();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Meal()</span><br><span class="line">Lunch()</span><br><span class="line">PortableLunch()</span><br><span class="line">Bread()</span><br><span class="line">Cheese()</span><br><span class="line">Lettuce()</span><br><span class="line">first()</span><br><span class="line">second()</span><br><span class="line">third()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习9："><a href="#练习9：" class="headerlink" title="练习9："></a>练习9：</h2><p>(3)重构Music5.java，将在Wind、Percussion和Stringed中的公共方法移入一个抽象类中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">enum Note &#123;</span><br><span class="line">    MIDDLE_C, C_SHARP, B_FLAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Instrument &#123;</span><br><span class="line">    public void play(Note n) &#123;</span><br><span class="line">        System.out.println(this + &quot;.play() &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">    public void adjust() &#123;</span><br><span class="line">        System.out.println(this + &quot;.adjust()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract String toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Wind extends Instrument &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Wind&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Percussion extends Instrument &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Percussion&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stringed extends Instrument &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Stringed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Brass extends Wind &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Brass&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Woodwind extends Wind &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Woodwind&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    static void tune(Instrument i) &#123;</span><br><span class="line">        i.adjust();</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    static void tuneAll(Instrument[] e) &#123;</span><br><span class="line">        for (Instrument instrument : e) &#123;</span><br><span class="line">            tune(instrument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Instrument[] ins = &#123;</span><br><span class="line">                new Wind(),</span><br><span class="line">                new Percussion(),</span><br><span class="line">                new Stringed(),</span><br><span class="line">                new Brass(),</span><br><span class="line">                new Woodwind()</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(ins);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Wind.adjust()</span><br><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Percussion.adjust()</span><br><span class="line">Percussion.play() MIDDLE_C</span><br><span class="line">Stringed.adjust()</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.adjust()</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">Woodwind.adjust()</span><br><span class="line">Woodwind.play() MIDDLE_C</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习10："><a href="#练习10：" class="headerlink" title="练习10："></a>练习10：</h2><p>(3)修改Music5.java，添加Playable接口。将play()的声明从Instrument中移到Playable中。通过将Playable包括在implements列表中，把Playable添加到导出类中。修改tune()，使它接受Playable而不是Instrumnet作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">enum Note &#123;</span><br><span class="line">    MIDDLE_C, C_SHARP, B_FLAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Instrument &#123;</span><br><span class="line">    void adjust();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Playable &#123;</span><br><span class="line">    void play(Note n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Wind implements Instrument, Playable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void play(Note n) &#123;</span><br><span class="line">        System.out.println(this + &quot;.play() &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void adjust() &#123;</span><br><span class="line">        System.out.println(this + &quot;.adjust()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Wind&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Percussion implements Instrument, Playable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void play(Note n) &#123;</span><br><span class="line">        System.out.println(this + &quot;.play() &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void adjust() &#123;</span><br><span class="line">        System.out.println(this + &quot;.adjust()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Percussion&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stringed implements Instrument, Playable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void play(Note n) &#123;</span><br><span class="line">        System.out.println(this + &quot;.play() &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void adjust() &#123;</span><br><span class="line">        System.out.println(this + &quot;.adjust()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Stringed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Brass extends Wind &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Brass&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Woodwind extends Wind &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Woodwind&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    static void tune(Playable p) &#123;</span><br><span class="line">        p.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    static void tuneAll(Playable[] e) &#123;</span><br><span class="line">        for (Playable playable : e) &#123;</span><br><span class="line">            tune(playable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Playable[] ps = &#123;</span><br><span class="line">                new Wind(),</span><br><span class="line">                new Percussion(),</span><br><span class="line">                new Stringed(),</span><br><span class="line">                new Brass(),</span><br><span class="line">                new Woodwind()</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Percussion.play() MIDDLE_C</span><br><span class="line">Stringed.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">Woodwind.play() MIDDLE_C</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习12："><a href="#练习12：" class="headerlink" title="练习12："></a>练习12：</h2><p>(2)在Adventure.java中，按照其他接口的样式，增加一个CanClimb接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">interface CanFight&#123;</span><br><span class="line">void fight();</span><br><span class="line">&#125;</span><br><span class="line">interface CanSwim&#123;</span><br><span class="line">void swim();</span><br><span class="line">&#125;</span><br><span class="line">interface CanFly&#123;</span><br><span class="line">void fly();</span><br><span class="line">&#125;</span><br><span class="line">interface CanClimb&#123;</span><br><span class="line">void play();</span><br><span class="line">&#125;</span><br><span class="line">class ActionCharacter&#123;</span><br><span class="line">public void fight() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hero extends ActionCharacter implements CanFight,CanSwim,CanFly,CanClimb&#123;</span><br><span class="line">public void swim() &#123;&#125;</span><br><span class="line">public void fly() &#123;&#125;</span><br><span class="line">public void play() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Adventure&#123;</span><br><span class="line">public static void t(CanFight x) &#123;x.fight();&#125;</span><br><span class="line">public static void u(CanSwim x) &#123;x.swim();&#125;</span><br><span class="line">public static void v(CanFly x) &#123;x.fly();&#125;</span><br><span class="line">public static void w(ActionCharacter x) &#123;x.fight();&#125;</span><br><span class="line">public static void p(CanClimb x) &#123;x.play();&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Hero h = new Hero();</span><br><span class="line">t(h);</span><br><span class="line">u(h);</span><br><span class="line">v(h);</span><br><span class="line">w(h);</span><br><span class="line">p(h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习13："><a href="#练习13：" class="headerlink" title="练习13："></a>练习13：</h2><p>(2)创建一个接口，并从该接口继承两个接口，然后从后面两个接口多重继承第三个接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">void aa();</span><br><span class="line">&#125;</span><br><span class="line">interface B extends A&#123;</span><br><span class="line">void bb();</span><br><span class="line">&#125;</span><br><span class="line">interface C extends A&#123;</span><br><span class="line">void cc();</span><br><span class="line">&#125;</span><br><span class="line">interface D extends B,C&#123;</span><br><span class="line">void dd();</span><br><span class="line">&#125;</span><br><span class="line">public class Test implements D&#123;</span><br><span class="line">public void bb() &#123;System.out.println(&quot;bb&quot;);&#125;</span><br><span class="line">public void aa() &#123;System.out.println(&quot;aa&quot;);&#125;</span><br><span class="line">public void cc() &#123;System.out.println(&quot;cc&quot;);&#125;</span><br><span class="line">public void dd() &#123;System.out.println(&quot;dd&quot;);&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test test = new Test();</span><br><span class="line">test.bb();</span><br><span class="line">test.aa();</span><br><span class="line">test.cc();</span><br><span class="line">test.dd();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">bb</span><br><span class="line">aa</span><br><span class="line">cc</span><br><span class="line">dd</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习14："><a href="#练习14：" class="headerlink" title="练习14："></a>练习14：</h2><p>(2)创建三个接口，每个接口都包含两个方法。继承出一个接口，它组了这三个接口并添加了一个新方法。创建一个实现了该新接口并且继承了某个具体类的类。现在编写四个方法，每一个狗接受这四个接口之一作为参数。在main()方法中，创建这个类的对象，并将其传递给这四个方法。</p><h2 id="练习15："><a href="#练习15：" class="headerlink" title="练习15："></a>练习15：</h2><p>(2)将前一个练习修改为：创建一个抽象类，并将其继承到一个导出类中。</p><h2 id="练习16："><a href="#练习16：" class="headerlink" title="练习16："></a>练习16：</h2><p>(3)创建一个类，它将生成一个char序列，适配这个类，使其可以称为Scanner对象的一种输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.CharBuffer;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class RandomChars&#123;</span><br><span class="line">private static Random rd = new Random();</span><br><span class="line">public char next() &#123;</span><br><span class="line">return (char)(rd.nextInt(100)+2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test extends RandomChars implements Readable&#123;</span><br><span class="line"></span><br><span class="line">private int count;</span><br><span class="line">public Test(int count) &#123;this.count=count;&#125;</span><br><span class="line">public int read(CharBuffer cb) &#123;</span><br><span class="line">if(count--==0) &#123;return -1;&#125;</span><br><span class="line">String result=Character.toString(next())+&quot; &quot;;</span><br><span class="line">cb.append(result);</span><br><span class="line">return result.length();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner s = new Scanner(new Test(7));</span><br><span class="line">while(s.hasNext()) &#123;</span><br><span class="line">System.out.println(s.next()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习17："><a href="#练习17：" class="headerlink" title="练习17："></a>练习17：</h2><p>(2)证明在接口中的域隐式地为static和final的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">int a = 1,b =2;</span><br><span class="line">&#125;</span><br><span class="line">public class Test implements A&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(a+&quot; &quot;+b);</span><br><span class="line">//a=2; //不能对final字段 A.a 赋值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习18"><a href="#练习18" class="headerlink" title="练习18:"></a>练习18:</h2><p>(2)创建一个Cycle接口及其Unicycle、Bicycle和Tricycle实现。对每种类型的Cycle都创建相应的工厂，然后编写代码使用这些工厂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">interface Cycle&#123;</span><br><span class="line">void f();</span><br><span class="line">&#125;</span><br><span class="line">interface CycleFactory&#123;</span><br><span class="line">Cycle getCycle();</span><br><span class="line">&#125;</span><br><span class="line">class Unicycle implements Cycle&#123;</span><br><span class="line">public void f() &#123;</span><br><span class="line">System.out.println(&quot;Unicycle.f() &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class UnicycleFactory implements CycleFactory&#123;</span><br><span class="line">public Cycle getCycle() &#123;</span><br><span class="line">return new Unicycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bicycle implements Cycle&#123;</span><br><span class="line">public void f() &#123;</span><br><span class="line">System.out.println(&quot;Bicycle.f() &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class BicycleFactory implements CycleFactory&#123;</span><br><span class="line">public Cycle getCycle() &#123;</span><br><span class="line">return new Bicycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Tricycle implements Cycle&#123;</span><br><span class="line">public void f() &#123;</span><br><span class="line">System.out.println(&quot;Tricycle.f() &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class TricycleFactory implements CycleFactory&#123;</span><br><span class="line">public Cycle getCycle() &#123;</span><br><span class="line">return new Tricycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Games&#123;</span><br><span class="line">public static void playGame(CycleFactory factory) &#123;</span><br><span class="line">Cycle s = factory.getCycle();</span><br><span class="line">s.f();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">playGame(new UnicycleFactory());</span><br><span class="line">playGame(new BicycleFactory());</span><br><span class="line">playGame(new TricycleFactory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Outpur:</span><br><span class="line">Unicycle.f() </span><br><span class="line">Bicycle.f() </span><br><span class="line">Tricycle.f() </span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习19："><a href="#练习19：" class="headerlink" title="练习19："></a>练习19：</h2><p>(3)使用工厂方法来创建一个框架，它可以执行抛硬币和掷骰子功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">interface Game&#123;</span><br><span class="line">void print();</span><br><span class="line">&#125;</span><br><span class="line">interface GameFactory&#123;</span><br><span class="line">Game getGame();</span><br><span class="line">&#125;</span><br><span class="line">class Coin implements Game&#123;</span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(&quot;toss a coin &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class CoinFactory implements GameFactory&#123;</span><br><span class="line">public Game getGame() &#123;</span><br><span class="line">return new Coin();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dice implements Game&#123;</span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(&quot;dice &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class DiceFactory implements GameFactory&#123;</span><br><span class="line">public Game getGame() &#123;</span><br><span class="line">return new Dice();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Games&#123;</span><br><span class="line">public static void playGame(GameFactory factory) &#123;</span><br><span class="line">Game s = factory.getGame();</span><br><span class="line">s.print();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">playGame(new CoinFactory());</span><br><span class="line">playGame(new DiceFactory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">toss a coin </span><br><span class="line">dice </span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类和抽象方法</title>
      <link href="/2019/09/15/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/15/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>抽象类和抽象方法</p><a id="more"></a><h2 id="什么是抽象类？"><a href="#什么是抽象类？" class="headerlink" title="什么是抽象类？"></a>什么是抽象类？</h2><p>用abstract定义类</p><h2 id="什么是抽象方法？"><a href="#什么是抽象方法？" class="headerlink" title="什么是抽象方法？"></a>什么是抽象方法？</h2><p>用absctract定义方法</p><p>1、包含抽象方法的类叫做抽象类</p><p>2、抽象类不能直接实例化，也就是不能直接使用new关键字产生对象</p><p>如果继承了一个抽象类，并想创建新类的对象，那么就必须为基类中所有抽象方法提供方法定义。</p><p>如果不提供，编译器会强制用abstract关键字来限定这个导出类，使导出类也变为抽象类。</p><p>如果基类中的方法有方法体，那么导出类就可以不提供对方法的定义。</p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;</span><br><span class="line">abstract void f();</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">void f() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;</span><br><span class="line">abstract void f();</span><br><span class="line">&#125;</span><br><span class="line">abstract class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;</span><br><span class="line">void f() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> 抽象方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向下转型</title>
      <link href="/2019/09/15/%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
      <url>/2019/09/15/%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，所以也可以通过向下转型——也就是在继承层次中向下移动——应该能够获取类型信息。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Useful&#123;</span><br><span class="line">public void f() &#123;&#125;</span><br><span class="line">public void g() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MoreUseful extends Useful&#123;</span><br><span class="line">public void f() &#123;&#125;</span><br><span class="line">public void g() &#123;&#125;</span><br><span class="line">public void u() &#123;&#125;</span><br><span class="line">public void v() &#123;&#125;</span><br><span class="line">public void w() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class RTTI&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Useful[] x = &#123;</span><br><span class="line">new Useful(),</span><br><span class="line">new MoreUseful()</span><br><span class="line">&#125;;</span><br><span class="line">x[0].f();</span><br><span class="line">x[1].g();</span><br><span class="line">//Compile time: method not found in Useful:</span><br><span class="line">//! x[1].u();</span><br><span class="line">((MoreUseful)x[1]).u();  //Downcast/RTTI</span><br><span class="line">((MoreUseful)x[0]).u();  //Exception thrown</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MoreUseful接口扩展了Useful接口；数组中的两个对象都属于Useful类，所以可以用f()和g()这两个方法。如果试图调用u()方法（它只存在于MoreUseful），就会返回一条编译时出错消息。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 向下转型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协变返回类型</title>
      <link href="/2019/09/15/%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/09/15/%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>协变返回类型</p><a id="more"></a><p>百度了一下，有一种说法是：</p><p>在Java1.4及以前，子类方法如果要覆盖超类的某个方法，必须具有完全相同的方法签名，包括返回值也必须完全一样。</p><p>Java5.0放宽了这一限制，只要子类方法与超类方法具有相同的方法签名，或者子类方法的返回值是超类方法的子类型，就可以覆盖。</p><p>注意：”协变返回(covariant return)”，仅在subclass（子类）的返回类型是superclass（父类）返回类型的extension（继承）时才被容许。</p><p>———————————-分割线————————————————-</p><p>Java SE5中添加了协变返回类型，它表示在导出类中被覆盖方法可以返回基类方法的返回类型的某种导出类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Grain&#123;</span><br><span class="line">public String toString() &#123;return &quot;Grain&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wheat extends Grain&#123;</span><br><span class="line">public String toString() &#123;return &quot;Wheat&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Mill&#123;</span><br><span class="line">Grain process() &#123;return new Grain();&#125;</span><br><span class="line">&#125;</span><br><span class="line">class WheatMill extends Mill&#123;</span><br><span class="line">Wheat process() &#123;return new Wheat();&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CovariantReturn&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Mill m = new Mill();</span><br><span class="line">Grain g = m.process();</span><br><span class="line">System.out.println(g);</span><br><span class="line">m = new WheatMill();</span><br><span class="line">g = m.process();</span><br><span class="line">System.out.println(g);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Grain</span><br><span class="line">Wheat</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>Java SE5与较早版本之间的主要差异就是较早的版本将强制process()的覆盖版本必须返回Grain()，而不能返回Wheat()，尽管Wheat是从Grain导出的，因而应该是以一种合法的返回类型。协变返回类型允许返回更具体的Wheat类型。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 协变返回 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造器内部的多态方法的行为</title>
      <link href="/2019/09/15/%E6%9E%84%E9%80%A0%E5%99%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%8C%E4%B8%BA/"/>
      <url>/2019/09/15/%E6%9E%84%E9%80%A0%E5%99%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%8C%E4%B8%BA/</url>
      
        <content type="html"><![CDATA[<p>构造器内部的多态方法的行为</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Glyph&#123;</span><br><span class="line">void draw() &#123;System.out.println(&quot;Glyph.draw()&quot;);&#125;</span><br><span class="line">Glyph()&#123;</span><br><span class="line">System.out.println(&quot;Glyph() before draw()&quot;);</span><br><span class="line">draw();</span><br><span class="line">System.out.println(&quot;Glyph() after draw()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class RoundGlyph extends Glyph&#123;</span><br><span class="line">private int radius = 1;</span><br><span class="line">RoundGlyph(int r) &#123;</span><br><span class="line">radius = r;</span><br><span class="line">System.out.println(&quot;RoundGlyph.RoundGlyph().radius = &quot;+radius);</span><br><span class="line">&#125;</span><br><span class="line">void draw() &#123;</span><br><span class="line">System.out.println(&quot;RoundGlyph.draw().radius = &quot;+radius);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class PolyConstructors&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new RoundGlyph(5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Glyph() before draw()</span><br><span class="line">RoundGlyph.draw().radius = 0   //1</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RoundGlyph.RoundGlyph().radius = 5</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>为什么在1处输出的为0？</p><p>Glyph.draw()方法设计为将要覆盖，这种覆盖是在RoundGlyph中发生的。但是Glyph构造器会调用这个方法，结果导致了对RoundGlyph.draw()的调用。</p><p>但输出结果不是默认值1，而是0。</p><p>初始化的实际过程：<br>1、在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。</p><p>2、如果所述那样调用基类构造器。此时，调用被覆盖后的draw()方法（要在调用RoundGlyph构造器之前调用），由于步骤1的缘故，我们此使会发现radius的值为0。</p><p>3、按照声明的顺序调用成员的初始化。</p><p>4、调用导出类的构造器主题</p><p>在构造器内唯一能够安全调用的哪些方法是基类的final方法（也适用于private方法，它们自动属于final方法）。这些方法不能被覆盖，因此也就不会出现上述令人惊讶的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protected关键字</title>
      <link href="/2019/09/15/protected%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/09/15/protected%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>如果希望超类中的某些方法允许被子类访问，或者允许子类的方法访问超类的某个域，为此需要将这些方法或域设置为protected。</p><a id="more"></a><p>下面是编程思想中的一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Villain&#123;</span><br><span class="line">private String name;</span><br><span class="line">protected void set(String nm) &#123;name = nm;&#125;</span><br><span class="line">public Villain(String name) &#123;this.name=name;&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;I&apos;m a Villain and my name is &quot;+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Orc extends Villain&#123;</span><br><span class="line">private int orcNumber;</span><br><span class="line">public Orc(String name,int orcNumber) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.orcNumber = orcNumber;</span><br><span class="line">&#125;</span><br><span class="line">public void change(String name,int orcNumber) &#123;</span><br><span class="line">set(name);</span><br><span class="line">this.orcNumber = orcNumber;</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Orc &quot;+orcNumber+&quot;: &quot;+super.toString();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Orc orc  = new Orc(&quot;Limburger&quot;,12);</span><br><span class="line">System.out.println(orc);</span><br><span class="line">orc.change(&quot;Bob&quot;,19);</span><br><span class="line">System.out.println(orc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Orc 12: I&apos;m a Villain and my name is Limburger</span><br><span class="line">Orc 19: I&apos;m a Villain and my name is Bob</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>change()可以访问set(),这是因为它是protected。</p><p>但是我换成public后依然可以运行，不懂为什么要用protected。</p><p>———————————–分割线———————————————————————————————————————————-</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> protected </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与清理</title>
      <link href="/2019/09/15/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B8%85%E7%90%86/"/>
      <url>/2019/09/15/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>继承与清理</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">class Characteristic&#123;</span><br><span class="line">private String s;</span><br><span class="line">Characteristic(String s) &#123;</span><br><span class="line">this.s = s;</span><br><span class="line">System.out.println(&quot;Creating Characteristic &quot;+s);</span><br><span class="line">&#125;</span><br><span class="line">protected void dispose() &#123;</span><br><span class="line">System.out.println(&quot;disposing Characteristic &quot;+s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Description&#123;</span><br><span class="line">private String s;</span><br><span class="line">Description(String s) &#123;</span><br><span class="line">this.s = s;</span><br><span class="line">System.out.println(&quot;Creating Descripion &quot;+s);</span><br><span class="line">&#125;</span><br><span class="line">protected void dispose() &#123;</span><br><span class="line">System.out.println(&quot;disposing Description &quot;+s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class LivingCreature&#123;</span><br><span class="line">private Characteristic p= new Characteristic(&quot;is alive&quot;);</span><br><span class="line">private Description t = new Description(&quot;Basic Living Creature&quot;);</span><br><span class="line">LivingCreature()&#123;</span><br><span class="line">System.out.println(&quot;LivingCreature()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">protected void dispose() &#123;</span><br><span class="line">System.out.println(&quot;LivingCreature dispose&quot;);</span><br><span class="line">t.dispose();</span><br><span class="line">p.dispose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal extends LivingCreature&#123;</span><br><span class="line">private Characteristic p = new Characteristic(&quot;has heart&quot;);</span><br><span class="line">private Description t = new Description(&quot;Animal not Vegetable&quot;);</span><br><span class="line">Animal()&#123;System.out.println(&quot;Animal()&quot;);&#125;</span><br><span class="line">protected void dispose() &#123;</span><br><span class="line">System.out.println(&quot;Animal dispose&quot;);</span><br><span class="line">t.dispose();</span><br><span class="line">p.dispose();</span><br><span class="line">super.dispose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Amphibian extends Animal&#123;</span><br><span class="line">private Characteristic p = new Characteristic(&quot;can live in water&quot;);</span><br><span class="line">private Description t = new Description(&quot;Both water and land&quot;);</span><br><span class="line">Amphibian()&#123;</span><br><span class="line">System.out.println(&quot;Amphibian()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">protected void dispose() &#123;</span><br><span class="line">System.out.println(&quot;Amphibian dispose&quot;);</span><br><span class="line">t.dispose();</span><br><span class="line">p.dispose();</span><br><span class="line">super.dispose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Frog extends Amphibian&#123;</span><br><span class="line">private Characteristic p = new Characteristic(&quot;Croaks&quot;);</span><br><span class="line">private Description t = new Description(&quot;Eats Bugs&quot;);</span><br><span class="line">public Frog() &#123;System.out.println(&quot;Frog()&quot;);&#125;</span><br><span class="line">protected void dispose() &#123;</span><br><span class="line">System.out.println(&quot;Frog dispose&quot;);</span><br><span class="line">t.dispose();</span><br><span class="line">p.dispose();</span><br><span class="line">super.dispose();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Frog frog = new Frog();</span><br><span class="line">System.out.println(&quot;Bye!&quot;);</span><br><span class="line">frog.dispose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Creating Characteristic is alive</span><br><span class="line">Creating Descripion Basic Living Creature</span><br><span class="line">LivingCreature()</span><br><span class="line">Creating Characteristic has heart</span><br><span class="line">Creating Descripion Animal not Vegetable</span><br><span class="line">Animal()</span><br><span class="line">Creating Characteristic can live in water</span><br><span class="line">Creating Descripion Both water and land</span><br><span class="line">Amphibian()</span><br><span class="line">Creating Characteristic Croaks</span><br><span class="line">Creating Descripion Eats Bugs</span><br><span class="line">Frog()</span><br><span class="line">Bye!</span><br><span class="line">Frog dispose</span><br><span class="line">disposing Description Eats Bugs</span><br><span class="line">disposing Characteristic Croaks</span><br><span class="line">Amphibian dispose</span><br><span class="line">disposing Description Both water and land</span><br><span class="line">disposing Characteristic can live in water</span><br><span class="line">Animal dispose</span><br><span class="line">disposing Description Animal not Vegetable</span><br><span class="line">disposing Characteristic has heart</span><br><span class="line">LivingCreature dispose</span><br><span class="line">disposing Description Basic Living Creature</span><br><span class="line">disposing Characteristic is alive</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、java中进行清理时要小心，在清理函数dispose()中数据成员的销毁顺序应该与声明的顺序相反，并且记得要调用基类的清理函数对基类进行清理（采用super.dispose()语句实现）；</p><p>2、对于字段，与声明的顺序相反进行清理；对于基类，应该首先对其导出类进行清理，然后才是基类（这是因为导出类的清理可能会调用基类中的某些方法，所以需要基类中的构件仍起作用而不应该过早地销毁它们。）</p><p>3、对象的所有部分都是按照创建的逆序进行销毁。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承中的构造方法执行顺序</title>
      <link href="/2019/09/15/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2019/09/15/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>查阅资料时发现了这段代码，当我想搞明白它的执行顺序时，出现了问题。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class FatherClass &#123;</span><br><span class="line">    public FatherClass() &#123;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public FatherClass(int age) &#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SonClass extends FatherClass &#123;</span><br><span class="line">    public SonClass() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public SonClass(int c) &#123;</span><br><span class="line">        System.out.println(2);</span><br><span class="line">    &#125;</span><br><span class="line">    public SonClass(int a, int b) &#123;</span><br><span class="line">        super(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new SonClass();</span><br><span class="line">        new SonClass(10);</span><br><span class="line">        new SonClass(10, 11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>为什么会输出两个1呢？</p><p>知识学不牢靠就是，真是懵逼。。</p><p>————————————————————–分割线——————————————-</p><p>转自 <a href="https://blog.csdn.net/weixin_44706512/article/details/89349076" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44706512/article/details/89349076</a></p><h2 id="在子类的构造方法的第一行代码如果没有调用父类的构造或者没有调用子类的其他构造，则默认调用父类无参构造。"><a href="#在子类的构造方法的第一行代码如果没有调用父类的构造或者没有调用子类的其他构造，则默认调用父类无参构造。" class="headerlink" title="在子类的构造方法的第一行代码如果没有调用父类的构造或者没有调用子类的其他构造，则默认调用父类无参构造。"></a>在子类的构造方法的第一行代码如果没有调用父类的构造或者没有调用子类的其他构造，则默认调用父类无参构造。</h2><p>为什么要调用父类构造？</p><p>因为需要给父类的成员变量初始化。肯定会先把父类的构造执行完毕，再去执行子类构造中的其他代码。</p><p>super(实参列表); 在子类的构造方法中使用,用来调用父类中的构造方法(具体哪一个由传递的参数决定),并且只能在构造方法第一行使用</p><p>this(实参列表); 语 在类的构造方法中使用,用来调用本类中的其它构造方法(具体哪一个由传递的参数决定),并且只能在构造方法的第一行使用</p><p>例如：下面这个例子中，首先调用子类的无参构造，因为第一行是this语句，所以这里不调用父类的无参构造。（第一行是this或super都不调用），然后执行this(1),调用的子类的有参构造，但是子类的有参构造第一行代码没有调用父类的构造或子类的其他构造，所以默认调用父类的无参构造。所以最终的输出结果为：“我是父类的无参构造”—&gt;“我是子类的有参构造”—&gt;“我是子类无参构造”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima;</span><br><span class="line"> </span><br><span class="line">public class ExtendsDemo6 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Zi z=new Zi();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Die &#123;</span><br><span class="line">public Die() &#123;</span><br><span class="line">System.out.println(&quot;我是父类无参构造&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public Die(int num) &#123;</span><br><span class="line">System.out.println(&quot;我是父类有参构造&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Zi extends Die &#123;</span><br><span class="line">public Zi() &#123;</span><br><span class="line">this(1);</span><br><span class="line">System.out.println(&quot;我是子类无参构造&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public Zi(int num) &#123;</span><br><span class="line">System.out.println(&quot;我是子类有参构造&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 继承 </tag>
            
            <tag> 构造方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2019/09/15/%E5%A4%9A%E6%80%81/"/>
      <url>/2019/09/15/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>学习多态时只是了解了多态应该怎样写，怎样用，但对多态的内在理解并不充分。</p><p>转自 <a href="https://blog.csdn.net/github_37022917/article/details/59600916" target="_blank" rel="noopener">https://blog.csdn.net/github_37022917/article/details/59600916</a></p><p>多态是面向对象程序设计三大特性之一，封装、继承、多态。</p><a id="more"></a><h2 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h2><p>主要体现在方法调用上，同一个方法根据其对象类型的不同而采取不同的方法行为。</p><p>得益于继承，对象既可以作为自己本身的类型使用，也可以作为它的基类使用（向上转型），因此对基类型对象起作用的方法就可以用于其所有的导出类对象中并因为导出类对象的不同而有不同的方法行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Animals &#123;</span><br><span class="line">    public void sound()&#123;</span><br><span class="line">        System.out.println(&quot;动物叫声&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animals&#123;</span><br><span class="line">    public void sound()&#123;</span><br><span class="line">        System.out.println(&quot;汪汪汪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animals&#123;</span><br><span class="line">    public void sound()&#123;</span><br><span class="line">        System.out.println(&quot;喵喵喵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test2&#123;</span><br><span class="line">    public static void animalsSound(Animals a)&#123;</span><br><span class="line">        a.sound();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animals dog = new Dog();</span><br><span class="line">        Animals cat = new Cat();</span><br><span class="line">        animalsSound(dog);</span><br><span class="line">        animalsSound(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">汪汪汪</span><br><span class="line">喵喵喵</span><br><span class="line">*///：~</span><br></pre></td></tr></table></figure><p>如上述示例，对于animalsSound(Animals a)方法，虽然传入的是Animals类型的引用Dog与Cat实例，调用其sound()方法，但是却根据Dog与Cat类型的不同而有不同的sound()方法实现，这就是表现出来的多态特性</p><h2 id="如何使用多态特性"><a href="#如何使用多态特性" class="headerlink" title="如何使用多态特性"></a>如何使用多态特性</h2><p>1、通过继承重写相应方法</p><p>2、通过实现接口</p><h2 id="为什么要使用多态（多态的好处）"><a href="#为什么要使用多态（多态的好处）" class="headerlink" title="为什么要使用多态（多态的好处）"></a>为什么要使用多态（多态的好处）</h2><p>1、可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p><p>2、可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。<br>3、接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。 </p><p>4、灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。 </p><p>5、简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p><h2 id="如何判断是否呈现出多态（多态的存在前提）"><a href="#如何判断是否呈现出多态（多态的存在前提）" class="headerlink" title="如何判断是否呈现出多态（多态的存在前提）"></a>如何判断是否呈现出多态（多态的存在前提）</h2><p>1、要有继承关系<br>2、子类重写父类的方法<br>3、父类引用指向子类实例</p><h2 id="为什么说静态成员无多态特性？"><a href="#为什么说静态成员无多态特性？" class="headerlink" title="为什么说静态成员无多态特性？"></a>为什么说静态成员无多态特性？</h2><p>其实，在分别弄清楚stiatc与多态的本质后，已经不难回答这个问题了。首先，要明确，static成员，不管是static变量还是static方法，都是属于类的，不与任何对象实例相关联，而多态最起码得要有多个对象的存在，从面向对象的角度就可以解释这个问题。其次，static方法不允许被重写，也就不存在动态绑定之类的一系列问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 向上转型之后调用子类的同名变量和方法的问题（多态）</title>
      <link href="/2019/09/15/java-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E4%B9%8B%E5%90%8E%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%9A%E6%80%81%EF%BC%89/"/>
      <url>/2019/09/15/java-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E4%B9%8B%E5%90%8E%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%9A%E6%80%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在学习向上转型时遇到的一些疑问</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">int i=0;</span><br><span class="line">void f1() &#123;</span><br><span class="line">System.out.println(&quot;A.f1()&quot;);</span><br><span class="line">f2();</span><br><span class="line">&#125;</span><br><span class="line">public void f2() &#123;</span><br><span class="line">System.out.println(&quot;A.f2()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">int i=1;</span><br><span class="line">public void f2() &#123;</span><br><span class="line">System.out.println(&quot;B.f2()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">A a = new B(); //(1)</span><br><span class="line">a.f1(); //(2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">A.f1()</span><br><span class="line">B.f2()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>在（1）处为向上转型（a实际上指向的是一个子类对象），之后调用了a.f1();,以为会打印A.f1();A.f2();,但结果却不是。</p><p>个人理解：B继承了A，也就是B有了A的方法，a.f1()是调用B里的f1()，然后f1()又调用了B里f2()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">A a = new B(); //（1）</span><br><span class="line">System.out.println(a.i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又出现疑问，为什么（1）后输出的i值为0</p><p>突然脑子短路。。</p><p>———————————分割线——————————————————————————————————————————– </p><p>在网上查看了好多类似的问题，发现某位兄台整理的比较好，就厚颜无耻的引用过来了。</p><p><a href="https://blog.csdn.net/kavensu/article/details/8079460" target="_blank" rel="noopener">https://blog.csdn.net/kavensu/article/details/8079460</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">String name = &quot;父&quot;;</span><br><span class="line">void f()&#123;System.out.print(&quot;父类&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">String name = &quot;儿子&quot;;</span><br><span class="line">void f() &#123;</span><br><span class="line">System.out.print(&quot;儿子&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f2() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Father s = new Son();</span><br><span class="line">System.out.println(s.name); //1</span><br><span class="line">s.f(); //2</span><br><span class="line">s.f2();//3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>疑问：不是说类型是由new决定的而不是由声明决定的吗？即Father s=new Son()此时s的具体类型是什么？若是Father 那上面的2就应该输出“父类”而不是“儿子”？<br>若是Son类那就应该能调用f2()呀？另外还有name疑问，s.name怎么会是”父”呢？</p><p>分析：</p><p>Father s = new Son();</p><p>表示定义了一个Father类型的引用，指向新建的Son类型的对象。由于Son是继承自它的父类Father，所以Father类型的引用是可以指向Son类型的对象的。那么这样有什么意义？因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特。</p><p>定义一个父类类型的引用之指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。</p><p>所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，它是无可奈何的； 因此s.name调用父类的属性! f2方法父类没有，出错！</p><p>同时，父类中的一个方法只有在在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用；</p><p>对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。因此s.f()调用子类的方法!</p><p>对于多态，可以总结它为：</p><p>　　一、使用父类类型的引用指向子类的对象；<br>　　<br>　　二、该引用只能调用父类中定义的方法和变量；<br>　　<br>　　三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）<br>　　<br>　　四、变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
            <tag> 向上转型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程思想第八章练习</title>
      <link href="/2019/09/15/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/09/15/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>编程思想第八章练习</p><a id="more"></a><h2 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a>练习1：</h2><p>创建一个Cycle类，它具有子类Unicycle，Bicycle和TriCycle.演示每一个类型的实例都可以经由ride（）向上转型为Cycle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Cycle&#123;</span><br><span class="line">public void ride() &#123;</span><br><span class="line">System.out.println(&quot;Cycle.ride()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Unicycle extends Cycle&#123;</span><br><span class="line">public void ride() &#123;</span><br><span class="line">System.out.println(&quot;Unicycle.ride()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bicycle extends Cycle&#123;</span><br><span class="line">public void ride() &#123;</span><br><span class="line">System.out.println(&quot;Bicycle.ride()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Tricycle extends Cycle&#123;</span><br><span class="line">public void ride() &#123;</span><br><span class="line">System.out.println(&quot;Tricycle.ride()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void f(Cycle c) &#123;</span><br><span class="line">c.ride();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Unicycle un = new Unicycle();</span><br><span class="line">Bicycle bi = new Bicycle();</span><br><span class="line">Tricycle tr = new Tricycle();</span><br><span class="line">f(un);</span><br><span class="line">f(bi);</span><br><span class="line">f(tr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Unicycle.ride()</span><br><span class="line">Bicycle.ride()</span><br><span class="line">Tricycle.ride()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h2><p>在几何图形的示例中添加@Override注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Shape&#123;</span><br><span class="line">public void draw() &#123;&#125;</span><br><span class="line">public void erase() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Circle extends Shape&#123;</span><br><span class="line">@Override public void draw() &#123;System.out.println(&quot;Circle.draw()&quot;);&#125;</span><br><span class="line">@Override public void erase() &#123;System.out.println(&quot;Circle.erase()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Square extends Shape&#123;</span><br><span class="line">@Override public void draw() &#123;System.out.println(&quot;Square.draw()&quot;);&#125;</span><br><span class="line">@Override public void erase() &#123;System.out.println(&quot;Square.erase()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Triangle extends Shape&#123;</span><br><span class="line">@Override public void draw() &#123;System.out.println(&quot;Triangle.draw()&quot;);&#125;</span><br><span class="line">@Override public void erase() &#123;System.out.println(&quot;Triangle.erase()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class RandomShapeGenerator&#123;</span><br><span class="line">private Random rand = new Random(47);</span><br><span class="line">public Shape next() &#123;</span><br><span class="line">switch(rand.nextInt(3)) &#123;</span><br><span class="line">default:</span><br><span class="line">case 0:return new Circle();</span><br><span class="line">case 1:return new Square();</span><br><span class="line">case 2:return new Triangle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Shapes&#123;</span><br><span class="line">private static RandomShapeGenerator gen = new RandomShapeGenerator();</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Shape[] s = new Shape[9];</span><br><span class="line">for(int i = 0;i&lt;s.length;i++) &#123;</span><br><span class="line">s[i] = gen.next();</span><br><span class="line">&#125;</span><br><span class="line">for(Shape shp : s) &#123;</span><br><span class="line">shp.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Triangle.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Circle.draw()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a>练习3：</h2><p>在基类Shape（）.java中添加一个新方法，用于打印一条消息，但导出类中不要覆盖这个方法。请解释发生了什么。现在，在其中一个导出类中覆盖该方法，而在其他的导出类不予覆盖，观察又有什么发生。最后，在所有的导出类中覆盖这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle extends Shape &#123;</span><br><span class="line">     @Override public void draw() &#123; System.out.println(&quot;Circle.draw()&quot;); &#125;</span><br><span class="line">     @Override public void erase() &#123;System.out.println(&quot;Circle.erase()&quot;); &#125;</span><br><span class="line">              public void msg() &#123;</span><br><span class="line">                  System.out.println(&quot;Circle.msg&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Square extends Shape &#123;</span><br><span class="line">    @Override public void draw() &#123; System.out.println(&quot;Square.draw()&quot;); &#125;</span><br><span class="line">    @Override public void erase() &#123; System.out.println(&quot;Square.erase()&quot;); &#125;</span><br><span class="line">     public void msg() &#123;</span><br><span class="line">      System.out.println(&quot;Square.msg&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Triangle extends Shape &#123;</span><br><span class="line">    @Override public void draw() &#123;System.out.println(&quot;Triangle.draw()&quot;); &#125;</span><br><span class="line">    @Override public void erase() &#123; System.out.println(&quot;Triangle.erase()&quot;); &#125;</span><br><span class="line">          public void msg() &#123;</span><br><span class="line">              System.out.println(&quot;Triangle.msg&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Shape &#123;</span><br><span class="line">      public void draw() &#123;&#125;</span><br><span class="line">      public void erase() &#123;&#125;</span><br><span class="line">      public void msg() &#123;</span><br><span class="line">          System.out.println(&quot;Shape.msg()&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Shapes &#123;</span><br><span class="line">      private static RandomShapeGenerator gen =</span><br><span class="line">        new RandomShapeGenerator();</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">        Shape[] s = new Shape[9];</span><br><span class="line">        // Fill up the array with shapes:</span><br><span class="line">        for(int i = 0; i &lt; s.length; i++)</span><br><span class="line">          s[i] = gen.next();</span><br><span class="line">        // Make polymorphic method calls:</span><br><span class="line">        for(Shape shp : s) &#123;</span><br><span class="line">            shp.draw();</span><br><span class="line">            shp.msg();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="练习4："><a href="#练习4：" class="headerlink" title="练习4："></a>练习4：</h2><p>向Shape.java中添加一个新的Shape类型，并在main（）方法中验证：多态对新类型的作用是否与在旧类型中的一样。</p><h2 id="练习5："><a href="#练习5：" class="headerlink" title="练习5："></a>练习5：</h2><p>以练习1为基础，在Cycle中添加wheels（）方法，它将返回轮子的数量。修改ride（）方法，并验证多态起作用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Cycle&#123;</span><br><span class="line">public int wheels() &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Unicycle extends Cycle&#123;</span><br><span class="line">public int wheels() &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bicycle extends Cycle&#123;</span><br><span class="line">public int wheels() &#123;</span><br><span class="line">return 2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Tricycle extends Cycle&#123;</span><br><span class="line">public int wheels() &#123;</span><br><span class="line">return 3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void ride(Cycle c) &#123;</span><br><span class="line">System.out.println(&quot;Number of wheels: &quot;+c.wheels());</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ride(new Unicycle());</span><br><span class="line">ride(new Bicycle());</span><br><span class="line">ride(new Tricycle());</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Number of wheels: 1</span><br><span class="line">Number of wheels: 2</span><br><span class="line">Number of wheels: 3</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习6："><a href="#练习6：" class="headerlink" title="练习6："></a>练习6：</h2><p>修改Music3.java，使what（）方法成为根Object的toString方法.试用System.out.Printfln()方法打印Instrucment对象（不用向上转型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">enum Note&#123;</span><br><span class="line">MIDDLE_C,C_SHARP,B_FLAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Instrument&#123;</span><br><span class="line">void play(Note n) &#123;System.out.println(&quot;Instrument.paly() &quot;+n);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Insrument&quot;;&#125;</span><br><span class="line">void adjust() &#123;System.out.println(&quot;Adjusting Insrument&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wind extends Instrument&#123;</span><br><span class="line">void play(Note n) &#123;System.out.println(&quot;Wind.play() &quot;+n);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Wind&quot;;&#125;</span><br><span class="line">void adjust() &#123;System.out.println(&quot;Adjustring Wind&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Percussion extends Instrument&#123;</span><br><span class="line">void play(Note n) &#123;System.out.println(&quot;Percussion.play() &quot;+n);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Percussion&quot;;&#125;</span><br><span class="line">void adjust() &#123;System.out.println(&quot;Adjustring Percussion&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Stringed extends Instrument&#123;</span><br><span class="line">void play(Note n) &#123;System.out.println(&quot;Stringed.play() &quot;+n);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Stringed&quot;;&#125;</span><br><span class="line">void adjust() &#123;System.out.println(&quot;Adjusting Stringed&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Brass extends Wind&#123;</span><br><span class="line">void play(Note n) &#123;System.out.println(&quot;Brass.play() &quot;+n);&#125;</span><br><span class="line">void adjust() &#123;System.out.println(&quot;Adjusting Brass&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Woodwind extends Wind&#123;</span><br><span class="line">void play(Note n) &#123;System.out.println(&quot;Woodwind.play() &quot;+n);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Woodwind&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Music3&#123;</span><br><span class="line">public static void tune(Instrument i) &#123;</span><br><span class="line">i.play(Note.MIDDLE_C);</span><br><span class="line">&#125;</span><br><span class="line">public static void tuneAll(Instrument[] e) &#123;</span><br><span class="line">for(Instrument i:e) &#123;</span><br><span class="line">//tune(i);</span><br><span class="line">System.out.println(i.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Instrument[] orchestra = &#123;</span><br><span class="line">new Wind(),</span><br><span class="line">new Percussion(),</span><br><span class="line">new Stringed(),</span><br><span class="line">new Brass(),</span><br><span class="line">new Woodwind()</span><br><span class="line">&#125;;</span><br><span class="line">tuneAll(orchestra);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Wind</span><br><span class="line">Percussion</span><br><span class="line">Stringed</span><br><span class="line">Wind</span><br><span class="line">Woodwind</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习7："><a href="#练习7：" class="headerlink" title="练习7："></a>练习7：</h2><p>想Music3.java添加一个新的类型Instrument，并验证多态性是否作用于所添加的新类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Electronic extends Wind&#123;</span><br><span class="line">    void play(Note n) &#123; System.out.println(&quot;Electronic.play() &quot; + n); &#125;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">    return &quot;Electronic&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Music3&#123;</span><br><span class="line">public static void tune(Instrument i) &#123;</span><br><span class="line">i.play(Note.MIDDLE_C);</span><br><span class="line">&#125;</span><br><span class="line">public static void tuneAll(Instrument[] e) &#123;</span><br><span class="line">for(Instrument i:e) &#123;</span><br><span class="line">tune(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Instrument[] orchestra = &#123;</span><br><span class="line">new Wind(),</span><br><span class="line">new Percussion(),</span><br><span class="line">new Stringed(),</span><br><span class="line">new Brass(),</span><br><span class="line">new Woodwind(),</span><br><span class="line">new Electronic()</span><br><span class="line">&#125;;</span><br><span class="line">tuneAll(orchestra);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习8："><a href="#练习8：" class="headerlink" title="练习8："></a>练习8：</h2><p>修改Music3.java，使其可以像Shapes.java中的方式那样可以随机创建Instrument对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class InstrumentGenerator&#123;</span><br><span class="line">Random random = new Random(47);</span><br><span class="line">public Instrument next() &#123;</span><br><span class="line">switch(random.nextInt(6)) &#123;</span><br><span class="line">default:</span><br><span class="line">case 0:return new Wind();</span><br><span class="line">case 1:return new Percussion();</span><br><span class="line">case 2:return new Stringed();</span><br><span class="line">case 3:return new Brass();</span><br><span class="line">case 4:return new Woodwind();</span><br><span class="line">case 5:return new Electronic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Music3&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">InstrumentGenerator generator = new InstrumentGenerator();</span><br><span class="line">for(int i=0;i&lt;20;i++) &#123;</span><br><span class="line">System.out.println(generator.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习9："><a href="#练习9：" class="headerlink" title="练习9："></a>练习9：</h2><p>创建Rodent（啮齿动物）：Mnouse（老鼠），Gerbil（鼹鼠），Hamster（大颊鼠），等等这样一个的继承层次结构。在基类中，提供对所有的Rodent都通用的方法，在导出类中，根据特定的Rodent类型覆盖这些方法，以便它们执行不同的行为。创建一个Robent数组，填充不同的Rodent类型，然后调用基类方法，观察发生什么情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         Rodent rodents[] = &#123;new Mouse(),new Gerbil(),new Hamster()&#125;;</span><br><span class="line">         for(Rodent r: rodents) &#123;</span><br><span class="line">             r.hop();</span><br><span class="line">             r.run();</span><br><span class="line">             System.out.println(r);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Rodent hopping&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Rodent scurrying&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Rodent&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Mouse extends Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Mouse hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Mouse run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Mouse&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Gerbil extends Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Gerbil hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Gerbil run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Gernil&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hamster extends Rodent&#123;</span><br><span class="line">    public void hop() &#123;System.out.println(&quot;Hamster hop&quot;);&#125;</span><br><span class="line">    public void run() &#123;System.out.println(&quot;Hamster run&quot;);&#125;</span><br><span class="line">    public String toString() &#123;return &quot;Hamster&quot;;&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Mouse hop</span><br><span class="line">Mouse run</span><br><span class="line">Mouse</span><br><span class="line">Gerbil hop</span><br><span class="line">Gerbil run</span><br><span class="line">Gerbil</span><br><span class="line">Hamster hop</span><br><span class="line">Hamster run</span><br><span class="line">Hamster</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习10"><a href="#练习10" class="headerlink" title="练习10:"></a>练习10:</h2><p>创建一个包含两个方法的基类。在第一个方法中可以调用第二个方法。然后产生一个继承自该基类的导出类，且覆盖基类中的第二个方法。为该导出类创建一个对象，将他向上转型到基类并调用第一个方法，解释发生的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">void f1() &#123;</span><br><span class="line">System.out.println(&quot;A.f1()&quot;);</span><br><span class="line">f2();</span><br><span class="line">&#125;</span><br><span class="line">void f2() &#123;</span><br><span class="line">System.out.println(&quot;A.f2()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">void f2() &#123;</span><br><span class="line">    System.out.println(&quot;B.f2()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">A a = new B();</span><br><span class="line">a.f1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">A.f1()</span><br><span class="line">B.f2()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习11："><a href="#练习11：" class="headerlink" title="练习11："></a>练习11：</h2><p>向Sandwich.java中添加 Pickle类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Pickle&#123;</span><br><span class="line">Pickle()&#123;System.out.println(&quot;Pickle()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Meal&#123;</span><br><span class="line">Meal()&#123;System.out.println(&quot;Meal()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bread&#123;</span><br><span class="line">Bread()&#123;System.out.println(&quot;Bread()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cheese&#123;</span><br><span class="line">Cheese()&#123;System.out.println(&quot;Cheese()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Lettuce&#123;</span><br><span class="line">Lettuce()&#123;System.out.println(&quot;Lettuce()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Lunch extends Meal&#123;</span><br><span class="line">Lunch()&#123;System.out.println(&quot;Lunch()&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class PortableLunch extends Lunch&#123;</span><br><span class="line">PortableLunch()&#123;System.out.println(&quot;PortableLunch&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Sandwich extends PortableLunch&#123;</span><br><span class="line">private Bread b = new Bread();</span><br><span class="line">private Cheese c = new Cheese();</span><br><span class="line">private Lettuce l = new Lettuce();</span><br><span class="line">private Pickle p = new Pickle();</span><br><span class="line">public Sandwich() &#123;System.out.println(&quot;Sandwinch()&quot;);&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Sandwich();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Meal()</span><br><span class="line">Lunch()</span><br><span class="line">PortableLunch</span><br><span class="line">Bread()</span><br><span class="line">Cheese()</span><br><span class="line">Lettuce()</span><br><span class="line">Pickle()</span><br><span class="line">Sandwinch()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习12："><a href="#练习12：" class="headerlink" title="练习12："></a>练习12：</h2><p>修改练习9，使其能够演示基类和导出类的初始化顺序。然后向基类和导出类中添加成员对象，并说明构造期间初始化发生的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Member&#123;</span><br><span class="line">public Member(String id) &#123;</span><br><span class="line">System.out.println(&quot;Member contructor&quot;+id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rodent&#123;</span><br><span class="line">Member m1 = new Member(&quot;r1&quot;);</span><br><span class="line">Member m2 = new Member(&quot;r2&quot;);</span><br><span class="line">Rodent()&#123;System.out.println(&quot;Rodent Conteuctor&quot;);&#125;</span><br><span class="line">void hop() &#123;System.out.println(&quot;Rodent hop&quot;);&#125;</span><br><span class="line">void run() &#123;System.out.println(&quot;Rodent run&quot;);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Rodent&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Mouse extends Rodent&#123;</span><br><span class="line">Member m1 = new Member(&quot;m1&quot;);</span><br><span class="line">Member m2 = new Member(&quot;m2&quot;);</span><br><span class="line">Mouse()&#123;System.out.println(&quot;Mouse Conteuctor&quot;);&#125;</span><br><span class="line">void hop() &#123;System.out.println(&quot;Mouse hop&quot;);&#125;</span><br><span class="line">void run() &#123;System.out.println(&quot;Mouse run&quot;);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Mouse&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Gerbil extends Rodent&#123;</span><br><span class="line">Member m1 = new Member(&quot;g1&quot;);</span><br><span class="line">Member m2 = new Member(&quot;g2&quot;);</span><br><span class="line">Gerbil()&#123;System.out.println(&quot;Gerbil Conteuctor&quot;);&#125;</span><br><span class="line">void hop() &#123;System.out.println(&quot;Gerbil hop&quot;);&#125;</span><br><span class="line">void run() &#123;System.out.println(&quot;Gerbil run&quot;);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Gerbil&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hamster extends Rodent&#123;</span><br><span class="line">Member m1 = new Member(&quot;h1&quot;);</span><br><span class="line">Member m2 = new Member(&quot;h2&quot;);</span><br><span class="line">Hamster()&#123;System.out.println(&quot;Hamster Conteuctor&quot;);&#125;</span><br><span class="line">void hop() &#123;System.out.println(&quot;Hamster hop&quot;);&#125;</span><br><span class="line">void run() &#123;System.out.println(&quot;Hamster run&quot;);&#125;</span><br><span class="line">public String toString() &#123;return &quot;Hamster&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Music3&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Hamster();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习15："><a href="#练习15：" class="headerlink" title="练习15："></a>练习15：</h2><p>在PolyConstructors.java中添加一个RectangularGlyph，并证明会出现本节所描述的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Glyph&#123;</span><br><span class="line">void draw() &#123;System.out.println(&quot;Glyph.draw()&quot;);&#125;</span><br><span class="line">Glyph()&#123;</span><br><span class="line">System.out.println(&quot;Glyph() before draw()&quot;);</span><br><span class="line">draw();</span><br><span class="line">System.out.println(&quot;Glyph() after draw()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//class RoundGlyph extends Glyph&#123;</span><br><span class="line">//private int radius = 1;</span><br><span class="line">//RoundGlyph(int r) &#123;</span><br><span class="line">//radius = r;</span><br><span class="line">//System.out.println(&quot;RoundGlyph.RoundGlyph().radius = &quot;+radius);</span><br><span class="line">//&#125;</span><br><span class="line">//void draw() &#123;</span><br><span class="line">//System.out.println(&quot;RoundGlyph.draw().radius = &quot;+radius);</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">class RectangularGlyph extends Glyph&#123;</span><br><span class="line">private int width = 1;</span><br><span class="line">private int height = 5;</span><br><span class="line"></span><br><span class="line">    public RectangularGlyph(int width,int height) &#123;</span><br><span class="line">        this.width = width;</span><br><span class="line">        this.height = height;</span><br><span class="line">        System.out.println(&quot;RectangularGlyph.width = &quot;+width+&quot; height = &quot;+height);</span><br><span class="line">    &#125;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;RectangularGlyph.area = &quot;+(width*height));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class PolyConstructors&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//new RoundGlyph(5);</span><br><span class="line">new RectangularGlyph(2, 2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Glyph() before draw()</span><br><span class="line">RectangularGlyph.area = 0</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RectangularGlyph.width = 2 height = 2</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习16："><a href="#练习16：" class="headerlink" title="练习16："></a>练习16：</h2><p>遵循Transmogrify.java这个例子，创建一个Starship类，包含一个AlertStatus引用，此引用可以指示三种不同的状态。纳入一些可以改变这些状态的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class AlertStatus&#123;</span><br><span class="line">   public String getStatus() &#123;return &quot;None&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class RedAlertStatus extends AlertStatus&#123;</span><br><span class="line">   public String getStatus() &#123;return &quot;Red&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class YellowAlertStatus extends AlertStatus&#123;</span><br><span class="line">   public String getStatus() &#123;return &quot;Yellow&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class GreenAlertStatus extends AlertStatus&#123;</span><br><span class="line">   public String getStatus() &#123;return &quot;Green&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Starship&#123;</span><br><span class="line">   private AlertStatus alertStatus = new GreenAlertStatus();</span><br><span class="line">   public void change(AlertStatus iStatus) &#123;</span><br><span class="line">       alertStatus = iStatus;</span><br><span class="line">   &#125;</span><br><span class="line">   public String toString() &#123;</span><br><span class="line">       return alertStatus.getStatus();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    Starship starship = new Starship();</span><br><span class="line">       System.out.println(starship);</span><br><span class="line">       starship.change(new YellowAlertStatus());</span><br><span class="line">       System.out.println(starship);</span><br><span class="line">       starship.change(new RedAlertStatus());</span><br><span class="line">       System.out.println(starship);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Green</span><br><span class="line">Yellow</span><br><span class="line">Red</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习17："><a href="#练习17：" class="headerlink" title="练习17："></a>练习17：</h2><p>使用练习1中的Cycle的层次结构哦，在Unicycle 和Bicycle中添加balance方法，而Tricycle中国不添加。创建这三种类型的实例，并将他们向上转型为Cycle数组。在该数组的每一个元素上都尝试调用balance，并观察结果。然后将他们向下转型，再次调用balance（），并观察将所发生什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Cycle&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Unicycle extends Cycle&#123;</span><br><span class="line">void balance()&#123;System.out.println(&quot;Unicycle&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bicycle extends Cycle&#123;</span><br><span class="line">void balance()&#123;System.out.println(&quot;Bicycle&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Tricycle extends Cycle&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Cycle[] cycle = &#123;</span><br><span class="line">new Unicycle(),</span><br><span class="line">new Bicycle(),</span><br><span class="line">new Tricycle()</span><br><span class="line">&#125;;</span><br><span class="line">//cycle[0].balance();</span><br><span class="line">//cycle[1].balance();</span><br><span class="line">//cycle[2].balance();</span><br><span class="line"></span><br><span class="line">((Unicycle)cycle[0]).balance();</span><br><span class="line">((Bicycle)cycle[1]).balance();</span><br><span class="line"></span><br><span class="line">//((Tricycle)cycle[3]).balance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Unicycle</span><br><span class="line">Bicycle</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_多态_再论向上转型</title>
      <link href="/2019/09/15/Java-%E5%A4%9A%E6%80%81-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/"/>
      <url>/2019/09/15/Java-%E5%A4%9A%E6%80%81-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java_多态_再论向上转型</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">enum Note&#123;</span><br><span class="line">MIDDLE_C,C_SHARP,B_FLAT;</span><br><span class="line">&#125;</span><br><span class="line">class Instrument&#123;</span><br><span class="line">public void play(Note n) &#123;</span><br><span class="line">System.out.println(&quot;Instrument.play()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Wind extends Instrument&#123;</span><br><span class="line">public void play(Note n) &#123;</span><br><span class="line">System.out.println(&quot;Wind.play() &quot;+n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Music&#123;</span><br><span class="line">static void tune(Instrument i) &#123;</span><br><span class="line">i.play(Note.MIDDLE_C);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Wind flute = new Wind();</span><br><span class="line">tune(flute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>Music.tune()方法接受一个Instrument引用，同时也接受任何导出自Instrumnet的类。在main()方法中，当一个Wind引用传递到tune()方法时，就会出现这种情况，而不需要任何类型转换。这样做是允许的-因为Wind从Instrument继承而来，所以Instrument的接口必定存在于Wind中。</p><p>但为什么不让tune()方法直接接受一个Wind引用作为自己的参数呢。如果那样做，就需要为系统内Instrument的每种类型都编写新的tune()方法。</p><p>按照这种假设，再加入Stringed（弦乐）和Brass（管乐）两种Instrument(乐器)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">enum Note&#123;</span><br><span class="line">MIDDLE_C,C_SHARP,B_FLAT;</span><br><span class="line">&#125;</span><br><span class="line">class Instrument&#123;</span><br><span class="line">public void play(Note n) &#123;</span><br><span class="line">System.out.println(&quot;Instrument.play()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wind extends Instrument&#123;</span><br><span class="line">public void play(Note n) &#123;</span><br><span class="line">System.out.println(&quot;Wind.play() &quot;+n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Stringed extends Instrument&#123;</span><br><span class="line">public void play(Note n) &#123;</span><br><span class="line">System.out.println(&quot;Stringes.play() &quot;+n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Brass extends Instrument&#123;</span><br><span class="line">public void play(Note n) &#123;</span><br><span class="line">System.out.println(&quot;Brass.play() &quot;+n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Music2&#123;</span><br><span class="line">public static void tune(Wind i) &#123;</span><br><span class="line">i.play(Note.MIDDLE_C);</span><br><span class="line">&#125;</span><br><span class="line">public static void tune(Stringed i) &#123;</span><br><span class="line">i.play(Note.MIDDLE_C);</span><br><span class="line">&#125;</span><br><span class="line">public static void tune(Brass i) &#123;</span><br><span class="line">i.play(Note.MIDDLE_C);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Wind flute = new Wind();</span><br><span class="line">Stringed violin = new Stringed();</span><br><span class="line">Brass frenchHorn = new Brass();</span><br><span class="line">tune(flute);</span><br><span class="line">tune(violin);</span><br><span class="line">tune(frenchHorn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Wind.play() MIDDLE_C</span><br><span class="line">Stringes.play() MIDDLE_C</span><br><span class="line">Brass.play() MIDDLE_C</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>虽然行得通，但必须为添加的每一个新Instrument类编写特定类型的方法。如果想添加类似tune()的新方法，或者添加自Instrument导出的新类，仍需要做大量工作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
            <tag> 向上转型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java继承与初始化</title>
      <link href="/2019/09/15/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/09/15/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>转自 <a href="https://blog.csdn.net/fengjianbang/article/details/50938569" target="_blank" rel="noopener">https://blog.csdn.net/fengjianbang/article/details/50938569</a></p><a id="more"></a><p>在Java中，每一个类的编译代码都存在于它自己的独立文件中。该文件只有在需要时才会被加载，一般是在类初次使用时加载，这通常是指创建类的第一个对象或者第一次访问类中的静态方法或者静态块。</p><p>当JVM要加载一个类A时，如果发现这个类有父类B，那么JVM首先加载其父类B，如果这个父类B还有其自身的父类C，那么首先加载类C，一次类推。这个过程是必须要进行的，即使我们有没有创建类A的对象。看下面这段代码，执行之后的输出结果为，在这段代码中，main函数中并没有任何语句，但是却产生了输出，这是因为在执行这段代码的时候，第一件事是试图访问B.main函数（由于main函数是属于类B的一个静态函数，根据上述内容，这时候需要加载类B的编译代码），于是加载器启动，并找出类B的编译代码（在名为B.class的文件中），在加载的过程中，发现它继承与类A，于是转而先加载类A。在类的加载过程中，加载器会对类的static 变量进行初始化，加载类中的静态块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package testOOP;</span><br><span class="line">class A&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;this is father&apos;s static&quot;);</span><br><span class="line">&#125;</span><br><span class="line">A()&#123;</span><br><span class="line">System.out.println(&quot;this is father&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class B extends A&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;this is child&apos;s static&quot;);</span><br><span class="line">&#125;</span><br><span class="line">B()&#123;</span><br><span class="line">System.out.println(&quot;this is child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String [] args)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的代码中，如果main函数中有明确创建B对象的语句，并且类A，和类B都有自己的成员变量和非静态初始化块时，类A，类B的初始化顺序是怎么样的呢？我们首先看一下这段代码，运行后的输出为。根据输出我们可以看出，在创建类B的对象时，首先会加载父类A，然后加载类B，加载完这两个类之后，开始进行初始化操作：首先执行父类的非静态块的初始化操作，然后执行父类的构造方法，再执行子类的非静态块初始化操作，最后执行子类的构造方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package testOOP;</span><br><span class="line">class A&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;this is father&apos;s static&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;这是父类的非静态初始化块&quot;);</span><br><span class="line">&#125;</span><br><span class="line">A()&#123;</span><br><span class="line">System.out.println(&quot;this is father&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class B extends A&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;this is child&apos;s static&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;这是子类的非静态初始化块&quot;);</span><br><span class="line">&#125;</span><br><span class="line">B()&#123;</span><br><span class="line">System.out.println(&quot;this is child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String [] args)&#123;</span><br><span class="line">new B();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述分析内容可以知道，当需要创建一个类A的对象时，其执行顺序是：1、加载父类，2、加载类A，3、执行父类的非静态初始化块，4、执行父类的构造方法，5、执行子类的非静态初始化块，6、执行子类的构造方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 继承初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空白fianl</title>
      <link href="/2019/09/15/%E7%A9%BA%E7%99%BDfianl/"/>
      <url>/2019/09/15/%E7%A9%BA%E7%99%BDfianl/</url>
      
        <content type="html"><![CDATA[<p>Java允许生成“空白fianl”，所谓空白fianl是指被声明为fianl但又未给定初值的域。编译器会确保空白fianl在使用前必须被初始化。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Poppet&#123;</span><br><span class="line">private int i;</span><br><span class="line">Poppet(int ii)&#123;i=ii;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BlankFianl&#123;</span><br><span class="line">private final int i=0;</span><br><span class="line">private final int j;</span><br><span class="line">private final Poppet p;</span><br><span class="line"></span><br><span class="line">public BlankFianl() &#123;</span><br><span class="line">j = 1;</span><br><span class="line">p = new Poppet(1);</span><br><span class="line">&#125;</span><br><span class="line">public BlankFianl(int x) &#123;</span><br><span class="line">j = x;</span><br><span class="line">p = new Poppet(x);</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;i,j,p:&quot;+i+j+p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new BlankFianl();</span><br><span class="line">new BlankFianl(47);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。</p><h2 id="练习19-："><a href="#练习19-：" class="headerlink" title="练习19 ："></a>练习19 ：</h2><p>创建一个含有指向某对象的空白final引用类。在所有构造器内部都执行空白final的初始化操作。说明Java确保final在使用前必须初始化，且一旦被初始化即无法改变</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> fianl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之向上转型</title>
      <link href="/2019/09/15/Java%E4%B9%8B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/"/>
      <url>/2019/09/15/Java%E4%B9%8B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java之向上转型</p><a id="more"></a><p>由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。Instrument类具有一个play()方法，那么Wind类也同样具备。可以说Windui对象也是一种类型的Instrument。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Instrument&#123;</span><br><span class="line">public void play() &#123;&#125;</span><br><span class="line">static void tune(Instrument i) &#123;</span><br><span class="line">i.play();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Wind extends Instrument&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Wind flute = new Wind();</span><br><span class="line">Instrument.tune(flute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在例中，tune()方法可以接受Instrument引用。但在Wind.main()中，传递给tune()方法的是一个Wind引用。在tune()中，程序代码可以对Instrument和它所有的导出类起作用，这种将Wind引用转换为Instrument引用的动作，我们称之为向上转型。</p><h2 id="父类类型的变量来引用一个子类类型的对象。"><a href="#父类类型的变量来引用一个子类类型的对象。" class="headerlink" title="父类类型的变量来引用一个子类类型的对象。"></a>父类类型的变量来引用一个子类类型的对象。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">void shout();</span><br><span class="line">&#125;</span><br><span class="line">class Cat implements Animal&#123;</span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;喵喵&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">animalShout(animal);</span><br><span class="line">&#125;</span><br><span class="line">public static void animalShout(Animal an) &#123;</span><br><span class="line">an.shout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Animal animal = new Cat() //将Cat对象当作Animal类型来使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 向上转型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之代理</title>
      <link href="/2019/09/15/Java%E4%B9%8B%E4%BB%A3%E7%90%86/"/>
      <url>/2019/09/15/Java%E4%B9%8B%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java并没有提供对它的直接支持。这是继承与组合之间的中庸之道，因为我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该对象的所有方法（就像继承）。例如，太空船需要一个控制模块：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SpaceShipCotrols&#123;</span><br><span class="line">void up(int velocity) &#123;&#125;</span><br><span class="line">void down(int velocity) &#123;&#125;</span><br><span class="line">void left(int velocity) &#123;&#125;</span><br><span class="line">void right(int velocity) &#123;&#125;</span><br><span class="line">void forward(int velocity) &#123;&#125;</span><br><span class="line">void back(int velocity) &#123;&#125;</span><br><span class="line">void turBoost(int velocity) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造太空船的一种方式是使用继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SpaceShip extends SpaceShipCotrols&#123;</span><br><span class="line">private String name;</span><br><span class="line">public SpaceShip(String name) &#123;this.name=name;&#125;</span><br><span class="line">public String toString() &#123;return name;&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpaceShip protector = new SpaceShip(&quot;NSEA Protector&quot;);</span><br><span class="line">protector.forward(100);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，SpaceShip并非真正的SpaceShipControls类型，即便你可以“告诉”SpaceShip向前运动（forward()）。更准确地讲，SpaceShip包含SpaceShipControls，与此同时，SpaceShipControls的所有方法在SpaceShip中都暴露了出来。代理解决了此难题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SpaceShipDelegation&#123;</span><br><span class="line">private String name;</span><br><span class="line">private SpaceShipControls controls = new SpaceShipControls();</span><br><span class="line">public SpaceShipDelegation(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public void back(int velocity) &#123;</span><br><span class="line">controls.back(velocity);</span><br><span class="line">&#125;</span><br><span class="line">public void down(int velocity) &#123;</span><br><span class="line">controls.down(velocity);</span><br><span class="line">&#125;</span><br><span class="line">public void forward(int velocity) &#123;</span><br><span class="line">controls.forward(velocity);</span><br><span class="line">&#125;</span><br><span class="line">public void left(int velocity) &#123;</span><br><span class="line">controls.left(velocity);</span><br><span class="line">&#125;</span><br><span class="line">public void right(int velocity) &#123;</span><br><span class="line">controls.right(velocity);</span><br><span class="line">&#125;</span><br><span class="line">public void turBoost(int velocity) &#123;</span><br><span class="line">controls.turBoost(velocity);</span><br><span class="line">&#125;</span><br><span class="line">public void up(int velocity) &#123;</span><br><span class="line">controls.up(velocity);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpaceShipDelegation protector = new SpaceShipDelegation(&quot;NSEA Protector&quot;);</span><br><span class="line">protector.forward(100);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的方法是如何传递给了底层的controls对象，而其接口由此也就与使用继承得到的接口相同了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text汉化教程</title>
      <link href="/2019/09/13/Sublime-Text%E6%B1%89%E5%8C%96%E6%95%99%E7%A8%8B/"/>
      <url>/2019/09/13/Sublime-Text%E6%B1%89%E5%8C%96%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>发现一款Sublime Text编辑器，界面非常简洁，官方简介“A sophisticated text editor for<br>code, markup and prose”</p><a id="more"></a><p>应用界面：</p><p><img src="https://note.youdao.com/yws/api/personal/file/D63DC3CDC8184E21AC0CC529AF3B0CB7?method=download&shareKey=0466c46ccdb5640c82c78d492c858b66" alt></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text</a>官网点击DOWNLOAD下载</p><h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>英文界面用着不习惯那就汉化，另外Sublime Text也支持很多语言</p><h3 id="打开Sublime-Text的控制台（Ctrl-）"><a href="#打开Sublime-Text的控制台（Ctrl-）" class="headerlink" title="打开Sublime Text的控制台（Ctrl+~）"></a>打开Sublime Text的控制台（Ctrl+~）</h3><p><img src="https://note.youdao.com/yws/api/personal/file/DECDD38064CB43D382A931789CB46459?method=download&shareKey=48c07dedbfc24163536553843b3fe86e" alt></p><h3 id="粘贴代码到控制台"><a href="#粘贴代码到控制台" class="headerlink" title="粘贴代码到控制台"></a>粘贴代码到控制台</h3><p>进入<a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">Package Control官方网站</a></p><p>打开后，将适用于您的Sublime Text版本的Python代码粘贴到控制台中。</p><p><img src="https://note.youdao.com/yws/api/personal/file/F3A3BCAFD6944276AB58FBC5B4E162A9?method=download&shareKey=a3aa69e5a8989458ddd9178faf64e14f" alt></p><p>可以直接粘贴下面的代码：</p><blockquote><p>SUBLIME TEST 3</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure><blockquote><p>SUBLIME TEST 2</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib2,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;)</span><br></pre></td></tr></table></figure><p>粘贴后回车</p><h3 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a>选择语言</h3><p><img src="https://note.youdao.com/yws/api/personal/file/17E635F75A414E85BE61A8689C1E0045?method=download&shareKey=1f2ebac7ba81d16f0070533dc2c28ca4" alt></p><p><img src="https://note.youdao.com/yws/api/personal/file/4FB00C2308514C3397179B4E178A8EA5?method=download&shareKey=572dceb1b7fc6eecec872fa4426aa008" alt></p><p><img src="https://note.youdao.com/yws/api/personal/file/128B2F2D5B21447F88BFD73978E8AAE2?method=download&shareKey=86be3e3a7b90dea49a76664b3c53b6c8" alt></p><p><img src="https://note.youdao.com/yws/api/personal/file/9CAEE92A14604CD6932B45BBE4C782E3?method=download&shareKey=b10febac4b4c005a12bad64bfbac34fb" alt></p><p>稍微等一会就会出现中文界面</p><h2 id="切换语言"><a href="#切换语言" class="headerlink" title="切换语言"></a>切换语言</h2><p><img src="https://note.youdao.com/yws/api/personal/file/7DF89CE11F4345099D7C39EE0087B3AE?method=download&shareKey=e6cd06046dbfa2c0e7f2d2f3a1fd764f" alt></p><p>Help-&gt;Language</p><hr><p>参考</p><p><a href="https://jingyan.baidu.com/article/90bc8fc8b38eabf653640c93.html" target="_blank" rel="noopener">Sublime text如何汉化</a></p>]]></content>
      
      
      <categories>
          
          <category> Sublime Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汉化 </tag>
            
            <tag> Sublime Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我要工作</title>
      <link href="/2019/09/13/%E6%88%91%E8%A6%81%E4%B8%8A%E7%8F%AD/"/>
      <url>/2019/09/13/%E6%88%91%E8%A6%81%E4%B8%8A%E7%8F%AD/</url>
      
        <content type="html"><![CDATA[<p>中秋节到了，又不能好好工作了。</p><a id="more"></a><p><img src="http://img04.sogoucdn.com/app/a/100520021/6f37a019d125a9f11b502f8799cd6d89" alt></p><p>什么！！三天小长假！！</p><p><strong>No</strong></p><p>没有工作的我该怎么活！！</p><p><img src="https://tse1-mm.cn.bing.net/th?id=OIP.E2YZGpbR_JpWF2OJlEEWBAHaGt&w=233&h=211&c=7&o=5&pid=1.7" alt></p><p>看来只能用电影音乐游戏苹果香蕉巧克力来减轻没有工作的痛苦了</p><p><img src="https://tse3-mm.cn.bing.net/th?id=OIP.NMPqP20fsacnj0SZlDvG6gHaEP&w=300&h=171&c=7&o=5&pid=1.7" alt>、</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客next主题添加文章阅读量统计功能</title>
      <link href="/2019/09/13/Hexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/09/13/Hexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>添加文章阅读量统计有很多方法，因为我已经注册了LeanCloud，所以就直接采用了LeanCloud。</p><a id="more"></a><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a></p><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>储存-&gt;数据-&gt;创建Class</p><p>创建名为Counter的class用来存储访问博客的数据，例如：访问次数，最新访问时间等信息。class类名必须为Counter，主要为了与next主题相兼容，否则无法接收到相关数据。为了避免后续因为权限的问题导致次数统计显示不正常，ACL权限选择无限制。</p><h2 id="获取ID和Key"><a href="#获取ID和Key" class="headerlink" title="获取ID和Key"></a>获取ID和Key</h2><p>设置-&gt;应用Key</p><p>会得到App ID和App Key</p><h2 id="修改next主题配置文件"><a href="#修改next主题配置文件" class="headerlink" title="修改next主题配置文件"></a>修改next主题配置文件</h2><p>打开_config.yml，搜索leancloud_visitors，更改为true，并添加id和key</p><p>保存文件</p><p>最后生成部署hexo博客</p><p>效果如图：</p><p><img src="https://note.youdao.com/yws/api/personal/file/3562A174A28C40DC8106572FC308D989?method=download&shareKey=ddd2ef2db8a657b3869db77c3ade6ce7" alt></p><hr><p>参考</p><p><a href="https://cuibin1991.github.io/2017/07/31/Hexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">Hexo博客next主题添加文章阅读量统计功能</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从多层嵌套类中访问外部类的成员</title>
      <link href="/2019/09/13/%E4%BB%8E%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98/"/>
      <url>/2019/09/13/%E4%BB%8E%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<p>一个内部类被嵌套多少层并不重要—它能透明地访问所有它所嵌入地外围类的所有成员，如下所示：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MNA&#123;</span><br><span class="line">private void f() &#123;&#125;</span><br><span class="line">class A&#123;</span><br><span class="line">private void g() &#123;&#125;</span><br><span class="line">public class B&#123;</span><br><span class="line">void h() &#123;</span><br><span class="line">g();</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MultiNetingAccess&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MNA mna = new MNA();</span><br><span class="line">MNA.A mnaa = mna.new A();</span><br><span class="line">MNA.A.B mnaab = mnaa.new B();</span><br><span class="line">mnaab.h();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在MNA.A.B中，调用方法g()和f()不需要任何条件（即使它们被定义为private）。这个例子同时展示了如何从不同的类里创建多层嵌套类的内部类对象的基本语法。“.new”语法能产生正确的作用域，所以不必在调用构造器时限定类名。</p><hr><p><strong>内容取自</strong>《<a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java编程思想</a>》</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客添加Valine评论系统</title>
      <link href="/2019/09/12/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/09/12/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://valine.js.org" target="_blank" rel="noopener">Valine</a> 诞生于2017年8月7日，是一款基于LeanCloud的快速、简洁且高效的无后端评论系统。</p><p>理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo、Ghost 等博客程序在使用Valine。</p><a id="more"></a><h2 id="注册Leancloud"><a href="#注册Leancloud" class="headerlink" title="注册Leancloud"></a>注册Leancloud</h2><p><a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">Leancloud官网</a></p><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>创建应用，名字随便，然后进入<strong>设置</strong>-&gt;<strong>应用Key</strong></p><p>会获得<strong>App ID</strong>和<strong>App Key</strong></p><p><img src="https://note.youdao.com/yws/api/personal/file/4681CD86787442E3ABDF8E4253EBB7F7?method=download&shareKey=4a29feba787b06c9bad81b82cba3e0e5" alt></p><h2 id="设置安全域名"><a href="#设置安全域名" class="headerlink" title="设置安全域名"></a>设置安全域名</h2><p><strong>设置</strong>-&gt;<strong>安全中心</strong>-&gt;<strong>Web 安全域名</strong></p><p>添加域名</p><p><img src="https://note.youdao.com/yws/api/personal/file/24F9AB5A35F246EEA9D1AC9E3B001B5E?method=download&shareKey=d1421b849fce2fe3ad04db77a829a274" alt></p><h2 id="配置主题文件"><a href="#配置主题文件" class="headerlink" title="配置主题文件"></a>配置主题文件</h2><p>打开next主题配置文件，找到Valine</p><p><img src="https://note.youdao.com/yws/api/personal/file/3218D186890A414690199CBE24AFF54B?method=download&shareKey=f67add0d27a1f16a2c63b6a57b6bb5f2" alt></p><p>添加<strong>App ID</strong>和<strong>App Key</strong></p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><blockquote><p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p></blockquote><p>然后刷刷刷</p><p><img src="https://note.youdao.com/yws/api/personal/file/6ACDF3D45A04486BAFFA1582C666F63C?method=download&shareKey=2015c0c92caaa4c71bddeb3e470a9e89" alt></p><p>添加成功</p><hr><p><strong>参考</strong></p><p><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Python命令下载视频</title>
      <link href="/2019/09/12/%E5%88%A9%E7%94%A8Python%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/"/>
      <url>/2019/09/12/%E5%88%A9%E7%94%A8Python%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>Python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。</p><a id="more"></a><p>1、电脑需要安装<a href="https://www.python.org" target="_blank" rel="noopener">Python3</a></p><p>2、window+r 打开cmd输入python来检查环境：</p><blockquote><p>python</p></blockquote><p>3、输入下面的代码回车：</p><blockquote><p>pip3 install you-get </p></blockquote><p>安装you-get，它是python3的一个下载工具</p><p>4、下载视频时可以选择文件路径</p><blockquote><p>you-get -o F:\k 文件地址  </p></blockquote><p>默认下载到C盘</p><p>5、下载视频选择清晰度</p><blockquote><p>you-get -i 文件地址</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/5D074E03E1A14F468FFFE7717370B64E?method=download&shareKey=af6f177fd5891cd1abe66e7436f3f007" alt></p><p>显示下载时会有多种：超清、高清、标清</p><p>然后我们下载想要下载的视频样式，比如下载高清的，高清的是：-format=mp4sd</p><p>那么我们在cmd中输入：</p><blockquote><p>you-get –format=mp4sd 视频地址</p></blockquote><hr><p>网站视频下载基本上都支持</p><p><strong>下载国外视频需要科学上网</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在云服务器下部署Java Web项目</title>
      <link href="/2019/09/12/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E9%83%A8%E7%BD%B2Java-Web%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/09/12/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E9%83%A8%E7%BD%B2Java-Web%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>在服务器下手动部署Java Web项目</p><a id="more"></a><h2 id="在云服务下部署Java的三种方法"><a href="#在云服务下部署Java的三种方法" class="headerlink" title="在云服务下部署Java的三种方法"></a>在云服务下部署Java的三种方法</h2><ul><li>Java镜像部署</li><li>一键安装包部署</li><li><strong>手动部署</strong></li></ul><h2 id="手动部署的准备"><a href="#手动部署的准备" class="headerlink" title="手动部署的准备"></a>手动部署的准备</h2><p>Java jdk:<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Java jdk官方</a>（下载“jdk-序号-linux-x64.tar.gz”版本）</p><p>Tomcat：<a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">Tomcat官方下载链接</a>（点击首页左侧Tomcat 8，下载“tar.gz (pgp, md5, sha1)”）</p><h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><p>1、打开Xshell和Xftp，用Xftp在云服务器创建文件夹</p><p><img src="https://upload-images.jianshu.io/upload_images/6089846-9c0ab37c7f566143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt></p><p>2、将jdk安装包和tomcat安装包复制粘贴到云服务器对应的文件夹下</p><p>3、在Xshell输入指令，解压jdk安装包到指定文件夹</p><blockquote><p>#tar-zxvf jdk-版本编号-linux-x64.tar.gz-C/usr/java/jdk/</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6089846-60aea858d317c8ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/681/format/webp" alt></p><p>4、解压完毕后jdk文件夹里会有对应文件，开始配置环境变量</p><blockquote><p>#vi /etc/profile<br>export JAVA_HOME=/usr/java/jdk/jdk版本编号_121<br>export JRE_HOME=/usr/java/jdk/jdk版本编号_121/jre<br>export CLASSPATH=.:$JAVA_HOME/lib$:JRE_HOME/lib:$CLASSPATH<br>export PATH=$JAVA_HOME/bin:$JRE_HOME/bin/$JAVA_HOME:$PATH</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6089846-1b2e66251be5b64a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/519/format/webp" alt></p><p>5、编辑完内容后，按下Esc键，并输入“:wq”，然后回车可以保存退出</p><p>6、保存完毕后输入下面指令</p><blockquote><p>#source /etc/profile</p></blockquote><p>7、验证是否成功</p><blockquote><p>#java -version</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6089846-9d6b1ed45549eb66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666/format/webp" alt></p><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>1、解压tomcat，解压指令如下：</p><blockquote><p>#tar -xvf apache-tomcat-版本编号.tar.gz -C /usr/java/tomcat/</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6089846-5ca276a70bb29aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/852/format/webp" alt></p><p>2、进入解压文件夹下的bin文件夹，指令如下：</p><blockquote><p>#cd/usr/java/tomcat/apache-tomcat-版本编号/bin/</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6089846-41050295e6db549c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/725/format/webp" alt></p><p>3、编辑setclasspath.sh 脚本，指令如下：</p><blockquote><p>#vi setclasspath.sh</p></blockquote><p>4、添写如下内容：</p><blockquote><p>export JAVA_HOME=/usr/java/jdk/jdk版本编号<br>export JRE_HOME=/usr/java/jdk/jdk版本编号/jre</p></blockquote><p>5、保存编辑内容，按下Esc键，并输入“:wq”，然后回车可以保存退出。</p><p>6、启动tomcat，指令如下：</p><blockquote><p> #./startup.sh</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6089846-66ccc6c4134336b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/854/format/webp" alt></p><p>7、jdk和tomcat都弄好了，接下来可以用浏览器访问我的云服务器吗？</p><p>当然可以！你可以从浏览器访问，输入http://云服务器的ip:8080就能访问啦！</p><p><img src="https://upload-images.jianshu.io/upload_images/6089846-adacb39c1796acf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt></p><h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><p>将项目上传到 Tomcat文件夹下的 Webapps 文件夹里就行。上传好了后，浏览器访问即可。例如：http://云服务器ip地址:8080/index/one.html等。</p><p><img src="https://upload-images.jianshu.io/upload_images/6089846-1919ee11f2bba7a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/922/format/webp" alt></p><h3 id="怎么通过我的域名访问我的网站呢"><a href="#怎么通过我的域名访问我的网站呢" class="headerlink" title="怎么通过我的域名访问我的网站呢"></a>怎么通过我的域名访问我的网站呢</h3><p>解析域名<br>域名直接访问</p><hr><p>参考</p><p><a href="https://www.jianshu.com/p/2604e53a7f6a?from=singlemessage" target="_blank" rel="noopener">阿里云ECS建网站（建站）超详细全套完整图文教程！菜鸟必看！</a></p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress建站</title>
      <link href="/2019/09/11/WordPress%E5%BB%BA%E7%AB%99/"/>
      <url>/2019/09/11/WordPress%E5%BB%BA%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>最近想让博客绑定域名，逛了阿里云，脑子一热又买了服务器，学生认证也挺优惠的，趁机会学习以下建站。因为个人没有基础，所以就从网上搜集教程，结合了多篇文章进行学习。</p><p>教程讲解了WordPress建站流程，从服务器配置、域名解析、宝塔面板、Wordpress建站、网站优化等操作讲解建站方法。</p><a id="more"></a><p>转自 <a href="https://blog.csdn.net/aliyunguide/article/details/86664703" target="_blank" rel="noopener">https://blog.csdn.net/aliyunguide/article/details/86664703</a></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>域名：实名认证</li><li>服务器：内存512M以上Linux服务器，推荐使用1G内存、Centos7系统。国内服务器需要备案才可以用</li><li>其他：Wordpress主题、插件等，免费或者付费都可以，免费的可以查看我们推荐的<a href="https://themeforwp.net/archives/wordpress-blog-theme/" target="_blank" rel="noopener">WordPress</a>免费主题，付费的可以到Themeforest挑选</li></ul><h2 id="服务器LNMP环境搭建"><a href="#服务器LNMP环境搭建" class="headerlink" title="服务器LNMP环境搭建"></a>服务器LNMP环境搭建</h2><p>想要运行Wordpress网站程序，必须要有对应的软件，也就是服务器环境，比如我们常说的LNMP就是 Linux + Nginx + Mysql + PHP 环境，最常见的网站程序，Wordpress程序就是结合这些语言开发出来的。</p><p>其实环境里面安装LNMP是众所周知的，这里我要说的是软件的版本，服务器不同于虚拟主机，我们可以自主控制各种程序的参数和版本，这将让网站的配置非常灵活。为了wordpress兼容和性能，关于软件版本的选择有一个很好的标准就是wordpress官方推荐环境，官方的建议是PHP7.2版本及以上，Mysql5.6版本及以上，还有就是https，安装软件的的原则就是版本越接近推荐的越好</p><p>接下来就让我们从使用服务器命令开始，搭建Wordpress网站的LNMP环境</p><h3 id="安装Xshell"><a href="#安装Xshell" class="headerlink" title="安装Xshell"></a>安装Xshell</h3><p>由于Windows是不能直接连接到Linux服务器的，需要一个SSH的软件，推荐使用Xshell作为远程连接软件，它对于个人和学校是免费使用的，可以在Xshell官网直接下载。</p><h3 id="连接到服务器"><a href="#连接到服务器" class="headerlink" title="连接到服务器"></a>连接到服务器</h3><p>安装好了Xshell软件之后，就可以开始连接到服务器了，提前准备好服务器的IP、账号、密码</p><p>打开Xshell软件，选择文件 – 新建，添加一个连接</p><p>图1-1为连接成功</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3c7e5bb2f3eb0b7dcf39547db3389e49?method=download&shareKey=498e383173ce4768c290d70dfe93255f" alt="图1-1"></p><h3 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h3><p>接下来我们在服务器安装宝塔面板，输入下面的命令并执行(最新宝塔面板需要在centos7系统用，其他系统的命令<a href="https://www.bt.cn/bbs/thread-1186-1-1.html" target="_blank" rel="noopener">查看这里</a>)</p><blockquote><p>yum install -y wget &amp;&amp; wget -O install.sh <a href="http://download.bt.cn/install/install_6.0.sh" target="_blank" rel="noopener">http://download.bt.cn/install/install_6.0.sh</a> &amp;&amp; bash install.sh</p></blockquote><p>安装中途会脚本询问是否将网站安装在www目录，直接选择y，然后确认即可，大概会需要几分钟的时间</p><p>安装成功后会出现图1-2的信息</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180613225752.jpg" alt="图1-2"></p><p>最后得到了宝塔面板的登陆信息，将这些保存下来</p><p>宝塔面板为了提升安全，已将面板路径在之前的8888端口增加了随机入口，所以最好将登录信息长期保存，以后面板的管理都需要用到这些信息</p><h3 id="安装网站环境"><a href="#安装网站环境" class="headerlink" title="安装网站环境"></a>安装网站环境</h3><p>使用刚刚获得到的信息，访问你的ip:8888，登陆宝塔面板，比如刚刚我的就是访问 <a href="http://45.76.48.16:8888，账号密码也就是刚刚安装完显示的" target="_blank" rel="noopener">http://45.76.48.16:8888，账号密码也就是刚刚安装完显示的</a></p><p>(注意：如果使用的是阿里云之类的云服务器提前开放安全端口)</p><p>首次登陆宝塔面板后台，会弹出一键安装环境，在这里我们需要耐心设置一遍</p><p>仔细看下图中的设置，安装环境主要有3个点</p><ul><li>选择LNMP环境，节省资源</li><li>调整Mysql和PHP版本</li><li>安装方式选择为编译安装</li></ul><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614070705.jpg" alt></p><p>最好是按照上图的配置安装，可能有朋友会问为什么不选择 PHP7.2，这里主要是考虑到各种主题和插件的最大兼容，如果选择PHP7.2的话可能会有一些奇怪的问题，当然如果后期主题和插件都兼容了也可以切换到7.2。还有一点就是如果服务器为512M内存要选择Mysql5.5，不然压力会很大</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614071911.jpg" alt></p><p>LNMP环境编译安装过程大概为半小时左右，视服务器性能而定</p><h2 id="搭建Wordpress网站"><a href="#搭建Wordpress网站" class="headerlink" title="搭建Wordpress网站"></a>搭建Wordpress网站</h2><p>当服务器LNMP环境安装完成之后，我们就可以开始着手搭建Wordpress网站了，这里就是建站的主要步骤，用过虚拟主机的朋友应当非常熟悉</p><h3 id="新建站点"><a href="#新建站点" class="headerlink" title="新建站点"></a>新建站点</h3><p>选择网站 – 添加站点，首先填入自己的域名，一般是 domain.com 和 <a href="http://www.domain.com" target="_blank" rel="noopener">www.domain.com</a> 两种格式都要绑定，并创建FTP和数据库</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614125432.jpg" alt></p><p>创建完成后会在网站列表中显示，这里面的密码记不记无所谓，可以随时查看，后期还要通过这里进行网站管理</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614125517.jpg" alt></p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>服务器已经绑定了域名，接下来就是添加解析了，其实就是添加2条A记录，非常简单，这里我用的是腾讯云域名，其他的服务商可能稍微有些不同</p><p>登陆控制台，选择域名注册 – 找到自己的域名 – 解析</p><p>和服务器绑定一致，域名也是添加2条记录，一个是www对应 <a href="http://www.domain.com，另一个是@，对应domain.com，全部解析到服务器的ip地址" target="_blank" rel="noopener">www.domain.com，另一个是@，对应domain.com，全部解析到服务器的ip地址</a></p><p>解析完成后访问域名，如果显示 恭喜, 站点创建成功，就证明解析完成，可以进入下一步的网站搭建了，如果还不能访问，稍等几分钟再尝试</p><p>注意，有些国外域名解析的话生效较慢，需要等待一天左右时间</p><h3 id="下载Wordpress安装包"><a href="#下载Wordpress安装包" class="headerlink" title="下载Wordpress安装包"></a>下载Wordpress安装包</h3><p>因为需要到wordpress官网下载程序，就采用的是宝塔的远程下载功能，先教大家如何使用</p><p>我们进入宝塔后台 – 文件，可以看到这就是服务器的文件系统，默认的/www目录就是所有网站的目录，可以看到刚刚我们创建的网站 wpwp.xyz，我们点击就能就入网站里面</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614133227.jpg" alt></p><p>可以看到网站下还很空，可以先把2个没用的 index.html 和 404.html 删除</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614133423-800x333.jpg" alt></p><p>在文件的上方，我们可以看到在上传的右边有一个远程下载的按钮，点击会弹出一个对话框</p><p>这里我们就填入wordpress最新版的下载地址，确定之后就会下载到当前的目录</p><p>有的朋友可能不知道如何获取下载地址，打开<a href="https://cn.wordpress.org/download/" target="_blank" rel="noopener">wordpress中文下载</a>，在下载按钮上右键 – 复制链接地址</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614134204.jpg" alt></p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614133907.jpg" alt></p><p>等待一会下载完成后，点击一下刷新按钮，就能看到Wordpress程序的压缩包</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614134338.jpg" alt></p><p>选择右键 – 解压，直接确定</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614134711.jpg" alt></p><p>解压完成后网站根目录会多出一个wordpress的文件夹</p><p>但这样不能直接使用的，我们还要继续将wordpress文件夹内的所有文件移动到网站的根目录</p><p>选中所有文件，然后剪切，然后到网站根目录粘贴所有</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614134952.jpg" alt></p><p>最后的目录结构如下图就行了</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614135525.jpg" alt></p><h3 id="WordPress安装"><a href="#WordPress安装" class="headerlink" title="WordPress安装"></a>WordPress安装</h3><p>环境和程序都就绪了，接下来就可以开始安装Wordpress网站了</p><p>访问 <a href="http://www.domain.com(自己购买的域名)，进入程序安装界面，第一步选择" target="_blank" rel="noopener">www.domain.com(自己购买的域名)，进入程序安装界面，第一步选择</a> 现在就开始</p><p><img src="https://themeforwp.net/wp-content/uploads/2018/06/20180614150844-800x444.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> WordPress </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress搭建 </tag>
            
            <tag> WordPress优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程思想第七章练习</title>
      <link href="/2019/09/04/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/09/04/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>编程思想第七章练习</p><a id="more"></a><h2 id="练习1"><a href="#练习1" class="headerlink" title="练习1:"></a>练习1:</h2><p>创建一个简单的类。第二个类中，将一个引用定义为第一个类的对象。运用惰性初始化来实例化 这个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     Second second  = new Second(&quot;Init String&quot;);</span><br><span class="line">     second.chenked();</span><br><span class="line">     System.out.println(second.getSimple());</span><br><span class="line">     second.chenked();</span><br><span class="line">     System.out.println(second);</span><br><span class="line">     second.setSimple(&quot;New String&quot;);</span><br><span class="line">     System.out.println(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Simple&#123;</span><br><span class="line">String s;</span><br><span class="line">public Simple(String si) &#123;</span><br><span class="line">s = si;</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">public void setString(String sNew) &#123;</span><br><span class="line">s = sNew;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Second&#123;</span><br><span class="line">Simple simple;</span><br><span class="line">String s;</span><br><span class="line">public Second(String si) &#123;</span><br><span class="line">s = si;</span><br><span class="line">&#125;</span><br><span class="line">public void chenked() &#123;</span><br><span class="line">if(simple==null) &#123;</span><br><span class="line">System.out.println(&quot;not initialized&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;initialized&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Simple lazy() &#123;</span><br><span class="line">if(simple==null) &#123;</span><br><span class="line">System.out.println(&quot;Creating simple&quot;);</span><br><span class="line">simple = new Simple(s);</span><br><span class="line">&#125;</span><br><span class="line">return simple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Simple getSimple() &#123;</span><br><span class="line">return lazy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">return lazy().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSimple(String sNew) &#123;</span><br><span class="line">lazy().setString(sNew);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">not initialized</span><br><span class="line">Creating simple</span><br><span class="line">Init String</span><br><span class="line">initialized</span><br><span class="line">Init String</span><br><span class="line">New String</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h2><p>从Detergent中继承产生一个新的类。覆盖scrub()并添加一个名为sterilize()的新方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Cleanser &#123;</span><br><span class="line">      private String s = &quot;Cleanser&quot;;</span><br><span class="line">      public void append(String a) &#123; s += a; &#125;</span><br><span class="line">      public void dilute() &#123; append(&quot; dilute()&quot;); &#125;</span><br><span class="line">      public void apply() &#123; append(&quot; apply()&quot;); &#125;</span><br><span class="line">      public void scrub() &#123; append(&quot; scrub()&quot;); &#125;</span><br><span class="line">      public String toString() &#123; return s; &#125;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">        Cleanser x = new Cleanser();</span><br><span class="line">        x.dilute(); x.apply(); x.scrub();</span><br><span class="line">        System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    public class Detergent extends Cleanser &#123;</span><br><span class="line">      // Change a method:</span><br><span class="line">      public void scrub() &#123;</span><br><span class="line">        append(&quot; Detergent.scrub()&quot;);</span><br><span class="line">        super.scrub(); // Call base-class version</span><br><span class="line">      &#125;</span><br><span class="line">      // Add methods to the interface:</span><br><span class="line">      public void foam() &#123; append(&quot; foam()&quot;); &#125;</span><br><span class="line">      // Test the new class:</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">        Detergent x = new Detergent();</span><br><span class="line">        x.dilute();</span><br><span class="line">        x.apply();</span><br><span class="line">        x.scrub();</span><br><span class="line">        x.foam();</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(&quot;Testing base class:&quot;);</span><br><span class="line">        Cleanser.main(args);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">        NewDetergent newDetergent = new NewDetergent();</span><br><span class="line">        newDetergent.dilute();</span><br><span class="line">        newDetergent.scrub();</span><br><span class="line">        newDetergent.sterilize();</span><br><span class="line">        System.out.println(newDetergent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class NewDetergent extends Detergent&#123;</span><br><span class="line">    public void scrub() &#123;</span><br><span class="line">        append(&quot;new Detergent.scrub&quot;);</span><br><span class="line">        super.scrub();</span><br><span class="line">    &#125;</span><br><span class="line">    public void sterilize() &#123;</span><br><span class="line">        append(&quot;sterilize&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a>练习3：</h2><p>证明前面两句话（即使你不为Cartoon创建构造器，编译器也为会你合成一个默认的构造器，该构造器将调用基类的构造器）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Cartoon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Art&#123;</span><br><span class="line">    Art()&#123;</span><br><span class="line">        System.out.println(&quot;Art constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Drawing extends Art&#123;</span><br><span class="line">    Drawing()&#123;</span><br><span class="line">        System.out.println(&quot;Drawing Contructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cartoon extends Drawing&#123;</span><br><span class="line">//  public Cartoon() &#123;</span><br><span class="line">//      System.out.println(&quot;Cartoon Contructor&quot;);</span><br><span class="line">//  &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Art constructor</span><br><span class="line">Drawing Contructor</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习4："><a href="#练习4：" class="headerlink" title="练习4："></a>练习4：</h2><p>证明基类构造器总是会被调用，在导出类构造器之前被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          new Derived2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Base1&#123;</span><br><span class="line"></span><br><span class="line">    public Base1() &#123;</span><br><span class="line">        System.out.println(&quot;Base1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived1 extends Base1&#123;</span><br><span class="line"></span><br><span class="line">    public Derived1() &#123;</span><br><span class="line">        System.out.println(&quot;Derived&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived2 extends Derived1&#123;</span><br><span class="line"></span><br><span class="line">    public Derived2() &#123;</span><br><span class="line">        System.out.println(&quot;Derived2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习5："><a href="#练习5：" class="headerlink" title="练习5："></a>练习5：</h2><p>创建两个带有默认构造器（空参数列表）的类A和类B。从A中继承产生一个名为C的新，并在C内创建一个B类的成员。不要给C编写构造器。创建一个C类的对象并观察其结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">A() &#123;</span><br><span class="line">System.out.println(&quot;A()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">B() &#123;</span><br><span class="line">System.out.println(&quot;B()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class C extends A&#123;</span><br><span class="line">B b = new B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       new C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">A()</span><br><span class="line">B()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习7："><a href="#练习7：" class="headerlink" title="练习7："></a>练习7：</h2><p>修改练习5，使A和B以带参数的构造器取代默认的构造器。为C写一个构造器，并在其中执行所有初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">A(int i) &#123;</span><br><span class="line">System.out.println(&quot;A()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">B(String i) &#123;</span><br><span class="line">System.out.println(&quot;B()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class C extends A&#123;</span><br><span class="line">C()&#123;</span><br><span class="line">super(1);</span><br><span class="line">B b = new B(&quot;s&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       new C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习8："><a href="#练习8：" class="headerlink" title="练习8："></a>练习8：</h2><p>创建一个基类，它仅有一个非默认构造器；再创建一个导出类，它带有默认构造器和非默认构造器。在导出类的构造器中调用基类的构造器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">A(int i)&#123;</span><br><span class="line">System.out.println(&quot;A()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test extends A&#123;</span><br><span class="line">Test()&#123;</span><br><span class="line">super(1);</span><br><span class="line">&#125;</span><br><span class="line">Test(int i)&#123;</span><br><span class="line">super(i);</span><br><span class="line">&#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    new Test();</span><br><span class="line">    new Test(2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习9："><a href="#练习9：" class="headerlink" title="练习9："></a>练习9：</h2><p>创建一个Root类，令其含有名为Component1、Component 2、Component3的类的各一个实例（这些也由你写）。从Root中派生一个类Stem，也含有上述各“组成部分”。所有的类都应带有可打印出类的相关信息的默认构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Component1&#123;</span><br><span class="line">Component1()&#123;</span><br><span class="line">System.out.println(&quot;Component1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Component2&#123;</span><br><span class="line">Component2()&#123;</span><br><span class="line">System.out.println(&quot;Component2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Component3&#123;</span><br><span class="line">Component3()&#123;</span><br><span class="line">System.out.println(&quot;Component3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Root &#123;</span><br><span class="line">Component1 c1 = new Component1();</span><br><span class="line">Component2 c2 = new Component2();</span><br><span class="line">Component3 c3 = new Component3();</span><br><span class="line">Root()&#123;</span><br><span class="line">System.out.println(&quot;Root()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stem extends Root&#123;</span><br><span class="line">Component1 c1 = new Component1();</span><br><span class="line">Component2 c2 = new Component2();</span><br><span class="line">Component3 c3 = new Component3();</span><br><span class="line">Stem()&#123;</span><br><span class="line">System.out.println(&quot;Stem()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stem s = new Stem();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Component1</span><br><span class="line">Component2</span><br><span class="line">Component3</span><br><span class="line">Root()</span><br><span class="line">Component1</span><br><span class="line">Component2</span><br><span class="line">Component3</span><br><span class="line">Stem()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习10："><a href="#练习10：" class="headerlink" title="练习10："></a>练习10：</h2><p>修改练习9，使每个类都仅具有非默认的构造器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Component1&#123;</span><br><span class="line">Component1()&#123;</span><br><span class="line">System.out.println(&quot;Component1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Component2&#123;</span><br><span class="line">Component2()&#123;</span><br><span class="line">System.out.println(&quot;Component2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Component3&#123;</span><br><span class="line">Component3()&#123;</span><br><span class="line">System.out.println(&quot;Component3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Root &#123;</span><br><span class="line">Component1 c1 = new Component1();</span><br><span class="line">Component2 c2 = new Component2();</span><br><span class="line">Component3 c3 = new Component3();</span><br><span class="line"></span><br><span class="line">Root(int i)&#123;</span><br><span class="line">System.out.println(&quot;Root()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stem extends Root&#123;</span><br><span class="line">Component1 c1 = new Component1();</span><br><span class="line">Component2 c2 = new Component2();</span><br><span class="line">Component3 c3 = new Component3();</span><br><span class="line"></span><br><span class="line">Stem(int i)&#123;</span><br><span class="line">super(i);</span><br><span class="line">System.out.println(&quot;Stem()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stem s = new Stem(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Component1</span><br><span class="line">Component2</span><br><span class="line">Component3</span><br><span class="line">Root()</span><br><span class="line">Component1</span><br><span class="line">Component2</span><br><span class="line">Component3</span><br><span class="line">Stem()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习12："><a href="#练习12：" class="headerlink" title="练习12："></a>练习12：</h2><p>将一个适当的dispose()方法的层次结构添加到练习9的所有类中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class Component1&#123;</span><br><span class="line">Component1()&#123;</span><br><span class="line">System.out.println(&quot;Component1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;Componentc1.dispose()&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Component2&#123;</span><br><span class="line">Component2()&#123;</span><br><span class="line">System.out.println(&quot;Component2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;Componentc2.dispose()&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Component3&#123;</span><br><span class="line">Component3()&#123;</span><br><span class="line">System.out.println(&quot;Component3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;Componentc3.dispose()&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Root &#123;</span><br><span class="line">Component1 c1 = new Component1();</span><br><span class="line">Component2 c2 = new Component2();</span><br><span class="line">Component3 c3 = new Component3();</span><br><span class="line">Root()&#123;</span><br><span class="line">System.out.println(&quot;Root()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;Root.dispose()&quot;);</span><br><span class="line">        c1.dispose();</span><br><span class="line">        c2.dispose();</span><br><span class="line">        c3.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stem extends Root&#123;</span><br><span class="line">Component1 c1 = new Component1();</span><br><span class="line">Component2 c2 = new Component2();</span><br><span class="line">Component3 c3 = new Component3();</span><br><span class="line">Stem()&#123;</span><br><span class="line">System.out.println(&quot;Stem()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void dispose() &#123;</span><br><span class="line">        System.out.println(&quot;Stem.dispose()&quot;);</span><br><span class="line">        c1.dispose();</span><br><span class="line">        c2.dispose();</span><br><span class="line">        c3.dispose();</span><br><span class="line">        super.dispose();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Stem().dispose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Component1</span><br><span class="line">Component2</span><br><span class="line">Component3</span><br><span class="line">Root()</span><br><span class="line">Component1</span><br><span class="line">Component2</span><br><span class="line">Component3</span><br><span class="line">Stem()</span><br><span class="line">Stem.dispose()</span><br><span class="line">Componentc1.dispose()</span><br><span class="line">Componentc2.dispose()</span><br><span class="line">Componentc3.dispose()</span><br><span class="line">Root.dispose()</span><br><span class="line">Componentc1.dispose()</span><br><span class="line">Componentc2.dispose()</span><br><span class="line">Componentc3.dispose()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习13"><a href="#练习13" class="headerlink" title="练习13:"></a>练习13:</h2><p>创建一个类，它应带有一个被重载了三次的方法。继承产生一个新类，并添加一个该方法的新的重载定义，展示这四个方法在导出类中都是可以使用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">void Overload(int i) &#123;</span><br><span class="line">System.out.println(&quot;A1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void Overload(String i) &#123;</span><br><span class="line">System.out.println(&quot;A2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void Overload(float i) &#123;</span><br><span class="line">System.out.println(&quot;A3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test extends A&#123;</span><br><span class="line">void Overload(char i) &#123;</span><br><span class="line">System.out.println(&quot;Test&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test test = new Test();</span><br><span class="line">test.Overload(1);</span><br><span class="line">test.Overload(&quot;1&quot;);</span><br><span class="line">test.Overload(1f);</span><br><span class="line">test.Overload(&apos;1&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">A1</span><br><span class="line">A2</span><br><span class="line">A3</span><br><span class="line">Test</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习14："><a href="#练习14：" class="headerlink" title="练习14："></a>练习14：</h2><p>在Car.java中给Engine添加一个service(),并在main()中调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Engine&#123;</span><br><span class="line">public void start() &#123;&#125;</span><br><span class="line">public void rev() &#123;&#125;</span><br><span class="line">public void stop() &#123;&#125;</span><br><span class="line">public void service() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wheel&#123;</span><br><span class="line">public void inflate(int psi) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Window&#123;</span><br><span class="line">public void rollup() &#123;&#125;</span><br><span class="line">public void rolldown() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Door&#123;</span><br><span class="line">public Window window = new Window();</span><br><span class="line">public void open() &#123;&#125;</span><br><span class="line">public void close() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Car&#123;</span><br><span class="line">private Engine engine = new Engine();</span><br><span class="line">private Wheel[] wheel = new Wheel[4];</span><br><span class="line">public Door</span><br><span class="line">left = new Door(),</span><br><span class="line">right = new Door();</span><br><span class="line">public Car() &#123;</span><br><span class="line">for(int i=0;i&lt;4;i++) &#123;</span><br><span class="line">wheel[i] = new Wheel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car = new Car();</span><br><span class="line">car.left.window.rollup();</span><br><span class="line">car.wheel[0].inflate(72);</span><br><span class="line">car.engine.service();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习15："><a href="#练习15：" class="headerlink" title="练习15："></a>练习15：</h2><p>在包中编写一个类，类应具备一个protected方法。在包外部，试着调用protede方法并解释其结果。然后，从你的类中继承产生一个类，并从该导出类的方法内部调用该protected方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package test1982;</span><br><span class="line"></span><br><span class="line">public class A&#123;</span><br><span class="line">protected void f() &#123;</span><br><span class="line">System.out.println(&quot;f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line">import test1982.*;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">public void g() &#123;</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new B().g();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习16："><a href="#练习16：" class="headerlink" title="练习16："></a>练习16：</h2><p>创建一个名为Amphibian的类，由此继承产生一个成为Frog的类，在基类中设置适当的方法，在main（）中，创建一个Frog向上转型至Amphibian， 然后说明所有方法都可工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Amphibian&#123;</span><br><span class="line">public void f() &#123;</span><br><span class="line">System.out.println(&quot;f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Frog extends Amphibian&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Amphibian am =new Frog();</span><br><span class="line">am.f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习17："><a href="#练习17：" class="headerlink" title="练习17："></a>练习17：</h2><p>修改练习16，使Frog覆盖基类中方法的定义。请留心main中都发生了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Amphibian&#123;</span><br><span class="line">public void f() &#123;</span><br><span class="line">System.out.println(&quot;Amphibian.f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Frog extends Amphibian&#123;</span><br><span class="line">public void f() &#123;</span><br><span class="line">System.out.println(&quot;Frog.f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Amphibian am =new Frog();</span><br><span class="line">am.f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习18："><a href="#练习18：" class="headerlink" title="练习18："></a>练习18：</h2><p>创建一个含有static final域和final域的类，说明二者间的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Exercise7_18 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;First Object&quot;);</span><br><span class="line">System.out.println(new WithFinalFields());</span><br><span class="line">System.out.println(&quot;Second Object&quot;);</span><br><span class="line">System.out.println(new WithFinalFields());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SelfCounter &#123;</span><br><span class="line">private static int count;</span><br><span class="line">private int id = count++;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Selfcounter&quot; + id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WithFinalFields &#123;</span><br><span class="line">final SelfCounter selfCounter = new SelfCounter();</span><br><span class="line">static final SelfCounter s = new SelfCounter();</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;selfcounter = &quot; + selfCounter + &quot; \ns = &quot; + s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">First Object</span><br><span class="line">selfcounter = Selfcounter1 </span><br><span class="line">s = Selfcounter0</span><br><span class="line">Second Object</span><br><span class="line">selfcounter = Selfcounter2 </span><br><span class="line">s = Selfcounter0</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习20："><a href="#练习20：" class="headerlink" title="练习20："></a>练习20：</h2><p>展示@Override注解可以解决本节中的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class WithFinals &#123;</span><br><span class="line">// Identical to &quot;private&quot; alone:</span><br><span class="line">private final void f() &#123;</span><br><span class="line">System.out.println(&quot;WithFinals.f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Also automatically &quot;final&quot;:</span><br><span class="line">private void g() &#123;</span><br><span class="line">System.out.println(&quot;WithFinals.g()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OverridingPrivate extends WithFinals &#123;</span><br><span class="line">private final void f() &#123;</span><br><span class="line">System.out.println(&quot;OverridingPrivate.f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void g() &#123;</span><br><span class="line">System.out.println(&quot;OverridingPrivate.g()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OverridingPrivate2 extends OverridingPrivate &#123;</span><br><span class="line">public final void f() &#123;</span><br><span class="line">System.out.println(&quot;OverridingPrivate2.f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void g() &#123;</span><br><span class="line">System.out.println(&quot;OverridingPrivate2.g()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FinalOverridingIllusion &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">OverridingPrivate2 op2 = new OverridingPrivate2();</span><br><span class="line">op2.f();</span><br><span class="line">op2.g();</span><br><span class="line">// You can upcast:</span><br><span class="line">OverridingPrivate op = op2;</span><br><span class="line">// But you can&apos;t call the methods:</span><br><span class="line">// ! op.f();</span><br><span class="line">// ! op.g();</span><br><span class="line">// Same here:</span><br><span class="line">WithFinals wf = op2;</span><br><span class="line">// ! wf.f();</span><br><span class="line">// ! wf.g();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Exercise7_20 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">OverridingPrivate20 oPrivate = new OverridingPrivate20();</span><br><span class="line">// oPrivate.f();</span><br><span class="line">// oPrivate.g();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OverridingPrivate20 extends WithFinals &#123;</span><br><span class="line">@Override</span><br><span class="line">private final void f() &#123;</span><br><span class="line">System.out.println(&quot;OverridingPrivate.f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">private void g() &#123;</span><br><span class="line">System.out.println(&quot;OverridingPrivate.g()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OverridingPrivate30 extends OverridingPrivate20 &#123;</span><br><span class="line">@Override</span><br><span class="line">public void f() &#123;</span><br><span class="line">System.out.println(&quot;OverridingPrivate2.f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void g() &#123;</span><br><span class="line">System.out.println(&quot;OverridingPrivate2.g()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习21："><a href="#练习21：" class="headerlink" title="练习21："></a>练习21：</h2><p>创建一个但final方法的类。由此继承产生一个类并尝试覆盖该方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Exercise7_21 extends WithFinalMethod &#123;</span><br><span class="line">//  void f() &#123;</span><br><span class="line">//    </span><br><span class="line">//  &#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WithFinalMethod &#123;</span><br><span class="line">final void f() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习23："><a href="#练习23：" class="headerlink" title="练习23："></a>练习23：</h2><p>请证明加载类的动作仅发生一次。证明该类的第一个实体的创建者或者对static成员的访问都有可能引起加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Exercise7_23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       System.out.println(&quot;Calling static member&quot;);</span><br><span class="line">       LoadTest.staticMember();</span><br><span class="line">       System.out.println(&quot;Creating an object&quot;);</span><br><span class="line">       new LoadTest();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">class LoadTest&#123;</span><br><span class="line">   static&#123;</span><br><span class="line">       System.out.println(&quot;Loading loadTest&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   static void staticMember() &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习24："><a href="#练习24：" class="headerlink" title="练习24："></a>练习24：</h2><p>在Beetle.java中，从Beetle类继承产生一个具体类型的“甲壳虫”。其形式与现有类相同，跟踪并解释其输出结果</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thinking in Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java惰性初始化</title>
      <link href="/2019/08/19/Java%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/08/19/Java%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Java惰性初始化</p><a id="more"></a><p>在书中第七章中提到了引用的初始化，编译器并不是简单地为每一个引用都创建默认对象，减少不必要的负担</p><p>1、在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。<br>2、在类的构造器中。<br>3、就在正要使用这些对象之前，这种方式称为惰性初始化。在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担。<br>4、使用实例初始化。</p><p>惰性初始化的目的是延迟对象的初始化，直到程序真正使用它，同时确保它只初始化一次。</p><p>/*<br>惰性初始化：当需要一个实例的时候才初始化一个对象。<br>新建两个简单的类，第二个类中包含第一个类的一个引用，当<br>需要第一个类的对象是调用Lazy()方法即可获得第一个类的对象。<br>*/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class First&#123;</span><br><span class="line"> First()&#123;</span><br><span class="line"> System.out.print(&quot;First()&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Lazy&#123;</span><br><span class="line"> First f;</span><br><span class="line"> public void print()&#123;</span><br><span class="line"> if(f==null)</span><br><span class="line"> f = new First();</span><br><span class="line"> &#125;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line"> Lazy z = new Lazy();</span><br><span class="line"> z.print();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">First()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程思想第五章练习</title>
      <link href="/2019/08/11/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/08/11/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>编程思想第五章练习</p><a id="more"></a><h2 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a>练习1：</h2><p>创建一个类,它包含一个未初始化的String引用.验证该引用被Java初始化成null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">public String string;</span><br><span class="line">&#125;</span><br><span class="line">public class E1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test test = new Test();</span><br><span class="line">System.out.println((test.string == null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h2><p>创建一个类，它包含一个在定义时就被初始化了的String域，以及另一个通过构造器初始化的String域。这两种方式有何差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">String s1=&quot;Initialized at definition&quot;;</span><br><span class="line">String s2;</span><br><span class="line">public Test(String s) &#123;</span><br><span class="line">s2 = s;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test test = new Test(&quot;Initialized at constructor&quot;);</span><br><span class="line">System.out.println(&quot;s1= &quot;+test.s1);</span><br><span class="line">System.out.println(&quot;s2= &quot;+test.s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a>练习3：</h2><p>创建一个带默认构造器（即无参构造器）的类，在构造器中打印一条消息。为这个类创建一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class T1&#123;</span><br><span class="line">T1()&#123;</span><br><span class="line">System.out.println(&quot;无参构造器&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new T1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习4："><a href="#练习4：" class="headerlink" title="练习4："></a>练习4：</h2><p>为前一个练习中的类添加一个重载构造器，令其接受一个字符参数，并在构造器中把你自己的信息和接受的参数一起打印出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class T1&#123;</span><br><span class="line">T1()&#123;</span><br><span class="line">System.out.println(&quot;这是无参构造器&quot;);</span><br><span class="line">&#125;</span><br><span class="line">T1(String s)&#123;</span><br><span class="line">System.out.println(&quot;这是&quot;+s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new T1();</span><br><span class="line">new T1(&quot;重载构造器&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">这是无参构造器</span><br><span class="line">这是重载构造器</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习5："><a href="#练习5：" class="headerlink" title="练习5："></a>练习5：</h2><p>创建一个名为Dog的类，它具有重载的bark（）方法。此方法应根据不同的基本数据类型进行重载，并根据被调用的版本，打印出不同类型的狗吠（barking）、咆哮（howling）等信息，编写main（）来调用所有不同版本的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">void bark() &#123;</span><br><span class="line">System.out.println(&quot;barking&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void bark(int i) &#123;</span><br><span class="line">System.out.println(&quot;howling&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.bark(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">barking</span><br><span class="line">howling</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习6："><a href="#练习6：" class="headerlink" title="练习6："></a>练习6：</h2><p>修改前一个练习的程序，让两个重载方法各自接受两个类型的不同的参数，但二者顺序相反。验证其是否工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">void bark(float f,int i) &#123;</span><br><span class="line">System.out.println(&quot;barking&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void bark(int i,float f) &#123;</span><br><span class="line">System.out.println(&quot;howling&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.bark(1.1f,1);</span><br><span class="line">dog.bark(1,1.1f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">barking</span><br><span class="line">howling</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习7："><a href="#练习7：" class="headerlink" title="练习7："></a>练习7：</h2><p>创建一个没有构造器的类，并在main（）中创建其对象，用以验证编译器是否真的自动加入了默认构造器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Dog();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习8："><a href="#练习8：" class="headerlink" title="练习8："></a>练习8：</h2><p>编写具有两个方法的类，在第一个方法内调用第二个方法两次：第一次调用时不使用this关键字，第二次调用时使用this关键字————这里只是为了验证它是起作用的，你不应该在实践中使用这种方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">void t1() &#123;</span><br><span class="line">t2();</span><br><span class="line">this.t2();</span><br><span class="line">&#125;</span><br><span class="line">void t2() &#123;</span><br><span class="line">System.out.println(&quot;t2()&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Test().t1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">t2()</span><br><span class="line">t2()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习14："><a href="#练习14：" class="headerlink" title="练习14："></a>练习14：</h2><p>编写一个类，拥有两个静态字符串域，其中一个在定义处初始化，另一个在静态块中初始化。现在，加入一个静态方法用以打印出两个字段值。请证明它们都会在被使用之前完成初始化动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">static String a = &quot;a&quot;;</span><br><span class="line">static String b;</span><br><span class="line">static &#123;</span><br><span class="line">b = &quot;b&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print() &#123;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习15："><a href="#练习15：" class="headerlink" title="练习15："></a>练习15：</h2><p>编写一个含有字符串域的类，并采用实例初始化方式进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">String s;</span><br><span class="line">&#123;</span><br><span class="line">s = new String(&quot;s&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Test ()&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Mugs&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test test = new Test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习16："><a href="#练习16：" class="headerlink" title="练习16："></a>练习16：</h2><p>创建一个String对象数据，并为每一个元素都赋值一个String。用for循环来打印该数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String[] arrayString = &#123;&quot;1111&quot;,&quot;2222&quot;,&quot;3333&quot;,&quot;4444&quot;&#125;;</span><br><span class="line">        for(String s:arrayString)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">4444</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习17、18："><a href="#练习17、18：" class="headerlink" title="练习17、18："></a>练习17、18：</h2><p>创建一个类，它有一个构造器，这个构造器接收一个String类型的参数。在构造阶段，打印此参数。创建一个该类对象的引用数组，但是不实际地创建对象赋值给该数组。试着运行程序。再试着通过创建对象，再赋值给引用数组，从而完成程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TestString&#123;</span><br><span class="line">TestString(String string)&#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">TestString[] tests = new TestString[] &#123;</span><br><span class="line">new TestString(&quot;a&quot;),</span><br><span class="line">new TestString(&quot;b&quot;)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习19："><a href="#练习19：" class="headerlink" title="练习19："></a>练习19：</h2><p>写一个类，他接受一个可变参数的String数组，验证你可以向该方法传递一个用逗号分隔的String列表，或是一个String[]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">static void printString(String... args) &#123;</span><br><span class="line">for(String s:args) &#123;</span><br><span class="line">System.out.print(s+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">printString(new String[] &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">a b c </span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习20："><a href="#练习20：" class="headerlink" title="练习20："></a>练习20：</h2><p>创建一个使用可变参数列表而不是用普通main()语法的主函数main()，打印args数组的传入的命令行参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String... args) &#123;</span><br><span class="line">for(String s:args) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习21："><a href="#练习21：" class="headerlink" title="练习21："></a>练习21：</h2><p>创建一个enum，它包含纸币中最小面值的6种类型。通过values()循环并打印每一个值及其ordinal()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Money&#123;</span><br><span class="line">One,Five,Ten,Twe,Fif</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">for(Money s:Money.values()) &#123;</span><br><span class="line">System.out.println(s+&quot;,ordinal:&quot;+s.ordinal());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">One,ordinal:0</span><br><span class="line">Five,ordinal:1</span><br><span class="line">Ten,ordinal:2</span><br><span class="line">Twe,ordinal:3</span><br><span class="line">Fif,ordinal:4</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="练习22："><a href="#练习22：" class="headerlink" title="练习22："></a>练习22：</h2><p>在前面的例子中，为enum写一个switch语句，对于每一个case，输出该特定货币的描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">enum Money&#123;</span><br><span class="line">One,Five,Ten,Twe,Fif</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;</span><br><span class="line">void describe(Money s)&#123;</span><br><span class="line">switch(s) &#123;</span><br><span class="line">case One:</span><br><span class="line">System.out.println(&quot;1&quot;);</span><br><span class="line">break;</span><br><span class="line">case Five:</span><br><span class="line">System.out.println(&quot;5&quot;);</span><br><span class="line">break;</span><br><span class="line">case Ten:</span><br><span class="line">System.out.println(&quot;10&quot;);</span><br><span class="line">break;</span><br><span class="line">case Twe:</span><br><span class="line">System.out.println(&quot;20&quot;);</span><br><span class="line">break;</span><br><span class="line">case Fif:</span><br><span class="line">System.out.println(&quot;30&quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">A a = new A();</span><br><span class="line">for(Money s:Money.values()) &#123;</span><br><span class="line">System.out.print(s +&quot;:&quot;);</span><br><span class="line">a.describe(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">One:1</span><br><span class="line">Five:5</span><br><span class="line">Ten:10</span><br><span class="line">Twe:20</span><br><span class="line">Fif:30</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thinking in Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组初始化</title>
      <link href="/2019/08/10/%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/08/10/%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>数组初始化</p><a id="more"></a><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] a1 = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int[] a2;</span><br><span class="line">a2=a1;</span><br><span class="line">for(int i =0;i&lt;a2.length;i++)</span><br><span class="line">a2[i]=a2[i]+1;</span><br><span class="line">for(int i =0;i&lt;a2.length;i++)</span><br><span class="line">System.out.print(a1[i]+&quot; &quot;);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">for(int i =0;i&lt;a2.length;i++)</span><br><span class="line">System.out.print(a2[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">2 3 4 5 6 </span><br><span class="line">2 3 4 5 6 </span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>a1赋值给了a2，a2赋值后，发现a1数组改变，输出a1和a2后发现相等</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java主函数的调用</title>
      <link href="/2019/08/10/Java%E4%B8%BB%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8/"/>
      <url>/2019/08/10/Java%E4%B8%BB%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Java主函数的调用</p><a id="more"></a><p>一个java文件里可以存在多个class，但是只能有一个public class</p><p>你可以创建一个String对象数组，将其传递给另一个main（）方法，以提供参数，用来替换传递给该main（）方法的命令行参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicArray&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Other.main(new String[] &#123;&quot;fiddle&quot;,&quot;de&quot;,&quot;dum&quot;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">for(String s:args) &#123;</span><br><span class="line">System.out.println(s+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">fiddle </span><br><span class="line">de </span><br><span class="line">dum </span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造器初始化</title>
      <link href="/2019/08/09/%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/08/09/%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>构造器初始化</p><a id="more"></a> <h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Window&#123;</span><br><span class="line">Window(int marker)&#123;</span><br><span class="line">System.out.println(&quot;Window(&quot;+marker+&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class House&#123;</span><br><span class="line">Window w1 = new Window(1);</span><br><span class="line">House()&#123;</span><br><span class="line">System.out.println(&quot;House()&quot;);</span><br><span class="line">w3 = new Window(33);</span><br><span class="line">&#125;</span><br><span class="line">Window w2 = new Window(2);</span><br><span class="line">void f() &#123;</span><br><span class="line">System.out.println(&quot;f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Window w3 = new Window(3);</span><br><span class="line">&#125;</span><br><span class="line">public class Flower&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">House h = new House();</span><br><span class="line">h.f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Window(1)</span><br><span class="line">Window(2)</span><br><span class="line">Window(3)</span><br><span class="line">House()</span><br><span class="line">Window(33)</span><br><span class="line">f()</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p><strong><em>w3这个引用会被初始化两次：一次在调用构造器前，一次在调用期间（第一次引用的对象将被丢弃，并作为垃圾回收）</em></strong></p><h2 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h2><p>1、无论创建多少个对象，静态数据都只占用一份存储区域。<br>2、static关键字不能应用于局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Bowl&#123;</span><br><span class="line">Bowl(int marker)&#123;</span><br><span class="line">System.out.println(&quot;Bowl(&quot;+marker+&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f1(int marker) &#123;</span><br><span class="line">System.out.println(&quot;f1(&quot;+marker+&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Table&#123;</span><br><span class="line">static Bowl bowl1 = new Bowl(1);</span><br><span class="line">Table()&#123;</span><br><span class="line">System.out.println(&quot;Table()&quot;);</span><br><span class="line">bowl2.f1(1);</span><br><span class="line">&#125;</span><br><span class="line">void f2(int marker) &#123;</span><br><span class="line">System.out.println(&quot;f2(&quot;+marker+&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">static Bowl bowl2 = new Bowl(2);</span><br><span class="line">&#125;</span><br><span class="line">class Cupboard&#123;</span><br><span class="line">Bowl bowl3 = new Bowl(3);</span><br><span class="line">static Bowl bowl4 = new Bowl(4);</span><br><span class="line">Cupboard()&#123;</span><br><span class="line">System.out.println(&quot;Cupboard()&quot;);</span><br><span class="line">bowl4.f1(2);</span><br><span class="line">&#125;</span><br><span class="line">void f3(int marker) &#123;</span><br><span class="line">System.out.println(&quot;f3(&quot;+marker+&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">static Bowl bowl5 = new Bowl(5);</span><br><span class="line">&#125;</span><br><span class="line">public class Flower&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;Creating new Cupboard() in main&quot;);</span><br><span class="line">new Cupboard();</span><br><span class="line">System.out.println(&quot;Creating new Cupboard() in main&quot;);</span><br><span class="line">new Cupboard();</span><br><span class="line">table.f2(1);</span><br><span class="line">cupboard.f3(1);</span><br><span class="line">&#125;</span><br><span class="line">static Table table = new Table();</span><br><span class="line">static Cupboard cupboard = new Cupboard();</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Bowl(1)</span><br><span class="line">Bowl(2)</span><br><span class="line">Table()</span><br><span class="line">f1(1)</span><br><span class="line">Bowl(4)</span><br><span class="line">Bowl(5)</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">Creating new Cupboard() in main</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">Creating new Cupboard() in main</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">f2(1)</span><br><span class="line">f3(1)</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p><strong><em>初始化时静态对象会先初始化，而后是非静态对象</em></strong></p><h2 id="总结对象的创建过程"><a href="#总结对象的创建过程" class="headerlink" title="总结对象的创建过程"></a>总结对象的创建过程</h2><p>1、即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。<br>2、然后载入Dog.class，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。<br>3、当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。<br>4、这块存储空间会被清零，这就自动地将Dog对象中地所有基本类型数据设置成了默认值（对数字来说就是0，对布尔型和字符型也相同），而引用则被设置成了null。<br>5、执行所有出现于字段定义处地初始化动作。<br>6、执行构造器。</p><h2 id="显式的静态初始化（代码不理解，这里先做下标记把，有空再慢慢看）"><a href="#显式的静态初始化（代码不理解，这里先做下标记把，有空再慢慢看）" class="headerlink" title="显式的静态初始化（代码不理解，这里先做下标记把，有空再慢慢看）"></a>显式的静态初始化（代码不理解，这里先做下标记把，有空再慢慢看）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Cup&#123;</span><br><span class="line">Cup(int marker)&#123;</span><br><span class="line">System.out.println(&quot;Cup(&quot;+marker+&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f(int marker) &#123;</span><br><span class="line">System.out.println(&quot;f(&quot;+marker+&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cups&#123;</span><br><span class="line">static Cup cup1;</span><br><span class="line">static Cup cup2;</span><br><span class="line">static &#123;</span><br><span class="line">cup1 = new Cup(1);</span><br><span class="line">cup2 = new Cup(2);</span><br><span class="line">&#125;</span><br><span class="line">Cups()&#123;</span><br><span class="line">System.out.println(&quot;Cups()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Flower&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;Inside main()&quot;);</span><br><span class="line">Cups.cup1.f(99);</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Inside main()</span><br><span class="line">Cup(1)</span><br><span class="line">Cup(2)</span><br><span class="line">f(99)</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this关键字</title>
      <link href="/2019/08/09/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/08/09/this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>编程思想第五章5.4中,这一段代码看着有点懵逼，记下来</p><a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">void eat(Apple apple) &#123;</span><br><span class="line">Apple peeled =apple.getPeeled();</span><br><span class="line">System.out.println(&quot;Yummy&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Peeler&#123;</span><br><span class="line">static Apple peel(Apple apple) &#123;</span><br><span class="line">return apple;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Apple&#123;</span><br><span class="line">Apple getPeeled() &#123;</span><br><span class="line">return Peeler.peel(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Leaf &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Person().eat(new Apple());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Apple需要调用Peeler.peel（）方法，它是一个外部的工具方法，将执行由于某种原因而必须放在Apple外部的操作。为了将自身传递给外部方法，Apple必须使用this关键字。</em></strong></p><h2 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Flower&#123;</span><br><span class="line">int petalCount = 0;</span><br><span class="line">String s=&quot;initial value&quot;;</span><br><span class="line">Flower(int petals)&#123;</span><br><span class="line">petalCount = petals;</span><br><span class="line">System.out.println(&quot;Constructor w/ int arg only,petalCount= &quot;+petalCount);</span><br><span class="line">&#125;</span><br><span class="line">Flower(String ss)&#123;</span><br><span class="line">System.out.println(&quot;Constructor w/ String arg only,s= &quot;+ss);</span><br><span class="line">s=ss;</span><br><span class="line">&#125;</span><br><span class="line">Flower(String s,int petals)&#123;</span><br><span class="line">this(petals);</span><br><span class="line">//this(s); //Can&apos;t call two!</span><br><span class="line">this.s=s;</span><br><span class="line">System.out.println(&quot;String &amp; int args&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Flower()&#123;</span><br><span class="line">this(&quot;hi&quot;,47);</span><br><span class="line">System.out.println(&quot;default constructor (no args)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void printPetalCount() &#123;</span><br><span class="line">//this(11); //Not inside non-constructor!</span><br><span class="line">System.out.println(&quot;petalCount = &quot;+petalCount+&quot; s= &quot;+s);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Flower x = new Flower();</span><br><span class="line">x.printPetalCount();</span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">Constructor w/ int arg only,petalCount= 47</span><br><span class="line">String &amp; int args</span><br><span class="line">default constructor (no args)</span><br><span class="line">petalCount = 47 s= hi</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p><strong><em>this调用构造器不能调用两个。</em></strong><br><strong><em>构造器调用必须置于起始值。</em></strong><br><strong><em>调用构造器只能在构造器中调用</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java方法重载</title>
      <link href="/2019/08/08/Java%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
      <url>/2019/08/08/Java%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>Java方法重载</p><a id="more"></a><h2 id="示范重载构造器和重载的方法"><a href="#示范重载构造器和重载的方法" class="headerlink" title="示范重载构造器和重载的方法"></a>示范重载构造器和重载的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Tree&#123;</span><br><span class="line">int height;</span><br><span class="line">Tree()&#123;</span><br><span class="line">System.out.println(&quot;Planting a seedling&quot;);</span><br><span class="line">height= 0;</span><br><span class="line">&#125;</span><br><span class="line">Tree(int initialHeight)&#123;</span><br><span class="line">height = initialHeight;</span><br><span class="line">System.out.println(&quot;Creating new Tree that is &quot;+height+&quot; feet tall&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void info() &#123;</span><br><span class="line">System.out.println(&quot;Tree is &quot;+height+&quot;feet tall&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void info(String s) &#123;</span><br><span class="line">System.out.println(s+&quot;:Tree is &quot;+height+&quot;feet tall&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Overloading &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">Tree t = new Tree(i);</span><br><span class="line">t.info();</span><br><span class="line">t.info(&quot;overloaded method&quot;);</span><br><span class="line">&#125;</span><br><span class="line">new Tree();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;/*Output:</span><br><span class="line">Creating new Tree that is 0 feet tall</span><br><span class="line">Tree is 0feet tall</span><br><span class="line">overloaded method:Tree is 0feet tall</span><br><span class="line">Creating new Tree that is 1 feet tall</span><br><span class="line">Tree is 1feet tall</span><br><span class="line">overloaded method:Tree is 1feet tall</span><br><span class="line">Creating new Tree that is 2 feet tall</span><br><span class="line">Tree is 2feet tall</span><br><span class="line">overloaded method:Tree is 2feet tall</span><br><span class="line">Creating new Tree that is 3 feet tall</span><br><span class="line">Tree is 3feet tall</span><br><span class="line">overloaded method:Tree is 3feet tall</span><br><span class="line">Creating new Tree that is 4 feet tall</span><br><span class="line">Tree is 4feet tall</span><br><span class="line">overloaded method:Tree is 4feet tall</span><br><span class="line">Planting a seedling</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h2 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">public class PrimitiveOverloading &#123;</span><br><span class="line">void f1(char x) &#123;</span><br><span class="line">System.out.println(&quot;f1(char) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f1(byte x) &#123;</span><br><span class="line">System.out.println(&quot;f1(byte) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f1(short x) &#123;</span><br><span class="line">System.out.println(&quot;f1(short) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f1(int x) &#123;</span><br><span class="line">System.out.println(&quot;f1(int) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f1(long x) &#123;</span><br><span class="line">System.out.println(&quot;f1(long) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f1(float x) &#123;</span><br><span class="line">System.out.println(&quot;f1(float) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f1(double x) &#123;</span><br><span class="line">System.out.println(&quot;f1(double) &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f2(byte x) &#123;</span><br><span class="line">System.out.println(&quot;f2(byte) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f2(short x) &#123;</span><br><span class="line">System.out.println(&quot;f2(short) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f2(int x) &#123;</span><br><span class="line">System.out.println(&quot;f2(int) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f2(long x) &#123;</span><br><span class="line">System.out.println(&quot;f2(long) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f2(float x) &#123;</span><br><span class="line">System.out.println(&quot;f2(float) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f2(double x) &#123;</span><br><span class="line">System.out.println(&quot;f2(double) &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f3(short x) &#123;</span><br><span class="line">System.out.println(&quot;f3(short) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f3(int x) &#123;</span><br><span class="line">System.out.println(&quot;f3(int) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f3(long x) &#123;</span><br><span class="line">System.out.println(&quot;f3(long) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f3(float x) &#123;</span><br><span class="line">System.out.println(&quot;f3(float) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f3(double x) &#123;</span><br><span class="line">System.out.println(&quot;f3(double) &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f4(int x) &#123;</span><br><span class="line">System.out.println(&quot;f4(int) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f4(long x) &#123;</span><br><span class="line">System.out.println(&quot;f4(long) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f4(float x) &#123;</span><br><span class="line">System.out.println(&quot;f4(float) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f4(double x) &#123;</span><br><span class="line">System.out.println(&quot;f4(double) &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f5(long x) &#123;</span><br><span class="line">System.out.println(&quot;f5(long) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f5(float x) &#123;</span><br><span class="line">System.out.println(&quot;f5(float) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f5(double x) &#123;</span><br><span class="line">System.out.println(&quot;f5(double) &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f6(float x) &#123;</span><br><span class="line">System.out.println(&quot;f6(float) &quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f6(double x) &#123;</span><br><span class="line">System.out.println(&quot;f6(double) &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f7(double x) &#123;</span><br><span class="line">System.out.println(&quot;f7(double) &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void testConstVal() &#123;</span><br><span class="line">System.out.println(&quot;5: &quot;);</span><br><span class="line">f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">void testChar() &#123;</span><br><span class="line">char x = &apos;x&apos;;</span><br><span class="line">System.out.println(&quot;char: &quot;);</span><br><span class="line">f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">void testByte() &#123;</span><br><span class="line">byte x =0;</span><br><span class="line">System.out.println(&quot;byte: &quot;);</span><br><span class="line">f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">void testShort() &#123;</span><br><span class="line">short x =0;</span><br><span class="line">System.out.println(&quot;short: &quot;);</span><br><span class="line">f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">void testInt() &#123;</span><br><span class="line">int x =0;</span><br><span class="line">System.out.println(&quot;int: &quot;);</span><br><span class="line">f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">void testLong() &#123;</span><br><span class="line">long x =0;</span><br><span class="line">System.out.println(&quot;long: &quot;);</span><br><span class="line">f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">void testFloat() &#123;</span><br><span class="line">float x =0;</span><br><span class="line">System.out.println(&quot;float: &quot;);</span><br><span class="line">f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">void testDouble() &#123;</span><br><span class="line">double x =0;</span><br><span class="line">System.out.println(&quot;double: &quot;);</span><br><span class="line">f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">PrimitiveOverloading p = new PrimitiveOverloading();</span><br><span class="line">p.testConstVal();</span><br><span class="line">p.testChar();</span><br><span class="line">p.testByte();</span><br><span class="line">p.testShort();</span><br><span class="line">p.testInt();</span><br><span class="line">p.testLong();</span><br><span class="line">p.testFloat();</span><br><span class="line">p.testDouble();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;/*Output:</span><br><span class="line">5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) </span><br><span class="line">char: </span><br><span class="line">f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) </span><br><span class="line">byte: </span><br><span class="line">f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double) </span><br><span class="line">short: </span><br><span class="line">f1(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double) </span><br><span class="line">int: </span><br><span class="line">f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) </span><br><span class="line">long: </span><br><span class="line">f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double) </span><br><span class="line">float: </span><br><span class="line">f1(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double) </span><br><span class="line">double: </span><br><span class="line">f1(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double) </span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p><strong>如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。</strong></p><h2 id="如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。"><a href="#如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。" class="headerlink" title="如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。"></a>如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void testDouble() &#123;</span><br><span class="line">double x =0;</span><br><span class="line">System.out.println(&quot;double  argument: &quot;);</span><br><span class="line">f1(x);f2((double)x);f3((long)x);f4((int)x);f5((short)x);f6((byte)x);f7((char)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 重载 </tag>
            
            <tag> Thinking in Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java标签</title>
      <link href="/2019/08/07/Java%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/08/07/Java%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p>Java标签</p><a id="more"></a><h2 id="Java标签-博文内容剽窃于Thinking-in-Java第四版四章4-7-●’◡’●"><a href="#Java标签-博文内容剽窃于Thinking-in-Java第四版四章4-7-●’◡’●" class="headerlink" title="Java标签,博文内容剽窃于Thinking in Java第四版四章4.7  (●’◡’●)"></a>Java标签,博文内容剽窃于Thinking in Java第四版四章4.7  (●’◡’●)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">label1:</span><br><span class="line">outer-iteration&#123;</span><br><span class="line">    inner-iteration&#123;</span><br><span class="line">        //...</span><br><span class="line">        break; //(1)</span><br><span class="line">        //...</span><br><span class="line">        continue; //(2)</span><br><span class="line">        //...</span><br><span class="line">        continue label1; //(3)</span><br><span class="line">        //...</span><br><span class="line">        break label1; //(4)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在（1）中，break中断内部迭代。<br>在（2）中，continue使执行点移回内部迭代的起始值。<br>在（3）中，continue label1同时中断内部迭代以及外部迭代，直接转到label1处；随后，它实际上是继续迭代过程，但却从外部迭代开始。<br>在（4）中，break label1也会中断所有迭代，并回到label1处，但并不重新进入迭代。也就是说，它实际是完全中止了两个迭代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    outer:</span><br><span class="line">    for(;true;) &#123;</span><br><span class="line">    inner:</span><br><span class="line">    for(;i&lt;10;i++) &#123;</span><br><span class="line">    System.out.println(&quot;i= &quot;+i);</span><br><span class="line">    if(i==2) &#123;</span><br><span class="line">    System.out.println(&quot;continue&quot;);</span><br><span class="line">    continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==3) &#123;</span><br><span class="line">    System.out.println(&quot;break&quot;);</span><br><span class="line">    i++;    //由于break跳过了递增表达式，所以这里添加了递增运算</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==7) &#123;</span><br><span class="line">    System.out.println(&quot;continue outer&quot;);</span><br><span class="line">    i++;    //添加了递增运算</span><br><span class="line">    continue outer;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==8) &#123;</span><br><span class="line">    System.out.println(&quot;break outer&quot;);</span><br><span class="line">    break outer;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k=0;k&lt;5;k++) &#123;</span><br><span class="line">    if(k==3) &#123;</span><br><span class="line">    System.out.println(&quot;continue inner&quot;);</span><br><span class="line">    continue inner;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Output:<br>i= 0<br>continue inner<br>i= 1<br>continue inner<br>i= 2<br>continue<br>i= 3<br>break<br>i= 4<br>continue inner<br>i= 5<br>continue inner<br>i= 6<br>continue inner<br>i= 7<br>continue outer<br>i= 8<br>break outer</p></blockquote><p><strong><em>break和continue本身只能中断最内层的循环</em></strong></p><h2 id="带标签的break以及continue语句在while循环中的用法："><a href="#带标签的break以及continue语句在while循环中的用法：" class="headerlink" title="带标签的break以及continue语句在while循环中的用法："></a>带标签的break以及continue语句在while循环中的用法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    outer:</span><br><span class="line">    while(true) &#123;</span><br><span class="line">    System.out.println(&quot;Outer while loop&quot;);</span><br><span class="line">    while(true) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    System.out.println(&quot;i= &quot;+i);</span><br><span class="line">    if(i==1) &#123;</span><br><span class="line">    System.out.println(&quot;continue&quot;);</span><br><span class="line">    continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==3) &#123;</span><br><span class="line">System.out.println(&quot;continue outer&quot;);</span><br><span class="line">continue outer;</span><br><span class="line">&#125;</span><br><span class="line">    if(i==5) &#123;</span><br><span class="line">System.out.println(&quot;break&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">    if(i==7) &#123;</span><br><span class="line">System.out.println(&quot;break outer&quot;);</span><br><span class="line">break outer;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Output:<br>Outer while loop<br>i= 1<br>continue<br>i= 2<br>i= 3<br>continue outer<br>Outer while loop<br>i= 4<br>i= 5<br>break<br>Outer while loop<br>i= 6<br>i= 7<br>break outer</p></blockquote><p>同样的规则亦适用于while:<br>1、一般的continue会退出最内层循环开头（顶部），并继续执行。<br>2、带标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。<br>3、一般的break会中断并跳出当前循环。<br>4、带标签的break会中断并跳出标签所指的循环。</p><h2 id="在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。"><a href="#在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。" class="headerlink" title="在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。"></a>在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想第四章练习</title>
      <link href="/2019/08/07/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/08/07/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Java编程思想第四章练习</p><a id="more"></a><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a>练习1：</h3><p>写一个程序，打印从1到100的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">for(int i=1;i&lt;=100;i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h3><p>写一个程序,产生25个int类型的随机数.对于每一个随机值,使用if-else语句来讲其分类为大于，小于,或等于紧随它产生的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int num[] =new int[25];</span><br><span class="line">        for (int i=0;i&lt;25;i++)&#123;</span><br><span class="line">            num[i]=(int)(Math.random()*100);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int j=0;j&lt;num.length-1;j++)&#123;//一共产生了25个数，需要比较24次，所以j的循环次数是num.length-1次。</span><br><span class="line">            if (num[j]&gt;num[j+1])&#123;</span><br><span class="line">                System.out.println(num[j]+&quot;大于&quot;+&quot;后面的数&quot;+num[j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (num[j]&lt;num[j+1])&#123;</span><br><span class="line">                System.out.println(num[j]+&quot;小于&quot;+&quot;后面的数&quot;+num[j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(num[j]+&quot;等于&quot;+&quot;后面的数&quot;+num[j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>39小于后面的数70<br>70大于后面的数30<br>30小于后面的数61<br>61大于后面的数57<br>57小于后面的数76<br>76小于后面的数83<br>83大于后面的数13<br>13大于后面的数3<br>3小于后面的数38<br>38小于后面的数60<br>60大于后面的数57<br>57小于后面的数75<br>75大于后面的数12<br>12小于后面的数52<br>52小于后面的数62<br>62小于后面的数84<br>84大于后面的数51<br>51大于后面的数18<br>18小于后面的数59<br>59小于后面的数64<br>64大于后面的数41<br>41小于后面的数98<br>98大于后面的数54<br>54大于后面的数51</p></blockquote><h3 id="练习4："><a href="#练习4：" class="headerlink" title="练习4："></a>练习4：</h3><p>写一个程序,使用两个嵌套的for循环和取余操作符来探测和打印素数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    boolean flog;</span><br><span class="line">    for(int i=2;i&lt;=100;i++) &#123;</span><br><span class="line">    flog=true;</span><br><span class="line">    for(int j=2;j&lt;i;j++) &#123;</span><br><span class="line">    if(i%j==0) &#123;</span><br><span class="line">    flog=false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flog==true) &#123;</span><br><span class="line">    System.out.println(i+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">5 </span><br><span class="line">7 </span><br><span class="line">11 </span><br><span class="line">13 </span><br><span class="line">17 </span><br><span class="line">19 </span><br><span class="line">23 </span><br><span class="line">29 </span><br><span class="line">31 </span><br><span class="line">37 </span><br><span class="line">41 </span><br><span class="line">43 </span><br><span class="line">47 </span><br><span class="line">53 </span><br><span class="line">59 </span><br><span class="line">61 </span><br><span class="line">67 </span><br><span class="line">71 </span><br><span class="line">73 </span><br><span class="line">79 </span><br><span class="line">83 </span><br><span class="line">89 </span><br><span class="line">97</span><br></pre></td></tr></table></figure><h3 id="练习5："><a href="#练习5：" class="headerlink" title="练习5："></a>练习5：</h3><p>重复第三章中的练习10，不要用Integer.toBinaryString()方法，而是用三元操作符和按位操作符来显示二进制0和1. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emmmmmmmmmm</span><br></pre></td></tr></table></figure><h2 id="练习7："><a href="#练习7：" class="headerlink" title="练习7："></a>练习7：</h2><p>修改本章练习1，通过使用break关键词（或者return关键词），使其只输出范围为1~99的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    for(int i=0;i&lt;100;i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    if(i==99)</span><br><span class="line">    break; //return</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thinking in Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中break和continue的区别</title>
      <link href="/2019/08/07/Java%E4%B8%ADbreak%E5%92%8Ccontinue%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/07/Java%E4%B8%ADbreak%E5%92%8Ccontinue%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Java中break和continue的区别</p><a id="more"></a><h2 id="在任何迭代语句的主体部分，都可用break和continue控制循环的流程"><a href="#在任何迭代语句的主体部分，都可用break和continue控制循环的流程" class="headerlink" title="在任何迭代语句的主体部分，都可用break和continue控制循环的流程"></a>在任何迭代语句的主体部分，都可用break和continue控制循环的流程</h2><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>1、break用于强行退出循环。<br>2、退出后不执行循环中剩余的语句</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>1、停止执行当前的迭代<br>2、退回循环起始处，开始下一次迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    for(int i=0;i&lt;=5;i++) &#123;</span><br><span class="line">    if(i==3) &#123;</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;===============&quot;);</span><br><span class="line">    for(int i=0;i&lt;=5;i++) &#123;</span><br><span class="line">    if(i==3) &#123;</span><br><span class="line">    continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>0<br>1<br>2<br>分隔符<br>0<br>1<br>2<br>4<br>5</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> break </tag>
            
            <tag> continue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Foreach语句</title>
      <link href="/2019/08/07/Foreach%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/08/07/Foreach%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>Foreach语句</p><a id="more"></a><h2 id="java-SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。"><a href="#java-SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。" class="headerlink" title="java SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。"></a>java SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class ForEachFloat&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Random rand = new Random(47);</span><br><span class="line">        float f[] = new float[10];</span><br><span class="line">        for(int i = 0;i &lt; 10;i++)</span><br><span class="line">            f[i]=rand.nextFloat();</span><br><span class="line">        for(float x:f)</span><br><span class="line">            System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>0.72711575<br>0.39982635<br>0.5309454<br>0.0534122<br>0.16020656<br>0.57799757<br>0.18847865<br>0.4170137<br>0.51660204<br>0.73734957</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ForEachFloat&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for(char c:&quot;An African Swallow&quot;.toCharArray())</span><br><span class="line">        System.out.print(c+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>A n   A f r i c a n   S w a l l o w </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Foreach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>截尾和舍入</title>
      <link href="/2019/08/05/%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5/"/>
      <url>/2019/08/05/%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>在执行窄化转换时，必须注意截尾与舍入问题。例如：如果将一个浮点值转换整形值，Java会如何处理？</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CastingNumbers &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">double above = 0.7,below = 0.4;</span><br><span class="line">float fabove = 0.7f,fbelow = 0.4f;</span><br><span class="line">System.out.println(&quot;(int)above: &quot;+(int)above);</span><br><span class="line">System.out.println(&quot;(int)below: &quot;+(int)below);</span><br><span class="line">System.out.println(&quot;(int)fabove: &quot;+(int)fabove);</span><br><span class="line">System.out.println(&quot;(int)fbelow: &quot;+(int)fbelow);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>(int)above: 0<br>(int)below: 0<br>(int)fabove: 0<br>(int)fbelow: 0</p></blockquote><p><strong>运行结果发现，在将float和double转型为整数值时，总是对该数字执行截尾。如果想要得到舍入的结果，就需要使用java.lang.Math中的round()方法。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CastingNumbers &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">double above = 0.7,below = 0.4;</span><br><span class="line">float fabove = 0.7f,fbelow = 0.4f;</span><br><span class="line">System.out.println(&quot;Math.round(above): &quot;+Math.round(above));</span><br><span class="line">System.out.println(&quot;Math.round(below): &quot;+Math.round(below));</span><br><span class="line">System.out.println(&quot;Math.round(fabove): &quot;+Math.round(fabove));</span><br><span class="line">System.out.println(&quot;Math.round(fbelow): &quot;+Math.round(fbelow));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果:<br>Math.round(above): 1<br>Math.round(below): 0<br>Math.round(fabove): 1<br>Math.round(fbelow): 0</p></blockquote><p><strong>由于round()是java.lang的一部分，因此在使用它时不需要额外地导入。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thinking in Java </tag>
            
            <tag> 数据类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>涉及按位操作的所有操作符（求二进制）</title>
      <link href="/2019/08/05/%E6%B6%89%E5%8F%8A%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%89/"/>
      <url>/2019/08/05/%E6%B6%89%E5%8F%8A%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>涉及按位操作的所有操作符（求二进制）</p><a id="more"></a><p>代码以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class BitManipulation&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Random rand = new Random(47);</span><br><span class="line">int i = rand.nextInt();</span><br><span class="line">int j = rand.nextInt();</span><br><span class="line">printBinaryInt(&quot;-1&quot;,-1);</span><br><span class="line">printBinaryInt(&quot;+1&quot;,+1);</span><br><span class="line">int maxpos = 2147483647;</span><br><span class="line">printBinaryInt(&quot;maxpos&quot;,maxpos);</span><br><span class="line">int maxneg = -2147483648;</span><br><span class="line">printBinaryInt(&quot;maxpos&quot;,maxneg);</span><br><span class="line">printBinaryInt(&quot;i&quot;,i);</span><br><span class="line">printBinaryInt(&quot;~i&quot;,~i);</span><br><span class="line">printBinaryInt(&quot;-i&quot;,-i);</span><br><span class="line">printBinaryInt(&quot;j&quot;,j);</span><br><span class="line">printBinaryInt(&quot;i&amp;j&quot;,i&amp;j);</span><br><span class="line">printBinaryInt(&quot;i|j&quot;,i|j);</span><br><span class="line">printBinaryInt(&quot;i^j&quot;,i^j); //不同为1，相同为0</span><br><span class="line">printBinaryInt(&quot;i&lt;&lt;5&quot;,i&lt;&lt;5);</span><br><span class="line">printBinaryInt(&quot;i&gt;&gt;5&quot;,i&gt;&gt;5);</span><br><span class="line">printBinaryInt(&quot;(~i)&gt;&gt;5&quot;,(~i)&gt;&gt;5);</span><br><span class="line">printBinaryInt(&quot;i&gt;&gt;&gt;5&quot;,i&gt;&gt;&gt;5);</span><br><span class="line">printBinaryInt(&quot;(~i)&gt;&gt;&gt;5&quot;,(~i)&gt;&gt;&gt;5);</span><br><span class="line"></span><br><span class="line">long l = rand.nextLong();</span><br><span class="line">long m = rand.nextLong();</span><br><span class="line">printBinaryLong(&quot;-1L&quot;,-1L);</span><br><span class="line">printBinaryLong(&quot;+1L&quot;,+1L);</span><br><span class="line">long ll = 9223372036854775807L;</span><br><span class="line">printBinaryLong(&quot;maxpos&quot;,ll);</span><br><span class="line">long lln = -9223372036854775808L;</span><br><span class="line">printBinaryLong(&quot;maxneg&quot;,lln);</span><br><span class="line">printBinaryLong(&quot;l&quot;,l);</span><br><span class="line">printBinaryLong(&quot;~l&quot;,~l);</span><br><span class="line">printBinaryLong(&quot;-l&quot;,-l);</span><br><span class="line">printBinaryLong(&quot;m&quot;,m);</span><br><span class="line">printBinaryLong(&quot;l&amp;m&quot;,l&amp;m);</span><br><span class="line">printBinaryLong(&quot;l|m&quot;,l|m);</span><br><span class="line">printBinaryLong(&quot;l^m&quot;,l^m);</span><br><span class="line">printBinaryLong(&quot;l&lt;&lt;5&quot;,l&lt;&lt;5);</span><br><span class="line">printBinaryLong(&quot;l&gt;&gt;5&quot;,l&gt;&gt;5);</span><br><span class="line">printBinaryLong(&quot;(~l)&gt;&gt;5&quot;,(~l)&gt;&gt;5);</span><br><span class="line">printBinaryLong(&quot;l&gt;&gt;&gt;5&quot;,l&gt;&gt;&gt;5);</span><br><span class="line">printBinaryLong(&quot;(~l)&gt;&gt;&gt;5&quot;,(~l)&gt;&gt;&gt;5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void printBinaryInt(String s, int i) &#123;</span><br><span class="line">System.out.println(s+&quot;,int: &quot;+i+&quot;.binary:\n &quot;+Integer.toBinaryString(i));</span><br><span class="line">&#125;</span><br><span class="line">static void printBinaryLong(String s, long l) &#123;</span><br><span class="line">System.out.println(s+&quot;,long: &quot;+l+&quot;.binary:\n &quot;+Long.toBinaryString(l));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行及结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">-1,int: -1.binary:</span><br><span class="line"> 11111111111111111111111111111111</span><br><span class="line">+1,int: 1.binary:</span><br><span class="line"> 1</span><br><span class="line">maxpos,int: 2147483647.binary:</span><br><span class="line"> 1111111111111111111111111111111</span><br><span class="line">maxpos,int: -2147483648.binary:</span><br><span class="line"> 10000000000000000000000000000000</span><br><span class="line">i,int: -1172028779.binary:</span><br><span class="line"> 10111010001001000100001010010101</span><br><span class="line">~i,int: 1172028778.binary:</span><br><span class="line"> 1000101110110111011110101101010</span><br><span class="line">-i,int: 1172028779.binary:</span><br><span class="line"> 1000101110110111011110101101011</span><br><span class="line">j,int: 1717241110.binary:</span><br><span class="line"> 1100110010110110000010100010110</span><br><span class="line">i&amp;j,int: 570425364.binary:</span><br><span class="line"> 100010000000000000000000010100</span><br><span class="line">i|j,int: -25213033.binary:</span><br><span class="line"> 11111110011111110100011110010111</span><br><span class="line">i^j,int: -595638397.binary:</span><br><span class="line"> 11011100011111110100011110000011</span><br><span class="line">i&lt;&lt;5,int: 1149784736.binary:</span><br><span class="line"> 1000100100010000101001010100000</span><br><span class="line">i&gt;&gt;5,int: -36625900.binary:</span><br><span class="line"> 11111101110100010010001000010100</span><br><span class="line">(~i)&gt;&gt;5,int: 36625899.binary:</span><br><span class="line"> 10001011101101110111101011</span><br><span class="line">i&gt;&gt;&gt;5,int: 97591828.binary:</span><br><span class="line"> 101110100010010001000010100</span><br><span class="line">(~i)&gt;&gt;&gt;5,int: 36625899.binary:</span><br><span class="line"> 10001011101101110111101011</span><br><span class="line">-1L,long: -1.binary:</span><br><span class="line"> 1111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">+1L,long: 1.binary:</span><br><span class="line"> 1</span><br><span class="line">maxpos,long: 9223372036854775807.binary:</span><br><span class="line"> 111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">maxneg,long: -9223372036854775808.binary:</span><br><span class="line"> 1000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">l,long: -8652529054300476342.binary:</span><br><span class="line"> 1000011111101100000010101010101100001101101011000110110001001010</span><br><span class="line">~l,long: 8652529054300476341.binary:</span><br><span class="line"> 111100000010011111101010101010011110010010100111001001110110101</span><br><span class="line">-l,long: 8652529054300476342.binary:</span><br><span class="line"> 111100000010011111101010101010011110010010100111001001110110110</span><br><span class="line">m,long: 2955289354441303771.binary:</span><br><span class="line"> 10100100000011010011000000001010010011111101111010011011011011</span><br><span class="line">l&amp;m,long: 72066398748419146.binary:</span><br><span class="line"> 100000000000010000000001000000001101001000010010001001010</span><br><span class="line">l|m,long: -5769306098607591717.binary:</span><br><span class="line"> 1010111111101111010011101010101110011111111111111110111011011011</span><br><span class="line">l^m,long: -5841372497356010863.binary:</span><br><span class="line"> 1010111011101111010001101010100110011110010110111100101010010001</span><br><span class="line">l&lt;&lt;5,long: -179768631971968704.binary:</span><br><span class="line"> 1111110110000001010101010110000110110101100011011000100101000000</span><br><span class="line">l&gt;&gt;5,long: -270391532946889886.binary:</span><br><span class="line"> 1111110000111111011000000101010101011000011011010110001101100010</span><br><span class="line">(~l)&gt;&gt;5,long: 270391532946889885.binary:</span><br><span class="line"> 1111000000100111111010101010100111100100101001110010011101</span><br><span class="line">l&gt;&gt;&gt;5,long: 306069219356533602.binary:</span><br><span class="line"> 10000111111011000000101010101011000011011010110001101100010</span><br><span class="line">(~l)&gt;&gt;&gt;5,long: 270391532946889885.binary:</span><br><span class="line"> 1111000000100111111010101010100111100100101001110010011101</span><br></pre></td></tr></table></figure><p><strong>注意高位表示符号：0为正，1为负。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 移位操作符 </tag>
            
            <tag> 二进制 </tag>
            
            <tag> 按位操作符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制转十进制快速方法</title>
      <link href="/2019/08/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>转自 <a href="https://blog.csdn.net/xy2204/article/details/50522075" target="_blank" rel="noopener">https://blog.csdn.net/xy2204/article/details/50522075</a></p><p>如果你是搞网络的，我觉得你一定要记住以下几种二进制数的转换值。你是一个网络工程 师，当看到一串二进制数时，你不要告诉我你会拿出笔纸或掰手指算半天才知道它转化成十进制的数值。要想快，那就记下下面几种常见的二进制–十进制转换：</p><a id="more"></a> <p>以8位 来演示:</p><p>1.第一种:</p><p>   00000001      1</p><p>   00000010      2</p><p>   00000100      4</p><p>   00001000      8</p><p>   00010000      16</p><p>   00100000      32</p><p>   01000000      64</p><p>   10000000      128</p><p>2.第二种：</p><p>  00000001      1</p><p>  00000011      3</p><p>  00000111      7</p><p>  00001111      15</p><p>  00011111      31</p><p>  00111111      63</p><p>  01111111      127</p><p>3.第三种：</p><p>  10000000     128</p><p>  11000000     192</p><p>  11100000     224</p><p>  11110000     240</p><p>  11111000     248</p><p>  11111100     252</p><p>  11111110     254</p><p>举个例子：  11101011     </p><pre><code>可分为：11100000（上面第三种类型）   22400001000（上面第一种类型）   800000011（上面第二种类型）   3</code></pre><p>我们通过记住上面三种类型的转换，再用加 法（加法口算你会吧）立即得到结果：235</p><p>==================================================================================</p><p>方法二：</p><p>熟记以下排列，其实很Easy了，从右往 左，依次是前一个数的2倍：</p><p>256      128      64       32      16      8        4         2         1</p><p>随便写个数字比如48</p><p>48 = 32 + 16,所以在32 和 16所在的位置为1，其余为0，</p><p>转为2进制就是</p><p>256  128  64  32  16  8   4   2   1</p><p>0      0       0    1    1   0   0   0   0</p><p>二进制转十进制就更简单了，</p><p>比如随便写的一串 01111101</p><p>先写上 ：  0         1           1         1         1         1          0          1</p><p>然后填充 128      64        32       16        8          4          2          1</p><p>十进制为 64+32+16+8+4+1=125</p><p>转载地址：<a href="http://blog.163.com/kongdelu2009@yeah/blog/static/111995207201037105051259/" target="_blank" rel="noopener">http://blog.163.com/kongdelu2009@yeah/blog/static/111995207201037105051259/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 二进制 </tag>
            
            <tag> 十进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java移位操作符</title>
      <link href="/2019/08/04/Java%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2019/08/04/Java%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>Java移位操作符</p><a id="more"></a><h3 id="移位运算符和按位运算符一样，同属于位运算符，因此移位运算符的位指的也是二进制位。它包括以下几种："><a href="#移位运算符和按位运算符一样，同属于位运算符，因此移位运算符的位指的也是二进制位。它包括以下几种：" class="headerlink" title="移位运算符和按位运算符一样，同属于位运算符，因此移位运算符的位指的也是二进制位。它包括以下几种："></a>移位运算符和按位运算符一样，同属于位运算符，因此移位运算符的位指的也是二进制位。它包括以下几种：</h3><p>1.左移位（&lt;&lt;）：将操作符左侧的操作数向左移动操作符右侧指定的位数。移动的规则是在二进制的低位补0。</p><p>2.有符号右移位（&gt;&gt;）：将操作符左侧的操作数向右移动操作符右侧指定的位数。移动的规则是，如果被操作数的符号为正，则在二进制的高位补0；如果被操作数的符号为负，则在二进制的高位补1。</p><p>3.无符号右移位（&gt;&gt;&gt;）：将操作符左侧的操作数向右移动操作符右侧指定的位数。移动的规则是，无论被操作数的符号是正是负，都在二进制位的高位补0。</p><h3 id="再来考虑一种情况，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，结果会是怎样呢？"><a href="#再来考虑一种情况，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，结果会是怎样呢？" class="headerlink" title="再来考虑一种情况，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，结果会是怎样呢？"></a>再来考虑一种情况，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，结果会是怎样呢？</h3><p>1、byte、short、char在做移位运算之前，会被自动转换为int类型，然后再进行运算。</p><p>2、byte、short、int、char类型的数据经过移位运算后结果都为int型。</p><p>3、long经过移位运算后结果为long型。</p><p>4、在左移位（&lt;&lt;）运算时，如果要移位的位数大于被操作数对应数据类型所能表示的最大位数，那么先将要求移位数对该类型所能表示的最大位数求余后，再将被操作数移位所得余数对应的数值，效果不变。比如1&lt;&lt;35=1&lt;&lt;(35%32)=1&lt;&lt;3=8。</p><p>5、对于有符号右移位（&gt;&gt;）运算和无符号右移位（&gt;&gt;&gt;）运算，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，那么先将要求移位数对该类型所能表示的最大位数求余后，再将被操作数移位所得余数对应的数值，效果不变。。比如100&gt;&gt;35=100&gt;&gt;(35%32)=100&gt;&gt;3=12。</p><h3 id="在编程思想中有这么一句话：”移位“可与”等号“（-lt-lt-或-gt-gt-或-gt-gt-gt-）组合使用"><a href="#在编程思想中有这么一句话：”移位“可与”等号“（-lt-lt-或-gt-gt-或-gt-gt-gt-）组合使用" class="headerlink" title="在编程思想中有这么一句话：”移位“可与”等号“（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）组合使用"></a>在编程思想中有这么一句话：”移位“可与”等号“（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）组合使用</h3><p>但是在进行这样的移位赋值操作时，可能会遇到一个问题：如果byte或short值进行这样的移位运算，得到的可能不是正确的结果。</p><p>它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int i = -1;</span><br><span class="line">System.out.println(Integer.toBinaryString(i));</span><br><span class="line">i &gt;&gt;&gt;=10;</span><br><span class="line">System.out.println(Integer.toBinaryString(i));</span><br><span class="line">long l = -1;</span><br><span class="line">System.out.println(Long.toBinaryString(l));</span><br><span class="line">l &gt;&gt;&gt;= 10;</span><br><span class="line">System.out.println(Long.toBinaryString(l));</span><br><span class="line">short s = -1;</span><br><span class="line">System.out.println(Integer.toBinaryString(s));</span><br><span class="line">s &gt;&gt;&gt;= 10;</span><br><span class="line">System.out.println(Integer.toBinaryString(s));</span><br><span class="line">byte b = -1;</span><br><span class="line">System.out.println(Integer.toBinaryString(b));</span><br><span class="line">b &gt;&gt;&gt;= 10;</span><br><span class="line">System.out.println(Integer.toBinaryString(b));</span><br><span class="line">b = -1;</span><br><span class="line">System.out.println(Integer.toBinaryString(b));</span><br><span class="line">System.out.println(Integer.toBinaryString(b&gt;&gt;&gt;10));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>11111111111111111111111111111111<br>1111111111111111111111<br>1111111111111111111111111111111111111111111111111111111111111111<br>111111111111111111111111111111111111111111111111111111<br>11111111111111111111111111111111<br>11111111111111111111111111111111<br>11111111111111111111111111111111<br>11111111111111111111111111111111<br>11111111111111111111111111111111<br>1111111111111111111111</p></blockquote><p>运行会发现s&gt;&gt;&gt;=10和b&gt;&gt;&gt;=10的输出结果是错误的。<br>而没有赋值的b&gt;&gt;&gt;=10的输出正确。</p><h3 id="内容转载于-http-blog-sina-com-cn-s-blog-6ca0f5eb0102vlha-html"><a href="#内容转载于-http-blog-sina-com-cn-s-blog-6ca0f5eb0102vlha-html" class="headerlink" title="内容转载于 http://blog.sina.com.cn/s/blog_6ca0f5eb0102vlha.html"></a>内容转载于 <a href="http://blog.sina.com.cn/s/blog_6ca0f5eb0102vlha.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6ca0f5eb0102vlha.html</a></h3><p>晚上纠结了很久这个问题，不懂为什么低5位才有用，怎么就2^5等于32位，跟int的32位挂上钩了，思考了很久终于明白了。</p><p>这段话有两个出处，一个是Java编程思想3.11移位操作符中出现，原话是“只有数值右端的低5位才有用”。一个是Java解惑中谜题27：变幻莫测的i值，原话是“移位操作符只使用其右操作数的低5位作为移位长度”。</p><p>弄清这句话首先需要弄清楚移位操作符，移位操作符是一个二元操作符，两个操作数分别位于移位操作两边形如：左操作数 移位操作符 右操作数 这样的结构，其含义是，将左操作数按照移位操作符指定的移位方向，进行右操作数指定的次数的移位。然后对照出处二，Java解惑中所描述的，就豁然开朗了。</p><p>首先，移位操作符能操作的数只有int类型和long类型，这个是指左操作数的类型。对于int类型而言，int在Java中占4字节，一共32位，也就是说，对于一个在Java中的int数据，做32次移位，那么这个int数据就完全变了，以左移为例，左移是补0，那么对于任意一个int类型数据，做32次移位，那么int数据变成32位全0的数据，Java不允许一次性移位左操作数的所有位，也就是右操作数不能大于32。于是回到上述的句子，其指的是右操作数的低5位，5位二进制所代表的最大值为2^5-1，为31，所以取右操作数的低5位，就是只看右操作数的二进制的低5位，其数值不会超过2^5次方，也就是int的32位。因此，移位操作符进行移位的实际次数，其实是右操作数2的次数。</p><p>对于Java编程思想中的翻译，“只有数值右端的低5位才有用”，真是莫名其妙了。其英语原文为：Only the five low-order bits of the right-hand side will be used.看到英文原文，可就明白了这句话的意思，鉴于现在的英译中的书籍参差不齐，建议阅读的时候配一本英文版的电子书在手边以备不时之需。</p><p>简而言之，移位操作符执行的次数，只取右操作数的低5位（其数值不会大于2^5=32，也就是移位次数不会超过32位，因为32位是int型的位数）作为移位的次数。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thinking in Java </tag>
            
            <tag> 移位操作符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Integer和int的区别</title>
      <link href="/2019/08/04/Integer%E5%92%8Cint%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/04/Integer%E5%92%8Cint%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Integer和int的区别</p><a id="more"></a><p>内容转载于 <a href="https://www.cnblogs.com/guodongdidi/p/6953217.html" target="_blank" rel="noopener">https://www.cnblogs.com/guodongdidi/p/6953217.html</a></p><ol><li>Integer是int的包装类，int则是java的一种基本数据类型</li><li>Integer变量必需实例化后才能使用，而int变量不需要</li><li>Integer实际是对象的引用，当new一个integer时，实际上是生成一个指针指向对象；而int则是直接存储数据值</li><li>Integer的默认值是null，int的默认值是0</li></ol><p>延伸：<br>关于Integer和int的比较<br>1.由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><blockquote><p>Integer i = new Integer(100);<br>Integer j = new Integer(100);<br>System.out.print(i == j); //false</p></blockquote><p>2.Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><blockquote><p>Integer i = new Integer(100);<br>int j = 100;<br>System.out.print(i == j); //true</p></blockquote><p>3.非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><blockquote><p>Integer i = new Integer(100);<br>Integer j = 100;<br>System.out.print(i == j); //false</p></blockquote><p>4.对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><blockquote><p>Integer i = 100;<br>Integer j = 100;<br>System.out.print(i == j); //true</p></blockquote><blockquote><p>Integer i = 128;<br>Integer j = 128;<br>System.out.print(i == j); //false</p></blockquote><p>对于第4条的原因：<br>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的<br>定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= &gt;IntegerCache.high)&#123;</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Integer </tag>
            
            <tag> int </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负数的二进制表示</title>
      <link href="/2019/08/04/%E8%B4%9F%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/"/>
      <url>/2019/08/04/%E8%B4%9F%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>了解负数的二进制表示</p><a id="more"></a><p>计算机中，负数以其正值的补码形式表示</p><p>比如2的二进制为10，但int类型的数占用4字节（32位），就写为00000000 00000000 00000000 00000010</p><p>求-2的二进制就要求出原码、补码、反码</p><p>原码：将整数的绝对值大小转换为二进制，称为原码。</p><blockquote><p>00000000 00000000 00000000 00000010</p></blockquote><p>反码：将原码按位取反，所得为反码。（1变0，0变1）。</p><blockquote><p>11111111 11111111 11111111 11111101</p></blockquote><p>补码：反码加1为补码。</p><blockquote><p>11111111 11111111 11111111 11111110</p></blockquote><p>-2的二进制为11111111 11111111 11111111 11111110</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java短路与</title>
      <link href="/2019/08/04/Java%E7%9F%AD%E8%B7%AF%E4%B8%8E/"/>
      <url>/2019/08/04/Java%E7%9F%AD%E8%B7%AF%E4%B8%8E/</url>
      
        <content type="html"><![CDATA[<p>Java短路与</p><a id="more"></a><h2 id="Java中使用逻辑操作符时遇到的短路现象"><a href="#Java中使用逻辑操作符时遇到的短路现象" class="headerlink" title="Java中使用逻辑操作符时遇到的短路现象"></a>Java中使用逻辑操作符时遇到的短路现象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// &amp;&amp;短路与</span><br><span class="line"></span><br><span class="line">public class ShortCircuit&#123;</span><br><span class="line">static boolean test1(int val) &#123;</span><br><span class="line">System.out.println(&quot;test(&quot;+val+&quot;)&quot;);</span><br><span class="line">System.out.println(&quot;result: &quot;+(val&lt;1));</span><br><span class="line">return val&lt;1;</span><br><span class="line">&#125;</span><br><span class="line">static boolean test2(int val) &#123;</span><br><span class="line">System.out.println(&quot;test(&quot;+val+&quot;)&quot;);</span><br><span class="line">System.out.println(&quot;result: &quot;+(val&lt;2));</span><br><span class="line">return val&lt;2;</span><br><span class="line">&#125;</span><br><span class="line">static boolean test3(int val) &#123;</span><br><span class="line">System.out.println(&quot;test(&quot;+val+&quot;)&quot;);</span><br><span class="line">System.out.println(&quot;result: &quot;+(val&lt;3));</span><br><span class="line">return val&lt;3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">boolean b=test1(0)&amp;&amp;test2(2)&amp;&amp;test3(2);</span><br><span class="line">System.out.println(&quot;expression is &quot;+b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>test(0)<br>result: true<br>test(2)<br>result: false<br>expression is false</p></blockquote><p>可以发现test1与test2比较后直接输出，不会对test3进行比较，这就是&amp;和&amp;&amp;的不同之处。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想第三章练习</title>
      <link href="/2019/08/04/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/08/04/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Java编程思想第三章练习</p><a id="more"></a><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="练习5："><a href="#练习5：" class="headerlink" title="练习5："></a>练习5：</h3><p>创建一个名为Dogde类，它包含两个String域：name和scruffy（它的叫声为“Ruff!”）,另一个名为scruffy（它的叫声为“Wurf！”）。然后显示它们的名字和叫声。<br>练习6：<br>创建一个新的Dog索引，并对其赋值为spot对象。测试用==和equals()方法比较所有引用的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">String name;</span><br><span class="line">String says;</span><br><span class="line"></span><br><span class="line">void shows() &#123;</span><br><span class="line">System.out.println(&quot;name: &quot;+name+&quot; Says: &quot;+says);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Dog spot = new Dog();</span><br><span class="line">spot.name=&quot;Spot&quot;;</span><br><span class="line">spot.says=&quot;Ruff!&quot;;</span><br><span class="line">Dog scruffy = new Dog();</span><br><span class="line">scruffy.name=&quot;Sruffy&quot;;</span><br><span class="line">scruffy.says=&quot;Wufrf!&quot;;</span><br><span class="line"></span><br><span class="line">spot.shows();</span><br><span class="line">scruffy.shows();</span><br><span class="line"></span><br><span class="line">Dog newDog = new Dog();</span><br><span class="line">newDog = spot;</span><br><span class="line">System.out.println(newDog==spot);</span><br><span class="line">System.out.println(newDog.equals(spot));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>name: Spot Says: Ruff!<br>name: Sruffy Says: Wufrf!<br>true<br>true</p></blockquote><h3 id="练习7："><a href="#练习7：" class="headerlink" title="练习7："></a>练习7：</h3><p>编写一个程序，模拟扔硬币的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">class Coin&#123;</span><br><span class="line">static void test() &#123;</span><br><span class="line">Random r = new Random();</span><br><span class="line">System.out.println(r.nextInt(2) == 1?&quot;正面&quot;:&quot;反面&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Coin.test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习8："><a href="#练习8：" class="headerlink" title="练习8："></a>练习8：</h3><p>展示用16进制和8进制记数法（字面值）来操作long值（赋值），用Long.toBinaryString()来显示其结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">long l1=0xC2B;</span><br><span class="line">long l2=0777;</span><br><span class="line">System.out.println(Long.toBinaryString(l1));</span><br><span class="line">System.out.println(Long.toBinaryString(l2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习9："><a href="#练习9：" class="headerlink" title="练习9："></a>练习9：</h3><p>分别显示用float和double指数计数法所能表示的最大和最小的数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">float floatmax = Float.MAX_VALUE;</span><br><span class="line">float floatmin = Float.MIN_VALUE;</span><br><span class="line">double doublemax = Double.MAX_VALUE;</span><br><span class="line">double doublemin = Double.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;floatmax = &quot; + floatmax);</span><br><span class="line">System.out.println(&quot;floatmin = &quot; + floatmin);</span><br><span class="line">System.out.println(&quot;doublemax = &quot; + doublemax);</span><br><span class="line">System.out.println(&quot;doublemin = &quot; + doublemin);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>floatmax = 3.4028235E38<br>floatmin = 1.4E-45<br>doublemax = 1.7976931348623157E308<br>doublemin = 4.9E-324</p></blockquote><h3 id="练习10："><a href="#练习10：" class="headerlink" title="练习10："></a>练习10：</h3><p>编写一个具有两个常量值的程序,一个具有交替的二进制位1和0,其中最低有效位为0,另一个也具有交替的二进制位1和0,其中最低有效位为1.取这两个值,用按位操作符以所有可能的方式结合运算它们,然后用Integer.toBinaryString()显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 0xaaaaaaaa;</span><br><span class="line">int b = 0x55555555;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;  a: &quot;+Integer.toBinaryString(a));</span><br><span class="line">System.out.println(&quot;  b: &quot;+Integer.toBinaryString(b));</span><br><span class="line">System.out.println(&quot; ~a: &quot;+Integer.toBinaryString(~a));</span><br><span class="line">System.out.println(&quot; ~b: &quot;+Integer.toBinaryString(~b));</span><br><span class="line">System.out.println(&quot;a&amp;a: &quot;+Integer.toBinaryString(a&amp;a));</span><br><span class="line">System.out.println(&quot;a|a: &quot;+Integer.toBinaryString(a|a));</span><br><span class="line">System.out.println(&quot;a^a: &quot;+Integer.toBinaryString(a^a));</span><br><span class="line">System.out.println(&quot;a&amp;b: &quot;+Integer.toBinaryString(a&amp;b));</span><br><span class="line">System.out.println(&quot;a|b: &quot;+Integer.toBinaryString(a|b));</span><br><span class="line">System.out.println(&quot;a^b: &quot;+Integer.toBinaryString(a^b));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br> a: 10101010101010101010101010101010<br> b: 1010101010101010101010101010101<br>~a: 1010101010101010101010101010101<br>~b: 10101010101010101010101010101010<br>a&amp;a: 10101010101010101010101010101010<br>a|a: 10101010101010101010101010101010<br>a^a: 0<br>a&amp;b: 0<br>a|b: 11111111111111111111111111111111<br>a^b: 11111111111111111111111111111111</p></blockquote><h3 id="练习11："><a href="#练习11：" class="headerlink" title="练习11："></a>练习11：</h3><p>以一个最高有效位为1的二进制数开始,用有符号右移操作符对其进行右移,直至所有的二进制位都被移出为止,每移一位都显示二进制字符串效果.<br>练习12：<br>以一个所有位都为1的二进制数字开始,先左移它,然后用无符号右移操作符对其进行右移,直至所有二进制位都移出为止,每移一位都要显示二进制字符串效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int number = 0xaaaaa;</span><br><span class="line">while(number != 0) &#123;</span><br><span class="line">number &gt;&gt;= 1;</span><br><span class="line">System.out.println(Integer.toBinaryString(number));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;====================&quot;);</span><br><span class="line"></span><br><span class="line">int number2 = 0xff;</span><br><span class="line">number2 &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">while(number2 != 0) &#123;</span><br><span class="line">number2 &gt;&gt;&gt;= 1;</span><br><span class="line">System.out.println(Integer.toBinaryString(number2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">运行及结果：</span><br><span class="line">1010101010101010101</span><br><span class="line">101010101010101010</span><br><span class="line">10101010101010101</span><br><span class="line">1010101010101010</span><br><span class="line">101010101010101</span><br><span class="line">10101010101010</span><br><span class="line">1010101010101</span><br><span class="line">101010101010</span><br><span class="line">10101010101</span><br><span class="line">1010101010</span><br><span class="line">101010101</span><br><span class="line">10101010</span><br><span class="line">1010101</span><br><span class="line">101010</span><br><span class="line">10101</span><br><span class="line">1010</span><br><span class="line">101</span><br><span class="line">10</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">====================</span><br><span class="line">11111111</span><br><span class="line">1111111</span><br><span class="line">111111</span><br><span class="line">11111</span><br><span class="line">1111</span><br><span class="line">111</span><br><span class="line">11</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="练习13："><a href="#练习13：" class="headerlink" title="练习13："></a>练习13：</h3><p>编写一个方法,它以二进制形式显示char类型的值.使用多个不同的字符来展示它.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TestChar&#123;</span><br><span class="line">static void Conversion(char c) &#123;</span><br><span class="line">System.out.println(Integer.toBinaryString((int)c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">TestChar.Conversion(&apos;a&apos;);</span><br><span class="line">TestChar.Conversion(&apos;b&apos;);</span><br><span class="line">TestChar.Conversion(&apos;c&apos;);</span><br><span class="line">TestChar.Conversion(&apos;$&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>1100001<br>1100010<br>1100011<br>100100</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thinking in Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中对象的赋值</title>
      <link href="/2019/08/03/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC/"/>
      <url>/2019/08/03/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>记录以下学习Java对象赋值中出现的问题</p><a id="more"></a><p>在java中赋值使用操作符“=”。意思是“取右边的值，把它赋值给左边”。右值可以是任何常数、变量或者表达式（只要能生成一个值）。但左边必须是一个明确的、已命名的变量。<br>但是不能把任何东西赋值给一个常数，常数不能作为左值（比如不能4=a;）。<br>基本数据类型的赋值是直接将一个地方的内容复制到了另一个地方。例如，a=b,b的内容复制给a。接着又修改了a，而b并不会受a修改的影响。</p><p>但在为对象赋值的时候，情况却不一样。<br>对一个对象进行操作时，我们真正操作的是对对象的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Tank&#123;</span><br><span class="line">int level;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] arg) &#123;</span><br><span class="line">Tank t1 = new Tank();</span><br><span class="line">Tank t2 = new Tank();</span><br><span class="line">t1.level = 9;</span><br><span class="line">t2.level = 47;</span><br><span class="line">System.out.println(&quot;1: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level);</span><br><span class="line">t1 = t2;</span><br><span class="line">System.out.println(&quot;2: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level);</span><br><span class="line">t1.level = 27;</span><br><span class="line">System.out.println(&quot;3: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;/*Output:</span><br><span class="line">1: t1.level: 9,t2.level: 47</span><br><span class="line">2: t1.level: 47,t2.level: 47</span><br><span class="line">3: t1.level: 27,t2.level: 27</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>每个Tank类对象的level域都赋予了一个不同的值，然后，将t2赋给t1。<br>我们可能会期望t1和t2总是相互独立的。<br>但由于赋值操作的是一个对象的引用，t1和t2包含的引用相同,所以修改t1的同时也改变了t2。<br>这种特殊现象称为”别名现象“。</p><blockquote><p>避免方式：<br>t1.level = t2.level;</p></blockquote><hr><h2 id="方法调用中的别名问题"><a href="#方法调用中的别名问题" class="headerlink" title="方法调用中的别名问题"></a>方法调用中的别名问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Tank&#123;</span><br><span class="line">char c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">static void f(Tank y) &#123;</span><br><span class="line">y.c = &apos;z&apos;;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] arg) &#123;</span><br><span class="line">Tank t = new Tank();</span><br><span class="line">t.c = &apos;a&apos;;</span><br><span class="line">System.out.println(&quot;1: t.c: &quot; + t.c);</span><br><span class="line">f(t);</span><br><span class="line">System.out.println(&quot;2: t.c: &quot; + t.c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行及结果：<br>1: t.c: a<br>2: t.c: z</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 赋值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中局部变量的初始化问题</title>
      <link href="/2019/08/02/java%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/02/java%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>java中局部变量的初始化问题</p><a id="more"></a> <h2 id="Java中局部变量必须初始化但成员变量不必须初始化"><a href="#Java中局部变量必须初始化但成员变量不必须初始化" class="headerlink" title="Java中局部变量必须初始化但成员变量不必须初始化"></a>Java中局部变量必须初始化但成员变量不必须初始化</h2><p>其实无论成员变量还是局部变量都要初始化，只是JVM帮我们初始化了成员变量。</p><p>JVM在初始化对象时就可以初始化成员变量。</p><p>在类的加载中，我们定义的成员变量进行了两次初始化，一次赋默认初值（0值，boolean赋为false），一次赋自定义的初值。<br>而对于方法中的局部变量，需要进栈执行，这个过程是没有赋初值过程的。</p><p>还有种情况为：定义的局部变量没有赋值，也没有报错，是因为局部变量没有被调用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 局部变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据备份与还原</title>
      <link href="/2019/07/21/Mysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
      <url>/2019/07/21/Mysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<p>Mysql数据备份与还原</p><a id="more"></a><ul><li><h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2></li></ul><p>1.整库备份<br>    利用mysqldump进行sql备份<br>    语法：mysqldump.exe -hPup 数据库名字 &gt; 备份路径</p><pre><code>mysqldump.exe -hlocalhost -P3306 -uroot -proot mydatabase C:/server/mydatabase.sql</code></pre><p>2.单表备份<br>    语法：mysqldump.exe -hPup 数据库名字 表名 &gt; 备份路径</p><pre><code>mysqldump -uroot -proot mydatabase my_int &gt; c:/server/int.sql</code></pre><p>3.多表备份<br>    语法：mysqldump.exe -hPup 数据库名字 表名 表名 .. &gt; 备份路径</p><pre><code>mysqldump -uroot -proot mydatabase my_student my_int &gt; c:/server/student_int.sq</code></pre><ul><li><h2 id="数据还原"><a href="#数据还原" class="headerlink" title="数据还原"></a>数据还原</h2></li></ul><p>1.利用mysql.exe客户端<br>     在cmd中直接对数据还原<br>     语法：mysql -hPup 数据库 &lt; 文件路径</p><pre><code>mysql -uroot -proot mydatabse &lt; c:/server/mydatabase.sql</code></pre><p>2.利用sql指令<br>     登录mysql客户端并进入对应数据库<br>    语法：source 文件路径（注意后面会有； 因为这里是在mysql中输入的sql指令）</p><pre><code>source c:/server/int.sql;</code></pre><p>3.复制粘贴</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客文章添加图片、音乐、视频</title>
      <link href="/2019/07/19/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2019/07/19/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>博客文章添加图片、音乐、视频</p><a id="more"></a><h2 id="首先修改配置-config-yml"><a href="#首先修改配置-config-yml" class="headerlink" title="首先修改配置_config.yml"></a>首先修改配置_config.yml</h2><p> 将post_asset_folder: false改为post_asset_folder: true</p><h2 id="然后安装一个图片插件"><a href="#然后安装一个图片插件" class="headerlink" title="然后安装一个图片插件"></a>然后安装一个图片插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image -- save</span><br></pre></td></tr></table></figure><p>新建一个博文后就会发现在/source/_posts目录下会生成同名文件夹<br>将图片扔里面</p><h2 id="添加本地图片"><a href="#添加本地图片" class="headerlink" title="添加本地图片"></a>添加本地图片</h2><p> 在博文中插入代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](文件夹/h1.jpg)</span><br></pre></td></tr></table></figure><p>例:<br><img src="/2019/07/19/博客文章添加图片/s1.gif" alt="图片描述"></p><h2 id="添加外部连接"><a href="#添加外部连接" class="headerlink" title="添加外部连接"></a>添加外部连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片地址)</span><br></pre></td></tr></table></figure><p>例:<br><img src="https://tse3-mm.cn.bing.net/th?id=OIP.-KRAMGIepQ5rXOFgZPCPggHaHa&w=141&h=150&c=7&o=5&dpr=1.1&pid=1.7" alt="图片描述"></p><h2 id="插入音乐"><a href="#插入音乐" class="headerlink" title="插入音乐"></a>插入音乐</h2><p>直接粘贴代码到博文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 </span><br><span class="line">src=&quot;http://music.163.com/outchain/player?type=2&amp;id=5263408&amp;auto=0&amp;height=66&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><h2 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h2><p>直接粘贴代码到博文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line">height=300 width=510 </span><br><span class="line">src=&quot;视频链接&quot; </span><br><span class="line">frameborder=0 allowfullscreen&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2019/07/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/07/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>今天天气真好</p><a id="more"></a><p> 好就好在好个锤子</p><p> <img src="https://www.bing.com/th?id=OGC.56352ff9bbbcdc091caccbf25f224961&pid=1.7&rurl=http%3a%2f%2fwx4.sinaimg.cn%2fmw690%2f006HJgYYgy1fo3p3supnng308r08rnnc.gif&ehk=owCBmHH4kjoZ6jGhvNLrzA" alt="图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
