<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Sublime Text汉化教程]]></title>
    <url>%2F2019%2F09%2F13%2FSublime-Text%E6%B1%89%E5%8C%96%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[发现一款Sublime Text编辑器，界面非常简洁，官方简介“A sophisticated text editor forcode, markup and prose” 应用界面： 安装Sublime Text官网点击DOWNLOAD下载 汉化英文界面用着不习惯那就汉化，另外Sublime Text也支持很多语言 打开Sublime Text的控制台（Ctrl+~） 粘贴代码到控制台进入Package Control官方网站 打开后，将适用于您的Sublime Text版本的Python代码粘贴到控制台中。 可以直接粘贴下面的代码： SUBLIME TEST 3 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) SUBLIME TEST 2 1import urllib2,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 粘贴后回车 选择语言 稍微等一会就会出现中文界面 切换语言 Help-&gt;Language 参考 Sublime text如何汉化]]></content>
      <categories>
        <category>Sublime Test</category>
      </categories>
      <tags>
        <tag>汉化</tag>
        <tag>Sublime Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我要上班]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%88%91%E8%A6%81%E4%B8%8A%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[中秋节到了，又不能好好工作了。 什么！！三天小长假！！ No 没有工作的我该怎么活！！ 看来只能用电影音乐游戏苹果香蕉巧克力来减轻没有工作的痛苦了 、]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客next主题添加文章阅读量统计功能]]></title>
    <url>%2F2019%2F09%2F13%2FHexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[添加文章阅读量统计有很多方法，因为我已经注册了LeanCloud，所以就直接采用了LeanCloud。 注册LeanCloud 创建应用储存-&gt;数据-&gt;创建Class 创建名为Counter的class用来存储访问博客的数据，例如：访问次数，最新访问时间等信息。class类名必须为Counter，主要为了与next主题相兼容，否则无法接收到相关数据。为了避免后续因为权限的问题导致次数统计显示不正常，ACL权限选择无限制。 获取ID和Key设置-&gt;应用Key 会得到App ID和App Key 修改next主题配置文件打开_config.yml，搜索leancloud_visitors，更改为true，并添加id和key 保存文件 最后生成部署hexo博客 效果如图： 参考 Hexo博客next主题添加文章阅读量统计功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从多层嵌套类中访问外部类的成员]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%BB%8E%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[一个内部类被嵌套多少层并不重要—它能透明地访问所有它所嵌入地外围类的所有成员，如下所示： 1234567891011121314151617181920class MNA&#123; private void f() &#123;&#125; class A&#123; private void g() &#123;&#125; public class B&#123; void h() &#123; g(); f(); &#125; &#125; &#125;&#125;public class MultiNetingAccess&#123; public static void main(String[] args) &#123; MNA mna = new MNA(); MNA.A mnaa = mna.new A(); MNA.A.B mnaab = mnaa.new B(); mnaab.h(); &#125;&#125; 可以看到在MNA.A.B中，调用方法g()和f()不需要任何条件（即使它们被定义为private）。这个例子同时展示了如何从不同的类里创建多层嵌套类的内部类对象的基本语法。“.new”语法能产生正确的作用域，所以不必在调用构造器时限定类名。 内容取自《Java编程思想》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加Valine评论系统]]></title>
    <url>%2F2019%2F09%2F12%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Valine 诞生于2017年8月7日，是一款基于LeanCloud的快速、简洁且高效的无后端评论系统。 理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo、Ghost 等博客程序在使用Valine。 注册LeancloudLeancloud官网 创建应用创建应用，名字随便，然后进入设置-&gt;应用Key 会获得App ID和App Key 设置安全域名设置-&gt;安全中心-&gt;Web 安全域名 添加域名 配置主题文件打开next主题配置文件，找到Valine 添加App ID和App Key 保存 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 然后刷刷刷 添加成功 参考 为你的Hexo加上评论系统-Valine]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python命令下载视频]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%88%A9%E7%94%A8Python%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[Python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。 1、电脑需要安装Python3 2、window+r 打开cmd输入python来检查环境： python 3、输入下面的代码回车： pip3 install you-get 安装you-get，它是python3的一个下载工具 4、下载视频时可以选择文件路径 you-get -o F:\k 文件地址 默认下载到C盘 5、下载视频选择清晰度 you-get -i 文件地址 显示下载时会有多种：超清、高清、标清 然后我们下载想要下载的视频样式，比如下载高清的，高清的是：-format=mp4sd 那么我们在cmd中输入： you-get –format=mp4sd 视频地址 网站视频下载基本上都支持 下载国外视频需要科学上网]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在云服务器下部署Java Web项目]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E9%83%A8%E7%BD%B2Java-Web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[在服务器下手动部署Java Web项目 在云服务下部署Java的三种方法 Java镜像部署 一键安装包部署 手动部署 手动部署的准备Java jdk:Java jdk官方（下载“jdk-序号-linux-x64.tar.gz”版本） Tomcat：Tomcat官方下载链接（点击首页左侧Tomcat 8，下载“tar.gz (pgp, md5, sha1)”） 安装jdk1、打开Xshell和Xftp，用Xftp在云服务器创建文件夹 2、将jdk安装包和tomcat安装包复制粘贴到云服务器对应的文件夹下 3、在Xshell输入指令，解压jdk安装包到指定文件夹 #tar-zxvf jdk-版本编号-linux-x64.tar.gz-C/usr/java/jdk/ 4、解压完毕后jdk文件夹里会有对应文件，开始配置环境变量 #vi /etc/profileexport JAVA_HOME=/usr/java/jdk/jdk版本编号_121export JRE_HOME=/usr/java/jdk/jdk版本编号_121/jreexport CLASSPATH=.:$JAVA_HOME/lib$:JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin/$JAVA_HOME:$PATH 5、编辑完内容后，按下Esc键，并输入“:wq”，然后回车可以保存退出 6、保存完毕后输入下面指令 #source /etc/profile 7、验证是否成功 #java -version 安装Tomcat1、解压tomcat，解压指令如下： #tar -xvf apache-tomcat-版本编号.tar.gz -C /usr/java/tomcat/ 2、进入解压文件夹下的bin文件夹，指令如下： #cd/usr/java/tomcat/apache-tomcat-版本编号/bin/ 3、编辑setclasspath.sh 脚本，指令如下： #vi setclasspath.sh 4、添写如下内容： export JAVA_HOME=/usr/java/jdk/jdk版本编号export JRE_HOME=/usr/java/jdk/jdk版本编号/jre 5、保存编辑内容，按下Esc键，并输入“:wq”，然后回车可以保存退出。 6、启动tomcat，指令如下： #./startup.sh 7、jdk和tomcat都弄好了，接下来可以用浏览器访问我的云服务器吗？ 当然可以！你可以从浏览器访问，输入http://云服务器的ip:8080就能访问啦！ 部署项目将项目上传到 Tomcat文件夹下的 Webapps 文件夹里就行。上传好了后，浏览器访问即可。例如：http://云服务器ip地址:8080/index/one.html等。 怎么通过我的域名访问我的网站呢解析域名域名直接访问 参考 阿里云ECS建网站（建站）超详细全套完整图文教程！菜鸟必看！]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress建站]]></title>
    <url>%2F2019%2F09%2F11%2FWordPress%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[最近想让博客绑定域名，逛了阿里云，脑子一热又买了服务器，学生认证也挺优惠的，趁机会学习以下建站。因为个人没有基础，所以就从网上搜集教程，结合了多篇文章进行学习。 教程讲解了WordPress建站流程，从服务器配置、域名解析、宝塔面板、Wordpress建站、网站优化等操作讲解建站方法。 转自 https://blog.csdn.net/aliyunguide/article/details/86664703 前期准备 域名：实名认证 服务器：内存512M以上Linux服务器，推荐使用1G内存、Centos7系统。国内服务器需要备案才可以用 其他：Wordpress主题、插件等，免费或者付费都可以，免费的可以查看我们推荐的WordPress免费主题，付费的可以到Themeforest挑选 服务器LNMP环境搭建想要运行Wordpress网站程序，必须要有对应的软件，也就是服务器环境，比如我们常说的LNMP就是 Linux + Nginx + Mysql + PHP 环境，最常见的网站程序，Wordpress程序就是结合这些语言开发出来的。 其实环境里面安装LNMP是众所周知的，这里我要说的是软件的版本，服务器不同于虚拟主机，我们可以自主控制各种程序的参数和版本，这将让网站的配置非常灵活。为了wordpress兼容和性能，关于软件版本的选择有一个很好的标准就是wordpress官方推荐环境，官方的建议是PHP7.2版本及以上，Mysql5.6版本及以上，还有就是https，安装软件的的原则就是版本越接近推荐的越好 接下来就让我们从使用服务器命令开始，搭建Wordpress网站的LNMP环境 安装Xshell由于Windows是不能直接连接到Linux服务器的，需要一个SSH的软件，推荐使用Xshell作为远程连接软件，它对于个人和学校是免费使用的，可以在Xshell官网直接下载。 连接到服务器安装好了Xshell软件之后，就可以开始连接到服务器了，提前准备好服务器的IP、账号、密码 打开Xshell软件，选择文件 – 新建，添加一个连接 图1-1为连接成功 安装宝塔面板接下来我们在服务器安装宝塔面板，输入下面的命令并执行(最新宝塔面板需要在centos7系统用，其他系统的命令查看这里) yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh 安装中途会脚本询问是否将网站安装在www目录，直接选择y，然后确认即可，大概会需要几分钟的时间 安装成功后会出现图1-2的信息 最后得到了宝塔面板的登陆信息，将这些保存下来 宝塔面板为了提升安全，已将面板路径在之前的8888端口增加了随机入口，所以最好将登录信息长期保存，以后面板的管理都需要用到这些信息 安装网站环境使用刚刚获得到的信息，访问你的ip:8888，登陆宝塔面板，比如刚刚我的就是访问 http://45.76.48.16:8888，账号密码也就是刚刚安装完显示的 (注意：如果使用的是阿里云之类的云服务器提前开放安全端口) 首次登陆宝塔面板后台，会弹出一键安装环境，在这里我们需要耐心设置一遍 仔细看下图中的设置，安装环境主要有3个点 选择LNMP环境，节省资源 调整Mysql和PHP版本 安装方式选择为编译安装 最好是按照上图的配置安装，可能有朋友会问为什么不选择 PHP7.2，这里主要是考虑到各种主题和插件的最大兼容，如果选择PHP7.2的话可能会有一些奇怪的问题，当然如果后期主题和插件都兼容了也可以切换到7.2。还有一点就是如果服务器为512M内存要选择Mysql5.5，不然压力会很大 LNMP环境编译安装过程大概为半小时左右，视服务器性能而定 搭建Wordpress网站当服务器LNMP环境安装完成之后，我们就可以开始着手搭建Wordpress网站了，这里就是建站的主要步骤，用过虚拟主机的朋友应当非常熟悉 新建站点选择网站 – 添加站点，首先填入自己的域名，一般是 domain.com 和 www.domain.com 两种格式都要绑定，并创建FTP和数据库 创建完成后会在网站列表中显示，这里面的密码记不记无所谓，可以随时查看，后期还要通过这里进行网站管理 域名解析服务器已经绑定了域名，接下来就是添加解析了，其实就是添加2条A记录，非常简单，这里我用的是腾讯云域名，其他的服务商可能稍微有些不同 登陆控制台，选择域名注册 – 找到自己的域名 – 解析 和服务器绑定一致，域名也是添加2条记录，一个是www对应 www.domain.com，另一个是@，对应domain.com，全部解析到服务器的ip地址 解析完成后访问域名，如果显示 恭喜, 站点创建成功，就证明解析完成，可以进入下一步的网站搭建了，如果还不能访问，稍等几分钟再尝试 注意，有些国外域名解析的话生效较慢，需要等待一天左右时间 下载Wordpress安装包因为需要到wordpress官网下载程序，就采用的是宝塔的远程下载功能，先教大家如何使用 我们进入宝塔后台 – 文件，可以看到这就是服务器的文件系统，默认的/www目录就是所有网站的目录，可以看到刚刚我们创建的网站 wpwp.xyz，我们点击就能就入网站里面 可以看到网站下还很空，可以先把2个没用的 index.html 和 404.html 删除 在文件的上方，我们可以看到在上传的右边有一个远程下载的按钮，点击会弹出一个对话框 这里我们就填入wordpress最新版的下载地址，确定之后就会下载到当前的目录 有的朋友可能不知道如何获取下载地址，打开wordpress中文下载，在下载按钮上右键 – 复制链接地址 等待一会下载完成后，点击一下刷新按钮，就能看到Wordpress程序的压缩包 选择右键 – 解压，直接确定 解压完成后网站根目录会多出一个wordpress的文件夹 但这样不能直接使用的，我们还要继续将wordpress文件夹内的所有文件移动到网站的根目录 选中所有文件，然后剪切，然后到网站根目录粘贴所有 最后的目录结构如下图就行了 WordPress安装环境和程序都就绪了，接下来就可以开始安装Wordpress网站了 访问 www.domain.com(自己购买的域名)，进入程序安装界面，第一步选择 现在就开始]]></content>
      <categories>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress搭建</tag>
        <tag>WordPress优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程思想第七章练习]]></title>
    <url>%2F2019%2F09%2F04%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[编程思想第七章练习 练习1:创建一个简单的类。第二个类中，将一个引用定义为第一个类的对象。运用惰性初始化来实例化 这个对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Test &#123; public static void main(String[] args) &#123; Second second = new Second(&quot;Init String&quot;); second.chenked(); System.out.println(second.getSimple()); second.chenked(); System.out.println(second); second.setSimple(&quot;New String&quot;); System.out.println(second); &#125;&#125;class Simple&#123; String s; public Simple(String si) &#123; s = si; &#125; public String toString() &#123; return s; &#125; public void setString(String sNew) &#123; s = sNew; &#125;&#125;class Second&#123; Simple simple; String s; public Second(String si) &#123; s = si; &#125; public void chenked() &#123; if(simple==null) &#123; System.out.println(&quot;not initialized&quot;); &#125;else &#123; System.out.println(&quot;initialized&quot;); &#125; &#125; private Simple lazy() &#123; if(simple==null) &#123; System.out.println(&quot;Creating simple&quot;); simple = new Simple(s); &#125; return simple; &#125; public Simple getSimple() &#123; return lazy(); &#125; public String toString() &#123; return lazy().toString(); &#125; public void setSimple(String sNew) &#123; lazy().setString(sNew); &#125;&#125;/*Output:not initializedCreating simpleInit StringinitializedInit StringNew String*///:~ 练习2：从Detergent中继承产生一个新的类。覆盖scrub()并添加一个名为sterilize()的新方法。 12345678910111213141516171819202122232425262728293031323334class Cleanser &#123; private String s = &quot;Cleanser&quot;; public void append(String a) &#123; s += a; &#125; public void dilute() &#123; append(&quot; dilute()&quot;); &#125; public void apply() &#123; append(&quot; apply()&quot;); &#125; public void scrub() &#123; append(&quot; scrub()&quot;); &#125; public String toString() &#123; return s; &#125; public static void main(String[] args) &#123; Cleanser x = new Cleanser(); x.dilute(); x.apply(); x.scrub(); System.out.println(x); &#125; &#125; public class Detergent extends Cleanser &#123; // Change a method: public void scrub() &#123; append(&quot; Detergent.scrub()&quot;); super.scrub(); // Call base-class version &#125; // Add methods to the interface: public void foam() &#123; append(&quot; foam()&quot;); &#125; // Test the new class: public static void main(String[] args) &#123; Detergent x = new Detergent(); x.dilute(); x.apply(); x.scrub(); x.foam(); System.out.println(x); System.out.println(&quot;Testing base class:&quot;); Cleanser.main(args); &#125; &#125; 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; NewDetergent newDetergent = new NewDetergent(); newDetergent.dilute(); newDetergent.scrub(); newDetergent.sterilize(); System.out.println(newDetergent); &#125;&#125;class NewDetergent extends Detergent&#123; public void scrub() &#123; append(&quot;new Detergent.scrub&quot;); super.scrub(); &#125; public void sterilize() &#123; append(&quot;sterilize&quot;); &#125;&#125; 练习3：证明前面两句话（即使你不为Cartoon创建构造器，编译器也为会你合成一个默认的构造器，该构造器将调用基类的构造器） 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; new Cartoon(); &#125;&#125;class Art&#123; Art()&#123; System.out.println(&quot;Art constructor&quot;); &#125;&#125;class Drawing extends Art&#123; Drawing()&#123; System.out.println(&quot;Drawing Contructor&quot;); &#125;&#125;class Cartoon extends Drawing&#123;// public Cartoon() &#123;// System.out.println(&quot;Cartoon Contructor&quot;);// &#125;&#125;/*Output:Art constructorDrawing Contructor*///:~ 练习4：证明基类构造器总是会被调用，在导出类构造器之前被调用。 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; new Derived2(); &#125;&#125;class Base1&#123; public Base1() &#123; System.out.println(&quot;Base1&quot;); &#125;&#125;class Derived1 extends Base1&#123; public Derived1() &#123; System.out.println(&quot;Derived&quot;); &#125;&#125;class Derived2 extends Derived1&#123; public Derived2() &#123; System.out.println(&quot;Derived2&quot;); &#125;&#125; 练习5：创建两个带有默认构造器（空参数列表）的类A和类B。从A中继承产生一个名为C的新，并在C内创建一个B类的成员。不要给C编写构造器。创建一个C类的对象并观察其结果。 12345678910111213141516171819202122class A&#123; A() &#123; System.out.println(&quot;A()&quot;); &#125;&#125;class B&#123; B() &#123; System.out.println(&quot;B()&quot;); &#125;&#125;class C extends A&#123; B b = new B();&#125;public class Test &#123; public static void main(String[] args) &#123; new C(); &#125;&#125;/*Output:A()B()*///:~ 练习7：修改练习5，使A和B以带参数的构造器取代默认的构造器。为C写一个构造器，并在其中执行所有初始化。 12345678910111213141516171819202122class A&#123; A(int i) &#123; System.out.println(&quot;A()&quot;); &#125;&#125;class B&#123; B(String i) &#123; System.out.println(&quot;B()&quot;); &#125;&#125;class C extends A&#123; C()&#123; super(1); B b = new B(&quot;s&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new C(); &#125;&#125; 练习8：创建一个基类，它仅有一个非默认构造器；再创建一个导出类，它带有默认构造器和非默认构造器。在导出类的构造器中调用基类的构造器。 123456789101112131415161718class A&#123; A(int i)&#123; System.out.println(&quot;A()&quot;); &#125;&#125;public class Test extends A&#123; Test()&#123; super(1); &#125; Test(int i)&#123; super(i); &#125; public static void main(String[] args) &#123; new Test(); new Test(2); &#125;&#125; 练习9：创建一个Root类，令其含有名为Component1、Component 2、Component3的类的各一个实例（这些也由你写）。从Root中派生一个类Stem，也含有上述各“组成部分”。所有的类都应带有可打印出类的相关信息的默认构造器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Component1&#123; Component1()&#123; System.out.println(&quot;Component1&quot;); &#125;&#125;class Component2&#123; Component2()&#123; System.out.println(&quot;Component2&quot;); &#125;&#125;class Component3&#123; Component3()&#123; System.out.println(&quot;Component3&quot;); &#125;&#125;class Root &#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Root()&#123; System.out.println(&quot;Root()&quot;); &#125;&#125;class Stem extends Root&#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Stem()&#123; System.out.println(&quot;Stem()&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Stem s = new Stem(); &#125;&#125;/*Output:Component1Component2Component3Root()Component1Component2Component3Stem()*///:~ 练习10：修改练习9，使每个类都仅具有非默认的构造器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Component1&#123; Component1()&#123; System.out.println(&quot;Component1&quot;); &#125;&#125;class Component2&#123; Component2()&#123; System.out.println(&quot;Component2&quot;); &#125;&#125;class Component3&#123; Component3()&#123; System.out.println(&quot;Component3&quot;); &#125;&#125;class Root &#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Root(int i)&#123; System.out.println(&quot;Root()&quot;); &#125;&#125;class Stem extends Root&#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Stem(int i)&#123; super(i); System.out.println(&quot;Stem()&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Stem s = new Stem(1); &#125;&#125;/*Output:Component1Component2Component3Root()Component1Component2Component3Stem()*///:~ 练习12：将一个适当的dispose()方法的层次结构添加到练习9的所有类中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Component1&#123; Component1()&#123; System.out.println(&quot;Component1&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Componentc1.dispose()&quot;); &#125;&#125;class Component2&#123; Component2()&#123; System.out.println(&quot;Component2&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Componentc2.dispose()&quot;); &#125;&#125;class Component3&#123; Component3()&#123; System.out.println(&quot;Component3&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Componentc3.dispose()&quot;); &#125;&#125;class Root &#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Root()&#123; System.out.println(&quot;Root()&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Root.dispose()&quot;); c1.dispose(); c2.dispose(); c3.dispose(); &#125;&#125;class Stem extends Root&#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Stem()&#123; System.out.println(&quot;Stem()&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Stem.dispose()&quot;); c1.dispose(); c2.dispose(); c3.dispose(); super.dispose(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new Stem().dispose(); &#125;&#125;/*Output:Component1Component2Component3Root()Component1Component2Component3Stem()Stem.dispose()Componentc1.dispose()Componentc2.dispose()Componentc3.dispose()Root.dispose()Componentc1.dispose()Componentc2.dispose()Componentc3.dispose()*///:~ 练习13:创建一个类，它应带有一个被重载了三次的方法。继承产生一个新类，并添加一个该方法的新的重载定义，展示这四个方法在导出类中都是可以使用的。 1234567891011121314151617181920212223242526272829class A&#123; void Overload(int i) &#123; System.out.println(&quot;A1&quot;); &#125; void Overload(String i) &#123; System.out.println(&quot;A2&quot;); &#125; void Overload(float i) &#123; System.out.println(&quot;A3&quot;); &#125;&#125;public class Test extends A&#123; void Overload(char i) &#123; System.out.println(&quot;Test&quot;); &#125; public static void main(String[] args) &#123; Test test = new Test(); test.Overload(1); test.Overload(&quot;1&quot;); test.Overload(1f); test.Overload(&apos;1&apos;); &#125;&#125;/*Output:A1A2A3Test*///:~ 练习14：在Car.java中给Engine添加一个service(),并在main()中调用该方法。 123456789101112131415161718192021222324252627282930313233343536class Engine&#123; public void start() &#123;&#125; public void rev() &#123;&#125; public void stop() &#123;&#125; public void service() &#123;&#125;&#125;class Wheel&#123; public void inflate(int psi) &#123;&#125;&#125;class Window&#123; public void rollup() &#123;&#125; public void rolldown() &#123;&#125;&#125;class Door&#123; public Window window = new Window(); public void open() &#123;&#125; public void close() &#123;&#125;&#125;public class Car&#123; private Engine engine = new Engine(); private Wheel[] wheel = new Wheel[4]; public Door left = new Door(), right = new Door(); public Car() &#123; for(int i=0;i&lt;4;i++) &#123; wheel[i] = new Wheel(); &#125; &#125; public static void main(String[] args) &#123; Car car = new Car(); car.left.window.rollup(); car.wheel[0].inflate(72); car.engine.service(); &#125;&#125; 练习15：在包中编写一个类，类应具备一个protected方法。在包外部，试着调用protede方法并解释其结果。然后，从你的类中继承产生一个类，并从该导出类的方法内部调用该protected方法 1234567package test1982;public class A&#123; protected void f() &#123; System.out.println(&quot;f()&quot;); &#125;&#125; 12345678910111213package test;import test1982.*;class B extends A&#123; public void g() &#123; f(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; new B().g(); &#125;&#125; 练习16：创建一个名为Amphibian的类，由此继承产生一个成为Frog的类，在基类中设置适当的方法，在main（）中，创建一个Frog向上转型至Amphibian， 然后说明所有方法都可工作。 1234567891011121314class Amphibian&#123; public void f() &#123; System.out.println(&quot;f()&quot;); &#125;&#125;class Frog extends Amphibian&#123; &#125;public class Test&#123; public static void main(String[] args) &#123; Amphibian am =new Frog(); am.f(); &#125;&#125; 练习17：修改练习16，使Frog覆盖基类中方法的定义。请留心main中都发生了什么 12345678910111213141516class Amphibian&#123; public void f() &#123; System.out.println(&quot;Amphibian.f()&quot;); &#125;&#125;class Frog extends Amphibian&#123; public void f() &#123; System.out.println(&quot;Frog.f()&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Amphibian am =new Frog(); am.f(); &#125;&#125; 练习18：创建一个含有static final域和final域的类，说明二者间的区别。 123456789101112131415161718192021222324252627282930313233public class Exercise7_18 &#123; public static void main(String[] args) &#123; System.out.println(&quot;First Object&quot;); System.out.println(new WithFinalFields()); System.out.println(&quot;Second Object&quot;); System.out.println(new WithFinalFields()); &#125;&#125;class SelfCounter &#123; private static int count; private int id = count++; public String toString() &#123; return &quot;Selfcounter&quot; + id; &#125;&#125;class WithFinalFields &#123; final SelfCounter selfCounter = new SelfCounter(); static final SelfCounter s = new SelfCounter(); public String toString() &#123; return &quot;selfcounter = &quot; + selfCounter + &quot; \ns = &quot; + s; &#125;&#125;/*Output:First Objectselfcounter = Selfcounter1 s = Selfcounter0Second Objectselfcounter = Selfcounter2 s = Selfcounter0*///:~ 练习20：展示@Override注解可以解决本节中的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class WithFinals &#123; // Identical to &quot;private&quot; alone: private final void f() &#123; System.out.println(&quot;WithFinals.f()&quot;); &#125; // Also automatically &quot;final&quot;: private void g() &#123; System.out.println(&quot;WithFinals.g()&quot;); &#125;&#125;class OverridingPrivate extends WithFinals &#123; private final void f() &#123; System.out.println(&quot;OverridingPrivate.f()&quot;); &#125; private void g() &#123; System.out.println(&quot;OverridingPrivate.g()&quot;); &#125;&#125;class OverridingPrivate2 extends OverridingPrivate &#123; public final void f() &#123; System.out.println(&quot;OverridingPrivate2.f()&quot;); &#125; public void g() &#123; System.out.println(&quot;OverridingPrivate2.g()&quot;); &#125;&#125;public class FinalOverridingIllusion &#123; public static void main(String[] args) &#123; OverridingPrivate2 op2 = new OverridingPrivate2(); op2.f(); op2.g(); // You can upcast: OverridingPrivate op = op2; // But you can&apos;t call the methods: // ! op.f(); // ! op.g(); // Same here: WithFinals wf = op2; // ! wf.f(); // ! wf.g(); &#125;&#125; 12345678910111213141516171819202122232425262728293031public class Exercise7_20 &#123; public static void main(String[] args) &#123; OverridingPrivate20 oPrivate = new OverridingPrivate20(); // oPrivate.f(); // oPrivate.g(); &#125;&#125;class OverridingPrivate20 extends WithFinals &#123; @Override private final void f() &#123; System.out.println(&quot;OverridingPrivate.f()&quot;); &#125; @Override private void g() &#123; System.out.println(&quot;OverridingPrivate.g()&quot;); &#125;&#125;class OverridingPrivate30 extends OverridingPrivate20 &#123; @Override public void f() &#123; System.out.println(&quot;OverridingPrivate2.f()&quot;); &#125; @Override public void g() &#123; System.out.println(&quot;OverridingPrivate2.g()&quot;); &#125;&#125; 练习21：创建一个但final方法的类。由此继承产生一个类并尝试覆盖该方法 1234567891011121314public class Exercise7_21 extends WithFinalMethod &#123;// void f() &#123;// // &#125; public static void main(String[] args) &#123; &#125;&#125;class WithFinalMethod &#123; final void f() &#123; &#125;&#125; 练习23：请证明加载类的动作仅发生一次。证明该类的第一个实体的创建者或者对static成员的访问都有可能引起加载 1234567891011121314public class Exercise7_23 &#123; public static void main(String[] args) &#123; System.out.println(&quot;Calling static member&quot;); LoadTest.staticMember(); System.out.println(&quot;Creating an object&quot;); new LoadTest(); &#125;&#125;class LoadTest&#123; static&#123; System.out.println(&quot;Loading loadTest&quot;); &#125; static void staticMember() &#123;&#125;;&#125; 练习24：在Beetle.java中，从Beetle类继承产生一个具体类型的“甲壳虫”。其形式与现有类相同，跟踪并解释其输出结果]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java惰性初始化]]></title>
    <url>%2F2019%2F08%2F19%2FJava%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Java惰性初始化 在书中第七章中提到了引用的初始化，编译器并不是简单地为每一个引用都创建默认对象，减少不必要的负担 1、在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。2、在类的构造器中。3、就在正要使用这些对象之前，这种方式称为惰性初始化。在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担。4、使用实例初始化。 惰性初始化的目的是延迟对象的初始化，直到程序真正使用它，同时确保它只初始化一次。 /*惰性初始化：当需要一个实例的时候才初始化一个对象。新建两个简单的类，第二个类中包含第一个类的一个引用，当需要第一个类的对象是调用Lazy()方法即可获得第一个类的对象。*/ 123456789101112131415161718class First&#123; First()&#123; System.out.print(&quot;First()&quot;); &#125;&#125;public class Lazy&#123; First f; public void print()&#123; if(f==null) f = new First(); &#125; public static void main(String[] args)&#123; Lazy z = new Lazy(); z.print(); &#125;&#125;/*Output:First()*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程思想第五章练习]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[编程思想第五章练习 练习1：创建一个类,它包含一个未初始化的String引用.验证该引用被Java初始化成null 12345678910class Test&#123; public String string;&#125;public class E1 &#123; public static void main(String[] args) &#123; Test test = new Test(); System.out.println((test.string == null)); &#125;&#125; 练习2：创建一个类，它包含一个在定义时就被初始化了的String域，以及另一个通过构造器初始化的String域。这两种方式有何差异。 12345678910111213public class Test &#123; String s1=&quot;Initialized at definition&quot;; String s2; public Test(String s) &#123; s2 = s; &#125; public static void main(String[] args) &#123; Test test = new Test(&quot;Initialized at constructor&quot;); System.out.println(&quot;s1= &quot;+test.s1); System.out.println(&quot;s2= &quot;+test.s2); &#125;&#125; 练习3：创建一个带默认构造器（即无参构造器）的类，在构造器中打印一条消息。为这个类创建一个对象。 12345678910class T1&#123; T1()&#123; System.out.println(&quot;无参构造器&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new T1(); &#125;&#125; 练习4：为前一个练习中的类添加一个重载构造器，令其接受一个字符参数，并在构造器中把你自己的信息和接受的参数一起打印出来。 1234567891011121314151617class T1&#123; T1()&#123; System.out.println(&quot;这是无参构造器&quot;); &#125; T1(String s)&#123; System.out.println(&quot;这是&quot;+s); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new T1(); new T1(&quot;重载构造器&quot;); &#125;&#125;/*Output:这是无参构造器这是重载构造器*///:~ 练习5：创建一个名为Dog的类，它具有重载的bark（）方法。此方法应根据不同的基本数据类型进行重载，并根据被调用的版本，打印出不同类型的狗吠（barking）、咆哮（howling）等信息，编写main（）来调用所有不同版本的方法。 123456789101112131415161718class Dog&#123; void bark() &#123; System.out.println(&quot;barking&quot;); &#125; void bark(int i) &#123; System.out.println(&quot;howling&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.bark(); dog.bark(1); &#125;&#125;/*Output:barkinghowling*///:~ 练习6：修改前一个练习的程序，让两个重载方法各自接受两个类型的不同的参数，但二者顺序相反。验证其是否工作。 123456789101112131415161718class Dog&#123; void bark(float f,int i) &#123; System.out.println(&quot;barking&quot;); &#125; void bark(int i,float f) &#123; System.out.println(&quot;howling&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.bark(1.1f,1); dog.bark(1,1.1f); &#125;&#125;/*Output:barkinghowling*///:~ 练习7：创建一个没有构造器的类，并在main（）中创建其对象，用以验证编译器是否真的自动加入了默认构造器。 12345678class Dog&#123; &#125;public class Test &#123; public static void main(String[] args) &#123; new Dog(); &#125;&#125; 练习8：编写具有两个方法的类，在第一个方法内调用第二个方法两次：第一次调用时不使用this关键字，第二次调用时使用this关键字————这里只是为了验证它是起作用的，你不应该在实践中使用这种方法。 12345678910111213141516public class Test&#123; void t1() &#123; t2(); this.t2(); &#125; void t2() &#123; System.out.println(&quot;t2()&quot;); &#125; public static void main(String[] args) &#123; new Test().t1(); &#125;&#125;/*Output:t2()t2()*///:~ 练习14：编写一个类，拥有两个静态字符串域，其中一个在定义处初始化，另一个在静态块中初始化。现在，加入一个静态方法用以打印出两个字段值。请证明它们都会在被使用之前完成初始化动作。 12345678910111213141516public class Test&#123; static String a = &quot;a&quot;; static String b; static &#123; b = &quot;b&quot;; &#125; void print() &#123; System.out.println(a); System.out.println(b); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 练习15：编写一个含有字符串域的类，并采用实例初始化方式进行初始化。 123456789101112131415class Test&#123; String s; &#123; s = new String(&quot;s&quot;); &#125; Test ()&#123; System.out.println(s); &#125; &#125;public class Mugs&#123; public static void main(String[] args) &#123; Test test = new Test(); &#125;&#125; 练习16：创建一个String对象数据，并为每一个元素都赋值一个String。用for循环来打印该数组。 1234567891011121314public class Test&#123; public static void main(String[] args) &#123; String[] arrayString = &#123;&quot;1111&quot;,&quot;2222&quot;,&quot;3333&quot;,&quot;4444&quot;&#125;; for(String s:arrayString) &#123; System.out.println(s); &#125; &#125;&#125;/*Output:1111222233334444*///:~ 练习17、18：创建一个类，它有一个构造器，这个构造器接收一个String类型的参数。在构造阶段，打印此参数。创建一个该类对象的引用数组，但是不实际地创建对象赋值给该数组。试着运行程序。再试着通过创建对象，再赋值给引用数组，从而完成程序。 12345678910111213141516class TestString&#123; TestString(String string)&#123; System.out.println(string); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; TestString[] tests = new TestString[] &#123; new TestString(&quot;a&quot;), new TestString(&quot;b&quot;) &#125;; &#125;&#125;/*Output:ab*///:~ 练习19：写一个类，他接受一个可变参数的String数组，验证你可以向该方法传递一个用逗号分隔的String列表，或是一个String[] 123456789101112public class Test&#123; static void printString(String... args) &#123; for(String s:args) &#123; System.out.print(s+&quot; &quot;); &#125; &#125; public static void main(String[] args) &#123; printString(new String[] &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;); &#125;&#125;/*Output:a b c *///:~ 练习20：创建一个使用可变参数列表而不是用普通main()语法的主函数main()，打印args数组的传入的命令行参数。 1234567public class Test&#123; public static void main(String... args) &#123; for(String s:args) &#123; System.out.println(s); &#125; &#125;&#125; 练习21：创建一个enum，它包含纸币中最小面值的6种类型。通过values()循环并打印每一个值及其ordinal() 12345678910111213141516enum Money&#123; One,Five,Ten,Twe,Fif&#125;public class Test&#123; public static void main(String[] args) &#123; for(Money s:Money.values()) &#123; System.out.println(s+&quot;,ordinal:&quot;+s.ordinal()); &#125; &#125;&#125;/*Output:One,ordinal:0Five,ordinal:1Ten,ordinal:2Twe,ordinal:3Fif,ordinal:4*///:~ 练习22：在前面的例子中，为enum写一个switch语句，对于每一个case，输出该特定货币的描述。 123456789101112131415161718192021222324252627282930313233343536373839404142enum Money&#123; One,Five,Ten,Twe,Fif&#125;class A&#123; void describe(Money s)&#123; switch(s) &#123; case One: System.out.println(&quot;1&quot;); break; case Five: System.out.println(&quot;5&quot;); break; case Ten: System.out.println(&quot;10&quot;); break; case Twe: System.out.println(&quot;20&quot;); break; case Fif: System.out.println(&quot;30&quot;); break; default: break; &#125; &#125; &#125;public class Test&#123; public static void main(String[] args) &#123; A a = new A(); for(Money s:Money.values()) &#123; System.out.print(s +&quot;:&quot;); a.describe(s); &#125; &#125;&#125;/*Output:One:1Five:5Ten:10Twe:20Fif:30*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组初始化]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数组初始化 数组初始化123456789101112131415161718public class Test&#123; public static void main(String[] args) &#123; int[] a1 = &#123;1,2,3,4,5&#125;; int[] a2; a2=a1; for(int i =0;i&lt;a2.length;i++) a2[i]=a2[i]+1; for(int i =0;i&lt;a2.length;i++) System.out.print(a1[i]+&quot; &quot;); System.out.println(); for(int i =0;i&lt;a2.length;i++) System.out.print(a2[i]+&quot; &quot;); &#125;&#125;/*Output:2 3 4 5 6 2 3 4 5 6 *///:~ a1赋值给了a2，a2赋值后，发现a1数组改变，输出a1和a2后发现相等]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java主函数的调用]]></title>
    <url>%2F2019%2F08%2F10%2FJava%E4%B8%BB%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java主函数的调用 一个java文件里可以存在多个class，但是只能有一个public class 你可以创建一个String对象数组，将其传递给另一个main（）方法，以提供参数，用来替换传递给该main（）方法的命令行参数。 12345678910111213141516public class DynamicArray&#123; public static void main(String[] args) &#123; Other.main(new String[] &#123;&quot;fiddle&quot;,&quot;de&quot;,&quot;dum&quot;&#125;); &#125;&#125;class Other&#123; public static void main(String[] args) &#123; for(String s:args) &#123; System.out.println(s+&quot; &quot;); &#125; &#125;&#125;/*Output:fiddle de dum *///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造器初始化]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[构造器初始化 初始化顺序在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。 123456789101112131415161718192021222324252627282930class Window&#123; Window(int marker)&#123; System.out.println(&quot;Window(&quot;+marker+&quot;)&quot;); &#125;&#125;class House&#123; Window w1 = new Window(1); House()&#123; System.out.println(&quot;House()&quot;); w3 = new Window(33); &#125; Window w2 = new Window(2); void f() &#123; System.out.println(&quot;f()&quot;); &#125; Window w3 = new Window(3);&#125;public class Flower&#123; public static void main(String[] args) &#123; House h = new House(); h.f(); &#125;&#125;/*Output:Window(1)Window(2)Window(3)House()Window(33)f()*///:~ w3这个引用会被初始化两次：一次在调用构造器前，一次在调用期间（第一次引用的对象将被丢弃，并作为垃圾回收） 静态数据的初始化1、无论创建多少个对象，静态数据都只占用一份存储区域。2、static关键字不能应用于局部变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Bowl&#123; Bowl(int marker)&#123; System.out.println(&quot;Bowl(&quot;+marker+&quot;)&quot;); &#125; void f1(int marker) &#123; System.out.println(&quot;f1(&quot;+marker+&quot;)&quot;); &#125;&#125;class Table&#123; static Bowl bowl1 = new Bowl(1); Table()&#123; System.out.println(&quot;Table()&quot;); bowl2.f1(1); &#125; void f2(int marker) &#123; System.out.println(&quot;f2(&quot;+marker+&quot;)&quot;); &#125; static Bowl bowl2 = new Bowl(2);&#125;class Cupboard&#123; Bowl bowl3 = new Bowl(3); static Bowl bowl4 = new Bowl(4); Cupboard()&#123; System.out.println(&quot;Cupboard()&quot;); bowl4.f1(2); &#125; void f3(int marker) &#123; System.out.println(&quot;f3(&quot;+marker+&quot;)&quot;); &#125; static Bowl bowl5 = new Bowl(5);&#125;public class Flower&#123; public static void main(String[] args) &#123; System.out.println(&quot;Creating new Cupboard() in main&quot;); new Cupboard(); System.out.println(&quot;Creating new Cupboard() in main&quot;); new Cupboard(); table.f2(1); cupboard.f3(1); &#125; static Table table = new Table(); static Cupboard cupboard = new Cupboard();&#125;/*Output:Bowl(1)Bowl(2)Table()f1(1)Bowl(4)Bowl(5)Bowl(3)Cupboard()f1(2)Creating new Cupboard() in mainBowl(3)Cupboard()f1(2)Creating new Cupboard() in mainBowl(3)Cupboard()f1(2)f2(1)f3(1)*///:~ 初始化时静态对象会先初始化，而后是非静态对象 总结对象的创建过程1、即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。2、然后载入Dog.class，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。3、当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。4、这块存储空间会被清零，这就自动地将Dog对象中地所有基本类型数据设置成了默认值（对数字来说就是0，对布尔型和字符型也相同），而引用则被设置成了null。5、执行所有出现于字段定义处地初始化动作。6、执行构造器。 显式的静态初始化（代码不理解，这里先做下标记把，有空再慢慢看）123456789101112131415161718192021222324252627282930class Cup&#123; Cup(int marker)&#123; System.out.println(&quot;Cup(&quot;+marker+&quot;)&quot;); &#125; void f(int marker) &#123; System.out.println(&quot;f(&quot;+marker+&quot;)&quot;); &#125;&#125;class Cups&#123; static Cup cup1; static Cup cup2; static &#123; cup1 = new Cup(1); cup2 = new Cup(2); &#125; Cups()&#123; System.out.println(&quot;Cups()&quot;); &#125;&#125;public class Flower&#123; public static void main(String[] args) &#123; System.out.println(&quot;Inside main()&quot;); Cups.cup1.f(99); &#125;&#125;/*Output:Inside main()Cup(1)Cup(2)f(99)*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2F2019%2F08%2F09%2Fthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[编程思想第五章5.4中,这一段代码看着有点懵逼，记下来 12345678910111213141516171819202122class Person&#123; void eat(Apple apple) &#123; Apple peeled =apple.getPeeled(); System.out.println(&quot;Yummy&quot;); &#125;&#125;class Peeler&#123; static Apple peel(Apple apple) &#123; return apple; &#125;&#125;class Apple&#123; Apple getPeeled() &#123; return Peeler.peel(this); &#125;&#125;public class Leaf &#123; public static void main(String[] args) &#123; new Person().eat(new Apple()); &#125;&#125; Apple需要调用Peeler.peel（）方法，它是一个外部的工具方法，将执行由于某种原因而必须放在Apple外部的操作。为了将自身传递给外部方法，Apple必须使用this关键字。 在构造器中调用构造器1234567891011121314151617181920212223242526272829303132333435public class Flower&#123; int petalCount = 0; String s=&quot;initial value&quot;; Flower(int petals)&#123; petalCount = petals; System.out.println(&quot;Constructor w/ int arg only,petalCount= &quot;+petalCount); &#125; Flower(String ss)&#123; System.out.println(&quot;Constructor w/ String arg only,s= &quot;+ss); s=ss; &#125; Flower(String s,int petals)&#123; this(petals); //this(s); //Can&apos;t call two! this.s=s; System.out.println(&quot;String &amp; int args&quot;); &#125; Flower()&#123; this(&quot;hi&quot;,47); System.out.println(&quot;default constructor (no args)&quot;); &#125; void printPetalCount() &#123; //this(11); //Not inside non-constructor! System.out.println(&quot;petalCount = &quot;+petalCount+&quot; s= &quot;+s); &#125; public static void main(String[] args) &#123; Flower x = new Flower(); x.printPetalCount(); &#125;&#125;/*Output:Constructor w/ int arg only,petalCount= 47String &amp; int argsdefault constructor (no args)petalCount = 47 s= hi*///:~ this调用构造器不能调用两个。构造器调用必须置于起始值。调用构造器只能在构造器中调用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java方法重载]]></title>
    <url>%2F2019%2F08%2F08%2FJava%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Java方法重载 示范重载构造器和重载的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445class Tree&#123; int height; Tree()&#123; System.out.println(&quot;Planting a seedling&quot;); height= 0; &#125; Tree(int initialHeight)&#123; height = initialHeight; System.out.println(&quot;Creating new Tree that is &quot;+height+&quot; feet tall&quot;); &#125; void info() &#123; System.out.println(&quot;Tree is &quot;+height+&quot;feet tall&quot;); &#125; void info(String s) &#123; System.out.println(s+&quot;:Tree is &quot;+height+&quot;feet tall&quot;); &#125;&#125;public class Overloading &#123; public static void main(String[] args) &#123; for(int i=0;i&lt;5;i++) &#123; Tree t = new Tree(i); t.info(); t.info(&quot;overloaded method&quot;); &#125; new Tree(); &#125;&#125;/*Output:Creating new Tree that is 0 feet tallTree is 0feet talloverloaded method:Tree is 0feet tallCreating new Tree that is 1 feet tallTree is 1feet talloverloaded method:Tree is 1feet tallCreating new Tree that is 2 feet tallTree is 2feet talloverloaded method:Tree is 2feet tallCreating new Tree that is 3 feet tallTree is 3feet talloverloaded method:Tree is 3feet tallCreating new Tree that is 4 feet tallTree is 4feet talloverloaded method:Tree is 4feet tallPlanting a seedling*///:~ 涉及基本类型的重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179public class PrimitiveOverloading &#123; void f1(char x) &#123; System.out.println(&quot;f1(char) &quot;); &#125; void f1(byte x) &#123; System.out.println(&quot;f1(byte) &quot;); &#125; void f1(short x) &#123; System.out.println(&quot;f1(short) &quot;); &#125; void f1(int x) &#123; System.out.println(&quot;f1(int) &quot;); &#125; void f1(long x) &#123; System.out.println(&quot;f1(long) &quot;); &#125; void f1(float x) &#123; System.out.println(&quot;f1(float) &quot;); &#125; void f1(double x) &#123; System.out.println(&quot;f1(double) &quot;); &#125; void f2(byte x) &#123; System.out.println(&quot;f2(byte) &quot;); &#125; void f2(short x) &#123; System.out.println(&quot;f2(short) &quot;); &#125; void f2(int x) &#123; System.out.println(&quot;f2(int) &quot;); &#125; void f2(long x) &#123; System.out.println(&quot;f2(long) &quot;); &#125; void f2(float x) &#123; System.out.println(&quot;f2(float) &quot;); &#125; void f2(double x) &#123; System.out.println(&quot;f2(double) &quot;); &#125; void f3(short x) &#123; System.out.println(&quot;f3(short) &quot;); &#125; void f3(int x) &#123; System.out.println(&quot;f3(int) &quot;); &#125; void f3(long x) &#123; System.out.println(&quot;f3(long) &quot;); &#125; void f3(float x) &#123; System.out.println(&quot;f3(float) &quot;); &#125; void f3(double x) &#123; System.out.println(&quot;f3(double) &quot;); &#125; void f4(int x) &#123; System.out.println(&quot;f4(int) &quot;); &#125; void f4(long x) &#123; System.out.println(&quot;f4(long) &quot;); &#125; void f4(float x) &#123; System.out.println(&quot;f4(float) &quot;); &#125; void f4(double x) &#123; System.out.println(&quot;f4(double) &quot;); &#125; void f5(long x) &#123; System.out.println(&quot;f5(long) &quot;); &#125; void f5(float x) &#123; System.out.println(&quot;f5(float) &quot;); &#125; void f5(double x) &#123; System.out.println(&quot;f5(double) &quot;); &#125; void f6(float x) &#123; System.out.println(&quot;f6(float) &quot;); &#125; void f6(double x) &#123; System.out.println(&quot;f6(double) &quot;); &#125; void f7(double x) &#123; System.out.println(&quot;f7(double) &quot;); &#125; void testConstVal() &#123; System.out.println(&quot;5: &quot;); f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5); System.out.println(); &#125; void testChar() &#123; char x = &apos;x&apos;; System.out.println(&quot;char: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testByte() &#123; byte x =0; System.out.println(&quot;byte: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testShort() &#123; short x =0; System.out.println(&quot;short: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testInt() &#123; int x =0; System.out.println(&quot;int: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testLong() &#123; long x =0; System.out.println(&quot;long: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testFloat() &#123; float x =0; System.out.println(&quot;float: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testDouble() &#123; double x =0; System.out.println(&quot;double: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; public static void main(String[] args) &#123; PrimitiveOverloading p = new PrimitiveOverloading(); p.testConstVal(); p.testChar(); p.testByte(); p.testShort(); p.testInt(); p.testLong(); p.testFloat(); p.testDouble(); &#125;&#125;/*Output:5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double) short: f1(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double) int: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) long: f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double) float: f1(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double) double: f1(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double) *///:~ 如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。 如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。12345void testDouble() &#123; double x =0; System.out.println(&quot;double argument: &quot;); f1(x);f2((double)x);f3((long)x);f4((int)x);f5((short)x);f6((byte)x);f7((char)x); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>重载</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java标签]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Java标签 Java标签,博文内容剽窃于Thinking in Java第四版四章4.7 (●’◡’●)12345678910111213label1:outer-iteration&#123; inner-iteration&#123; //... break; //(1) //... continue; //(2) //... continue label1; //(3) //... break label1; //(4) &#125;&#125; 在（1）中，break中断内部迭代。在（2）中，continue使执行点移回内部迭代的起始值。在（3）中，continue label1同时中断内部迭代以及外部迭代，直接转到label1处；随后，它实际上是继续迭代过程，但却从外部迭代开始。在（4）中，break label1也会中断所有迭代，并回到label1处，但并不重新进入迭代。也就是说，它实际是完全中止了两个迭代。 123456789101112131415161718192021222324252627282930313233343536public class Test&#123; public static void main(String[] args)&#123; int i=0; outer: for(;true;) &#123; inner: for(;i&lt;10;i++) &#123; System.out.println(&quot;i= &quot;+i); if(i==2) &#123; System.out.println(&quot;continue&quot;); continue; &#125; if(i==3) &#123; System.out.println(&quot;break&quot;); i++; //由于break跳过了递增表达式，所以这里添加了递增运算 break; &#125; if(i==7) &#123; System.out.println(&quot;continue outer&quot;); i++; //添加了递增运算 continue outer; &#125; if(i==8) &#123; System.out.println(&quot;break outer&quot;); break outer; &#125; for(int k=0;k&lt;5;k++) &#123; if(k==3) &#123; System.out.println(&quot;continue inner&quot;); continue inner; &#125; &#125; &#125; &#125; &#125;&#125; Output:i= 0continue inneri= 1continue inneri= 2continuei= 3breaki= 4continue inneri= 5continue inneri= 6continue inneri= 7continue outeri= 8break outer break和continue本身只能中断最内层的循环 带标签的break以及continue语句在while循环中的用法：1234567891011121314151617181920212223242526272829public class Test&#123; public static void main(String[] args)&#123; int i=0; outer: while(true) &#123; System.out.println(&quot;Outer while loop&quot;); while(true) &#123; i++; System.out.println(&quot;i= &quot;+i); if(i==1) &#123; System.out.println(&quot;continue&quot;); continue; &#125; if(i==3) &#123; System.out.println(&quot;continue outer&quot;); continue outer; &#125; if(i==5) &#123; System.out.println(&quot;break&quot;); break; &#125; if(i==7) &#123; System.out.println(&quot;break outer&quot;); break outer; &#125; &#125; &#125; &#125;&#125; Output:Outer while loopi= 1continuei= 2i= 3continue outerOuter while loopi= 4i= 5breakOuter while loopi= 6i= 7break outer 同样的规则亦适用于while:1、一般的continue会退出最内层循环开头（顶部），并继续执行。2、带标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。3、一般的break会中断并跳出当前循环。4、带标签的break会中断并跳出标签所指的循环。 在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想第四章练习]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Java编程思想第四章练习 第四章练习1：写一个程序，打印从1到100的值。 1234567public class Test&#123; public static void main(String[] args) &#123; for(int i=1;i&lt;=100;i++) &#123; System.out.println(i); &#125; &#125;&#125; 练习2：写一个程序,产生25个int类型的随机数.对于每一个随机值,使用if-else语句来讲其分类为大于，小于,或等于紧随它产生的值 1234567891011121314151617181920public class Test &#123; public static void main(String[] args)&#123; int num[] =new int[25]; for (int i=0;i&lt;25;i++)&#123; num[i]=(int)(Math.random()*100); &#125; for (int j=0;j&lt;num.length-1;j++)&#123;//一共产生了25个数，需要比较24次，所以j的循环次数是num.length-1次。 if (num[j]&gt;num[j+1])&#123; System.out.println(num[j]+&quot;大于&quot;+&quot;后面的数&quot;+num[j+1]); &#125; else if (num[j]&lt;num[j+1])&#123; System.out.println(num[j]+&quot;小于&quot;+&quot;后面的数&quot;+num[j+1]); &#125; else &#123; System.out.println(num[j]+&quot;等于&quot;+&quot;后面的数&quot;+num[j+1]); &#125; &#125; &#125;&#125; 运行及结果：39小于后面的数7070大于后面的数3030小于后面的数6161大于后面的数5757小于后面的数7676小于后面的数8383大于后面的数1313大于后面的数33小于后面的数3838小于后面的数6060大于后面的数5757小于后面的数7575大于后面的数1212小于后面的数5252小于后面的数6262小于后面的数8484大于后面的数5151大于后面的数1818小于后面的数5959小于后面的数6464大于后面的数4141小于后面的数9898大于后面的数5454大于后面的数51 练习4：写一个程序,使用两个嵌套的for循环和取余操作符来探测和打印素数 12345678910111213141516public class Test &#123; public static void main(String[] args)&#123; boolean flog; for(int i=2;i&lt;=100;i++) &#123; flog=true; for(int j=2;j&lt;i;j++) &#123; if(i%j==0) &#123; flog=false; &#125; &#125; if(flog==true) &#123; System.out.println(i+&quot; &quot;); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 练习5：重复第三章中的练习10，不要用Integer.toBinaryString()方法，而是用三元操作符和按位操作符来显示二进制0和1. 1emmmmmmmmmm 练习7：修改本章练习1，通过使用break关键词（或者return关键词），使其只输出范围为1~99的值。 123456789public class Test&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(i); if(i==99) break; //return &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中break和continue的区别]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E4%B8%ADbreak%E5%92%8Ccontinue%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java中break和continue的区别 在任何迭代语句的主体部分，都可用break和continue控制循环的流程break1、break用于强行退出循环。2、退出后不执行循环中剩余的语句 continue1、停止执行当前的迭代2、退回循环起始处，开始下一次迭代 123456789101112131415161718public class Test&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;=5;i++) &#123; if(i==3) &#123; break; &#125; System.out.println(i); &#125; System.out.println(&quot;===============&quot;); for(int i=0;i&lt;=5;i++) &#123; if(i==3) &#123; continue; &#125; System.out.println(i); &#125; &#125;&#125; 运行及结果：012分隔符01245]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>break</tag>
        <tag>continue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Foreach语句]]></title>
    <url>%2F2019%2F08%2F07%2FForeach%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[Foreach语句 java SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。123456789101112import java.util.Random;public class ForEachFloat&#123; public static void main(String[] args)&#123; Random rand = new Random(47); float f[] = new float[10]; for(int i = 0;i &lt; 10;i++) f[i]=rand.nextFloat(); for(float x:f) System.out.println(x); &#125;&#125; 运行及结果：0.727115750.399826350.53094540.05341220.160206560.577997570.188478650.41701370.516602040.73734957 123456public class ForEachFloat&#123; public static void main(String[] args)&#123; for(char c:&quot;An African Swallow&quot;.toCharArray()) System.out.print(c+&quot; &quot;); &#125;&#125; 运行及结果：A n A f r i c a n S w a l l o w]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Foreach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[截尾和舍入]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在执行窄化转换时，必须注意截尾与舍入问题。例如：如果将一个浮点值转换整形值，Java会如何处理？ 12345678910public class CastingNumbers &#123; public static void main(String[] args) &#123; double above = 0.7,below = 0.4; float fabove = 0.7f,fbelow = 0.4f; System.out.println(&quot;(int)above: &quot;+(int)above); System.out.println(&quot;(int)below: &quot;+(int)below); System.out.println(&quot;(int)fabove: &quot;+(int)fabove); System.out.println(&quot;(int)fbelow: &quot;+(int)fbelow); &#125;&#125; 运行及结果：(int)above: 0(int)below: 0(int)fabove: 0(int)fbelow: 0 运行结果发现，在将float和double转型为整数值时，总是对该数字执行截尾。如果想要得到舍入的结果，就需要使用java.lang.Math中的round()方法。 12345678910public class CastingNumbers &#123; public static void main(String[] args) &#123; double above = 0.7,below = 0.4; float fabove = 0.7f,fbelow = 0.4f; System.out.println(&quot;Math.round(above): &quot;+Math.round(above)); System.out.println(&quot;Math.round(below): &quot;+Math.round(below)); System.out.println(&quot;Math.round(fabove): &quot;+Math.round(fabove)); System.out.println(&quot;Math.round(fbelow): &quot;+Math.round(fbelow)); &#125;&#125; 运行及结果:Math.round(above): 1Math.round(below): 0Math.round(fabove): 1Math.round(fbelow): 0 由于round()是java.lang的一部分，因此在使用它时不需要额外地导入。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
        <tag>数据类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涉及按位操作的所有操作符（求二进制）]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%B6%89%E5%8F%8A%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[涉及按位操作的所有操作符（求二进制） 代码以下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Random;public class BitManipulation&#123; public static void main(String[] args) &#123; Random rand = new Random(47); int i = rand.nextInt(); int j = rand.nextInt(); printBinaryInt(&quot;-1&quot;,-1); printBinaryInt(&quot;+1&quot;,+1); int maxpos = 2147483647; printBinaryInt(&quot;maxpos&quot;,maxpos); int maxneg = -2147483648; printBinaryInt(&quot;maxpos&quot;,maxneg); printBinaryInt(&quot;i&quot;,i); printBinaryInt(&quot;~i&quot;,~i); printBinaryInt(&quot;-i&quot;,-i); printBinaryInt(&quot;j&quot;,j); printBinaryInt(&quot;i&amp;j&quot;,i&amp;j); printBinaryInt(&quot;i|j&quot;,i|j); printBinaryInt(&quot;i^j&quot;,i^j); //不同为1，相同为0 printBinaryInt(&quot;i&lt;&lt;5&quot;,i&lt;&lt;5); printBinaryInt(&quot;i&gt;&gt;5&quot;,i&gt;&gt;5); printBinaryInt(&quot;(~i)&gt;&gt;5&quot;,(~i)&gt;&gt;5); printBinaryInt(&quot;i&gt;&gt;&gt;5&quot;,i&gt;&gt;&gt;5); printBinaryInt(&quot;(~i)&gt;&gt;&gt;5&quot;,(~i)&gt;&gt;&gt;5); long l = rand.nextLong(); long m = rand.nextLong(); printBinaryLong(&quot;-1L&quot;,-1L); printBinaryLong(&quot;+1L&quot;,+1L); long ll = 9223372036854775807L; printBinaryLong(&quot;maxpos&quot;,ll); long lln = -9223372036854775808L; printBinaryLong(&quot;maxneg&quot;,lln); printBinaryLong(&quot;l&quot;,l); printBinaryLong(&quot;~l&quot;,~l); printBinaryLong(&quot;-l&quot;,-l); printBinaryLong(&quot;m&quot;,m); printBinaryLong(&quot;l&amp;m&quot;,l&amp;m); printBinaryLong(&quot;l|m&quot;,l|m); printBinaryLong(&quot;l^m&quot;,l^m); printBinaryLong(&quot;l&lt;&lt;5&quot;,l&lt;&lt;5); printBinaryLong(&quot;l&gt;&gt;5&quot;,l&gt;&gt;5); printBinaryLong(&quot;(~l)&gt;&gt;5&quot;,(~l)&gt;&gt;5); printBinaryLong(&quot;l&gt;&gt;&gt;5&quot;,l&gt;&gt;&gt;5); printBinaryLong(&quot;(~l)&gt;&gt;&gt;5&quot;,(~l)&gt;&gt;&gt;5); &#125; static void printBinaryInt(String s, int i) &#123; System.out.println(s+&quot;,int: &quot;+i+&quot;.binary:\n &quot;+Integer.toBinaryString(i)); &#125; static void printBinaryLong(String s, long l) &#123; System.out.println(s+&quot;,long: &quot;+l+&quot;.binary:\n &quot;+Long.toBinaryString(l)); &#125;&#125; 运行及结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364-1,int: -1.binary: 11111111111111111111111111111111+1,int: 1.binary: 1maxpos,int: 2147483647.binary: 1111111111111111111111111111111maxpos,int: -2147483648.binary: 10000000000000000000000000000000i,int: -1172028779.binary: 10111010001001000100001010010101~i,int: 1172028778.binary: 1000101110110111011110101101010-i,int: 1172028779.binary: 1000101110110111011110101101011j,int: 1717241110.binary: 1100110010110110000010100010110i&amp;j,int: 570425364.binary: 100010000000000000000000010100i|j,int: -25213033.binary: 11111110011111110100011110010111i^j,int: -595638397.binary: 11011100011111110100011110000011i&lt;&lt;5,int: 1149784736.binary: 1000100100010000101001010100000i&gt;&gt;5,int: -36625900.binary: 11111101110100010010001000010100(~i)&gt;&gt;5,int: 36625899.binary: 10001011101101110111101011i&gt;&gt;&gt;5,int: 97591828.binary: 101110100010010001000010100(~i)&gt;&gt;&gt;5,int: 36625899.binary: 10001011101101110111101011-1L,long: -1.binary: 1111111111111111111111111111111111111111111111111111111111111111+1L,long: 1.binary: 1maxpos,long: 9223372036854775807.binary: 111111111111111111111111111111111111111111111111111111111111111maxneg,long: -9223372036854775808.binary: 1000000000000000000000000000000000000000000000000000000000000000l,long: -8652529054300476342.binary: 1000011111101100000010101010101100001101101011000110110001001010~l,long: 8652529054300476341.binary: 111100000010011111101010101010011110010010100111001001110110101-l,long: 8652529054300476342.binary: 111100000010011111101010101010011110010010100111001001110110110m,long: 2955289354441303771.binary: 10100100000011010011000000001010010011111101111010011011011011l&amp;m,long: 72066398748419146.binary: 100000000000010000000001000000001101001000010010001001010l|m,long: -5769306098607591717.binary: 1010111111101111010011101010101110011111111111111110111011011011l^m,long: -5841372497356010863.binary: 1010111011101111010001101010100110011110010110111100101010010001l&lt;&lt;5,long: -179768631971968704.binary: 1111110110000001010101010110000110110101100011011000100101000000l&gt;&gt;5,long: -270391532946889886.binary: 1111110000111111011000000101010101011000011011010110001101100010(~l)&gt;&gt;5,long: 270391532946889885.binary: 1111000000100111111010101010100111100100101001110010011101l&gt;&gt;&gt;5,long: 306069219356533602.binary: 10000111111011000000101010101011000011011010110001101100010(~l)&gt;&gt;&gt;5,long: 270391532946889885.binary: 1111000000100111111010101010100111100100101001110010011101 注意高位表示符号：0为正，1为负。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>移位操作符</tag>
        <tag>二进制</tag>
        <tag>按位操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制转十进制快速方法]]></title>
    <url>%2F2019%2F08%2F05%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[转自 https://blog.csdn.net/xy2204/article/details/50522075 如果你是搞网络的，我觉得你一定要记住以下几种二进制数的转换值。你是一个网络工程 师，当看到一串二进制数时，你不要告诉我你会拿出笔纸或掰手指算半天才知道它转化成十进制的数值。要想快，那就记下下面几种常见的二进制–十进制转换： 以8位 来演示: 1.第一种: 00000001 1 00000010 2 00000100 4 00001000 8 00010000 16 00100000 32 01000000 64 10000000 128 2.第二种： 00000001 1 00000011 3 00000111 7 00001111 15 00011111 31 00111111 63 01111111 127 3.第三种： 10000000 128 11000000 192 11100000 224 11110000 240 11111000 248 11111100 252 11111110 254 举个例子： 11101011 可分为： 11100000（上面第三种类型） 224 00001000（上面第一种类型） 8 00000011（上面第二种类型） 3我们通过记住上面三种类型的转换，再用加 法（加法口算你会吧）立即得到结果：235 ================================================================================== 方法二： 熟记以下排列，其实很Easy了，从右往 左，依次是前一个数的2倍： 256 128 64 32 16 8 4 2 1 随便写个数字比如48 48 = 32 + 16,所以在32 和 16所在的位置为1，其余为0， 转为2进制就是 256 128 64 32 16 8 4 2 1 0 0 0 1 1 0 0 0 0 二进制转十进制就更简单了， 比如随便写的一串 01111101 先写上 ： 0 1 1 1 1 1 0 1 然后填充 128 64 32 16 8 4 2 1 十进制为 64+32+16+8+4+1=125 转载地址：http://blog.163.com/kongdelu2009@yeah/blog/static/111995207201037105051259/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二进制</tag>
        <tag>十进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java移位操作符]]></title>
    <url>%2F2019%2F08%2F04%2FJava%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java移位操作符 移位运算符和按位运算符一样，同属于位运算符，因此移位运算符的位指的也是二进制位。它包括以下几种：1.左移位（&lt;&lt;）：将操作符左侧的操作数向左移动操作符右侧指定的位数。移动的规则是在二进制的低位补0。 2.有符号右移位（&gt;&gt;）：将操作符左侧的操作数向右移动操作符右侧指定的位数。移动的规则是，如果被操作数的符号为正，则在二进制的高位补0；如果被操作数的符号为负，则在二进制的高位补1。 3.无符号右移位（&gt;&gt;&gt;）：将操作符左侧的操作数向右移动操作符右侧指定的位数。移动的规则是，无论被操作数的符号是正是负，都在二进制位的高位补0。 再来考虑一种情况，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，结果会是怎样呢？1、byte、short、char在做移位运算之前，会被自动转换为int类型，然后再进行运算。 2、byte、short、int、char类型的数据经过移位运算后结果都为int型。 3、long经过移位运算后结果为long型。 4、在左移位（&lt;&lt;）运算时，如果要移位的位数大于被操作数对应数据类型所能表示的最大位数，那么先将要求移位数对该类型所能表示的最大位数求余后，再将被操作数移位所得余数对应的数值，效果不变。比如1&lt;&lt;35=1&lt;&lt;(35%32)=1&lt;&lt;3=8。 5、对于有符号右移位（&gt;&gt;）运算和无符号右移位（&gt;&gt;&gt;）运算，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，那么先将要求移位数对该类型所能表示的最大位数求余后，再将被操作数移位所得余数对应的数值，效果不变。。比如100&gt;&gt;35=100&gt;&gt;(35%32)=100&gt;&gt;3=12。 在编程思想中有这么一句话：”移位“可与”等号“（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）组合使用但是在进行这样的移位赋值操作时，可能会遇到一个问题：如果byte或short值进行这样的移位运算，得到的可能不是正确的结果。 它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。 12345678910111213141516171819202122232425public class Test&#123; public static void main(String[] args) &#123; int i = -1; System.out.println(Integer.toBinaryString(i)); i &gt;&gt;&gt;=10; System.out.println(Integer.toBinaryString(i)); long l = -1; System.out.println(Long.toBinaryString(l)); l &gt;&gt;&gt;= 10; System.out.println(Long.toBinaryString(l)); short s = -1; System.out.println(Integer.toBinaryString(s)); s &gt;&gt;&gt;= 10; System.out.println(Integer.toBinaryString(s)); byte b = -1; System.out.println(Integer.toBinaryString(b)); b &gt;&gt;&gt;= 10; System.out.println(Integer.toBinaryString(b)); b = -1; System.out.println(Integer.toBinaryString(b)); System.out.println(Integer.toBinaryString(b&gt;&gt;&gt;10)); &#125;&#125; 运行及结果：111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 运行会发现s&gt;&gt;&gt;=10和b&gt;&gt;&gt;=10的输出结果是错误的。而没有赋值的b&gt;&gt;&gt;=10的输出正确。 内容转载于 http://blog.sina.com.cn/s/blog_6ca0f5eb0102vlha.html晚上纠结了很久这个问题，不懂为什么低5位才有用，怎么就2^5等于32位，跟int的32位挂上钩了，思考了很久终于明白了。 这段话有两个出处，一个是Java编程思想3.11移位操作符中出现，原话是“只有数值右端的低5位才有用”。一个是Java解惑中谜题27：变幻莫测的i值，原话是“移位操作符只使用其右操作数的低5位作为移位长度”。 弄清这句话首先需要弄清楚移位操作符，移位操作符是一个二元操作符，两个操作数分别位于移位操作两边形如：左操作数 移位操作符 右操作数 这样的结构，其含义是，将左操作数按照移位操作符指定的移位方向，进行右操作数指定的次数的移位。然后对照出处二，Java解惑中所描述的，就豁然开朗了。 首先，移位操作符能操作的数只有int类型和long类型，这个是指左操作数的类型。对于int类型而言，int在Java中占4字节，一共32位，也就是说，对于一个在Java中的int数据，做32次移位，那么这个int数据就完全变了，以左移为例，左移是补0，那么对于任意一个int类型数据，做32次移位，那么int数据变成32位全0的数据，Java不允许一次性移位左操作数的所有位，也就是右操作数不能大于32。于是回到上述的句子，其指的是右操作数的低5位，5位二进制所代表的最大值为2^5-1，为31，所以取右操作数的低5位，就是只看右操作数的二进制的低5位，其数值不会超过2^5次方，也就是int的32位。因此，移位操作符进行移位的实际次数，其实是右操作数2的次数。 对于Java编程思想中的翻译，“只有数值右端的低5位才有用”，真是莫名其妙了。其英语原文为：Only the five low-order bits of the right-hand side will be used.看到英文原文，可就明白了这句话的意思，鉴于现在的英译中的书籍参差不齐，建议阅读的时候配一本英文版的电子书在手边以备不时之需。 简而言之，移位操作符执行的次数，只取右操作数的低5位（其数值不会大于2^5=32，也就是移位次数不会超过32位，因为32位是int型的位数）作为移位的次数。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
        <tag>移位操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integer和int的区别]]></title>
    <url>%2F2019%2F08%2F04%2FInteger%E5%92%8Cint%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Integer和int的区别 内容转载于 https://www.cnblogs.com/guodongdidi/p/6953217.html Integer是int的包装类，int则是java的一种基本数据类型 Integer变量必需实例化后才能使用，而int变量不需要 Integer实际是对象的引用，当new一个integer时，实际上是生成一个指针指向对象；而int则是直接存储数据值 Integer的默认值是null，int的默认值是0 延伸：关于Integer和int的比较1.由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false 2.Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） Integer i = new Integer(100);int j = 100;System.out.print(i == j); //true 3.非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 4.对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false Integer i = 100;Integer j = 100;System.out.print(i == j); //true Integer i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因：java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下： 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= &gt;IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Integer</tag>
        <tag>int</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负数的二进制表示]]></title>
    <url>%2F2019%2F08%2F04%2F%E8%B4%9F%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[了解负数的二进制表示 计算机中，负数以其正值的补码形式表示 比如2的二进制为10，但int类型的数占用4字节（32位），就写为00000000 00000000 00000000 00000010 求-2的二进制就要求出原码、补码、反码 原码：将整数的绝对值大小转换为二进制，称为原码。 00000000 00000000 00000000 00000010 反码：将原码按位取反，所得为反码。（1变0，0变1）。 11111111 11111111 11111111 11111101 补码：反码加1为补码。 11111111 11111111 11111111 11111110 -2的二进制为11111111 11111111 11111111 11111110]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java短路与]]></title>
    <url>%2F2019%2F08%2F04%2FJava%E7%9F%AD%E8%B7%AF%E4%B8%8E%2F</url>
    <content type="text"><![CDATA[Java短路与 Java中使用逻辑操作符时遇到的短路现象123456789101112131415161718192021222324// &amp;&amp;短路与public class ShortCircuit&#123; static boolean test1(int val) &#123; System.out.println(&quot;test(&quot;+val+&quot;)&quot;); System.out.println(&quot;result: &quot;+(val&lt;1)); return val&lt;1; &#125; static boolean test2(int val) &#123; System.out.println(&quot;test(&quot;+val+&quot;)&quot;); System.out.println(&quot;result: &quot;+(val&lt;2)); return val&lt;2; &#125; static boolean test3(int val) &#123; System.out.println(&quot;test(&quot;+val+&quot;)&quot;); System.out.println(&quot;result: &quot;+(val&lt;3)); return val&lt;3; &#125; public static void main(String[] args) &#123; boolean b=test1(0)&amp;&amp;test2(2)&amp;&amp;test3(2); System.out.println(&quot;expression is &quot;+b); &#125;&#125; 运行及结果：test(0)result: truetest(2)result: falseexpression is false 可以发现test1与test2比较后直接输出，不会对test3进行比较，这就是&amp;和&amp;&amp;的不同之处。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想第三章练习]]></title>
    <url>%2F2019%2F08%2F04%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Java编程思想第三章练习 第三章练习5：创建一个名为Dogde类，它包含两个String域：name和scruffy（它的叫声为“Ruff!”）,另一个名为scruffy（它的叫声为“Wurf！”）。然后显示它们的名字和叫声。练习6：创建一个新的Dog索引，并对其赋值为spot对象。测试用==和equals()方法比较所有引用的结果。 123456789101112131415161718192021222324252627class Dog&#123; String name; String says; void shows() &#123; System.out.println(&quot;name: &quot;+name+&quot; Says: &quot;+says); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Dog spot = new Dog(); spot.name=&quot;Spot&quot;; spot.says=&quot;Ruff!&quot;; Dog scruffy = new Dog(); scruffy.name=&quot;Sruffy&quot;; scruffy.says=&quot;Wufrf!&quot;; spot.shows(); scruffy.shows(); Dog newDog = new Dog(); newDog = spot; System.out.println(newDog==spot); System.out.println(newDog.equals(spot)); &#125;&#125; 运行及结果：name: Spot Says: Ruff!name: Sruffy Says: Wufrf!truetrue 练习7：编写一个程序，模拟扔硬币的结果。 12345678910111213import java.util.Random;class Coin&#123; static void test() &#123; Random r = new Random(); System.out.println(r.nextInt(2) == 1?&quot;正面&quot;:&quot;反面&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Coin.test(); &#125;&#125; 练习8：展示用16进制和8进制记数法（字面值）来操作long值（赋值），用Long.toBinaryString()来显示其结果。 123456789public class Test&#123; public static void main(String[] args) &#123; long l1=0xC2B; long l2=0777; System.out.println(Long.toBinaryString(l1)); System.out.println(Long.toBinaryString(l2)); &#125;&#125; 练习9：分别显示用float和double指数计数法所能表示的最大和最小的数字 1234567891011121314public class Test&#123; public static void main(String[] args) &#123; float floatmax = Float.MAX_VALUE; float floatmin = Float.MIN_VALUE; double doublemax = Double.MAX_VALUE; double doublemin = Double.MIN_VALUE; System.out.println(&quot;floatmax = &quot; + floatmax); System.out.println(&quot;floatmin = &quot; + floatmin); System.out.println(&quot;doublemax = &quot; + doublemax); System.out.println(&quot;doublemin = &quot; + doublemin); &#125;&#125; 运行及结果：floatmax = 3.4028235E38floatmin = 1.4E-45doublemax = 1.7976931348623157E308doublemin = 4.9E-324 练习10：编写一个具有两个常量值的程序,一个具有交替的二进制位1和0,其中最低有效位为0,另一个也具有交替的二进制位1和0,其中最低有效位为1.取这两个值,用按位操作符以所有可能的方式结合运算它们,然后用Integer.toBinaryString()显示 123456789101112131415161718public class Test&#123; public static void main(String[] args) &#123; int a = 0xaaaaaaaa; int b = 0x55555555; System.out.println(&quot; a: &quot;+Integer.toBinaryString(a)); System.out.println(&quot; b: &quot;+Integer.toBinaryString(b)); System.out.println(&quot; ~a: &quot;+Integer.toBinaryString(~a)); System.out.println(&quot; ~b: &quot;+Integer.toBinaryString(~b)); System.out.println(&quot;a&amp;a: &quot;+Integer.toBinaryString(a&amp;a)); System.out.println(&quot;a|a: &quot;+Integer.toBinaryString(a|a)); System.out.println(&quot;a^a: &quot;+Integer.toBinaryString(a^a)); System.out.println(&quot;a&amp;b: &quot;+Integer.toBinaryString(a&amp;b)); System.out.println(&quot;a|b: &quot;+Integer.toBinaryString(a|b)); System.out.println(&quot;a^b: &quot;+Integer.toBinaryString(a^b)); &#125;&#125; 运行及结果： a: 10101010101010101010101010101010 b: 1010101010101010101010101010101~a: 1010101010101010101010101010101~b: 10101010101010101010101010101010a&amp;a: 10101010101010101010101010101010a|a: 10101010101010101010101010101010a^a: 0a&amp;b: 0a|b: 11111111111111111111111111111111a^b: 11111111111111111111111111111111 练习11：以一个最高有效位为1的二进制数开始,用有符号右移操作符对其进行右移,直至所有的二进制位都被移出为止,每移一位都显示二进制字符串效果.练习12：以一个所有位都为1的二进制数字开始,先左移它,然后用无符号右移操作符对其进行右移,直至所有二进制位都移出为止,每移一位都要显示二进制字符串效果. 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; int number = 0xaaaaa; while(number != 0) &#123; number &gt;&gt;= 1; System.out.println(Integer.toBinaryString(number)); &#125; System.out.println(&quot;====================&quot;); int number2 = 0xff; number2 &lt;&lt;= 1; while(number2 != 0) &#123; number2 &gt;&gt;&gt;= 1; System.out.println(Integer.toBinaryString(number2)); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031运行及结果：10101010101010101011010101010101010101010101010101010110101010101010101010101010101011010101010101010101010101011010101010101010101010110101010101010101011010101010101011010101010110101011010====================1111111111111111111111111111111111110 练习13：编写一个方法,它以二进制形式显示char类型的值.使用多个不同的字符来展示它. 12345678910111213class TestChar&#123; static void Conversion(char c) &#123; System.out.println(Integer.toBinaryString((int)c)); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; TestChar.Conversion(&apos;a&apos;); TestChar.Conversion(&apos;b&apos;); TestChar.Conversion(&apos;c&apos;); TestChar.Conversion(&apos;$&apos;); &#125;&#125; 运行及结果：110000111000101100011100100]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中对象的赋值]]></title>
    <url>%2F2019%2F08%2F03%2FJava%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[记录以下学习Java对象赋值中出现的问题 在java中赋值使用操作符“=”。意思是“取右边的值，把它赋值给左边”。右值可以是任何常数、变量或者表达式（只要能生成一个值）。但左边必须是一个明确的、已命名的变量。但是不能把任何东西赋值给一个常数，常数不能作为左值（比如不能4=a;）。基本数据类型的赋值是直接将一个地方的内容复制到了另一个地方。例如，a=b,b的内容复制给a。接着又修改了a，而b并不会受a修改的影响。 但在为对象赋值的时候，情况却不一样。对一个对象进行操作时，我们真正操作的是对对象的引用。 123456789101112131415161718192021class Tank&#123; int level;&#125;public class Test&#123; public static void main(String[] arg) &#123; Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 9; t2.level = 47; System.out.println(&quot;1: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level); t1 = t2; System.out.println(&quot;2: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level); t1.level = 27; System.out.println(&quot;3: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level); &#125;&#125;/*Output:1: t1.level: 9,t2.level: 472: t1.level: 47,t2.level: 473: t1.level: 27,t2.level: 27*///:~ 每个Tank类对象的level域都赋予了一个不同的值，然后，将t2赋给t1。我们可能会期望t1和t2总是相互独立的。但由于赋值操作的是一个对象的引用，t1和t2包含的引用相同,所以修改t1的同时也改变了t2。这种特殊现象称为”别名现象“。 避免方式：t1.level = t2.level; 方法调用中的别名问题12345678910111213141516class Tank&#123; char c;&#125;public class Test&#123; static void f(Tank y) &#123; y.c = &apos;z&apos;; &#125; public static void main(String[] arg) &#123; Tank t = new Tank(); t.c = &apos;a&apos;; System.out.println(&quot;1: t.c: &quot; + t.c); f(t); System.out.println(&quot;2: t.c: &quot; + t.c); &#125;&#125; 运行及结果：1: t.c: a2: t.c: z]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中局部变量的初始化问题]]></title>
    <url>%2F2019%2F08%2F02%2Fjava%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[java中局部变量的初始化问题 Java中局部变量必须初始化但成员变量不必须初始化其实无论成员变量还是局部变量都要初始化，只是JVM帮我们初始化了成员变量。 JVM在初始化对象时就可以初始化成员变量。 在类的加载中，我们定义的成员变量进行了两次初始化，一次赋默认初值（0值，boolean赋为false），一次赋自定义的初值。而对于方法中的局部变量，需要进栈执行，这个过程是没有赋初值过程的。 还有种情况为：定义的局部变量没有赋值，也没有报错，是因为局部变量没有被调用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>局部变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql数据备份与还原]]></title>
    <url>%2F2019%2F07%2F21%2FMysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[Mysql数据备份与还原 数据备份 1.整库备份 利用mysqldump进行sql备份 语法：mysqldump.exe -hPup 数据库名字 &gt; 备份路径 mysqldump.exe -hlocalhost -P3306 -uroot -proot mydatabase C:/server/mydatabase.sql2.单表备份 语法：mysqldump.exe -hPup 数据库名字 表名 &gt; 备份路径 mysqldump -uroot -proot mydatabase my_int &gt; c:/server/int.sql3.多表备份 语法：mysqldump.exe -hPup 数据库名字 表名 表名 .. &gt; 备份路径 mysqldump -uroot -proot mydatabase my_student my_int &gt; c:/server/student_int.sq 数据还原 1.利用mysql.exe客户端 在cmd中直接对数据还原 语法：mysql -hPup 数据库 &lt; 文件路径 mysql -uroot -proot mydatabse &lt; c:/server/mydatabase.sql2.利用sql指令 登录mysql客户端并进入对应数据库 语法：source 文件路径（注意后面会有； 因为这里是在mysql中输入的sql指令） source c:/server/int.sql;3.复制粘贴]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客文章添加图片、音乐、视频]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[博客文章添加图片、音乐、视频 首先修改配置_config.yml 将post_asset_folder: false改为post_asset_folder: true 然后安装一个图片插件1npm install https://github.com/CodeFalling/hexo-asset-image -- save 新建一个博文后就会发现在/source/_posts目录下会生成同名文件夹将图片扔里面 添加本地图片 在博文中插入代码： 1![图片描述](文件夹/h1.jpg) 例: 添加外部连接1![图片描述](图片地址) 例: 插入音乐直接粘贴代码到博文： 123&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=5263408&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; 插入视频直接粘贴代码到博文： 12345&lt;iframe height=300 width=510 src=&quot;视频链接&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天天气真好 好就好在好个锤子]]></content>
  </entry>
</search>
