<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java对Mysql进行增删改查]]></title>
    <url>%2F2019%2F12%2F25%2FJava%E5%AF%B9Mysql%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[在Eclipse环境下创建一个Java项目Exam01,导入-个MySQL数据库驱动文件。在默认路径下创建一个名为Exam01的类。要求在类中实现: 1.注册数据库驱动。2.创建连接对象，连接数据 库xxgc(已经在MySQL数据 库中创建完成，用户名root, 密码123456)。3.通连接对象connection创 建执行对象statement4.创建一-个名叫xxxx的表5.插入以下三个字段6.查询三个字段，在控制台 上显示结果7.删除表格xxxx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.sql.*;public class Exam01 &#123; public static void main(String[] args) &#123; try &#123; //注册数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); System.out.println(&quot;数据库驱动加载成功&quot;); //创建连接对象，连接数据库 Connection con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:端口号3306/xxgc&quot;,&quot;root&quot;,&quot;123456&quot;); //实现SQL语句的执行 Statement state = con.createStatement(); //创建表 String sql = &quot;create table test(name varchar(10),number int(5),ssex varchar(5))&quot;; state.executeUpdate(sql); System.out.println(&quot;表创建成功&quot;); //向表内插入数据 String sql2 = &quot;insert into test values(&apos;Potato&apos;,11,&apos;雄&apos;)&quot;; state.executeUpdate(sql2); System.out.println(&quot;数据插入成功&quot;); //使用ResultSet保存查询所得结果，使用while语句循环打印到控制台 ResultSet rs = state.executeQuery(&quot;select * from test&quot;); while(rs.next()) &#123; String name = rs.getString(&quot;name&quot;); int number = rs.getInt(&quot;number&quot;); String ssex = rs.getString(&quot;ssex&quot;); System.out.print(&quot;name：&quot;+name); System.out.print(&quot;，number：&quot;+number); System.out.print(&quot;,ssex：&quot;+ssex); System.out.println(); &#125; //删除数据表 String sql3=&quot;drop table test&quot;; state.executeUpdate(sql3); System.out.println(&quot;删除成功&quot;); &#125; catch (ClassNotFoundException e) &#123; System.out.println(&quot;数据库连接失败&quot;); // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO 自动生成的 catch 块 System.out.println(&quot;SQL语句异常&quot;); e.printStackTrace(); &#125; &#125;&#125;/*Output:数据库驱动加载成功表创建成功数据插入成功name：Potato，number：11,ssex：雄删除成功*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网上花店]]></title>
    <url>%2F2019%2F10%2F13%2F%E7%BD%91%E4%B8%8A%E8%8A%B1%E5%BA%97%2F</url>
    <content type="text"><![CDATA[网上花店 源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style03.css&quot; type=&quot;text/css&quot; /&gt; &lt;title&gt;网上花店&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--heaer begin--&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;&lt;strong&gt;彼岸の花&lt;/strong&gt; &lt;em&gt;偏安一隅 静静生活&lt;/em&gt;&lt;/h1&gt; &lt;hr size=&quot;2&quot; color=&quot;#dldldl&quot; width=&quot;980px&quot;/&gt; &lt;/div&gt; &lt;!--heaer end--&gt; &lt;!--fenlei begin--&gt; &lt;div class=&quot;fenlei&quot;&gt; &lt;h2&gt;商品分类 &amp;gt;&lt;/h2&gt; &lt;img src=&quot;images/banner.jpg&quot; alt=&quot;网上花店&quot;/&gt; &lt;br /&gt;&lt;br /&gt; &lt;p&gt;我喜欢一些花儿，静静地开放，从不声张。小小的花朵，有着异样地芬芳...&lt;/p&gt; &lt;p&gt;I love flowers,quietly open,never quiet.Little flowers,with the same fragrance...&lt;/p&gt; &lt;br /&gt; &lt;/div&gt; &lt;!--fenlei end--&gt; &lt;!--bestseller begin--&gt; &lt;div class=&quot;bestseller&quot;&gt; &lt;img src=&quot;images/bestseller1.png&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt; &lt;img src=&quot;images/bestseller2.jpg&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;&lt;br /&gt; &lt;p class=&quot;txt&quot;&gt;多肉植物是指植物营养器官肥大地高等植物，通常具根、茎、叶三种营养器官和花、果实、种子三种繁殖器官。在园艺上，又称肉质植物或多肉花，但以多肉植物这个名称最为常用。&lt;/p&gt; &lt;p class=&quot;txt&quot;&gt;&lt;em&gt;全世界共有多肉植物一万余种&lt;/em&gt;，它们绝大部分属于高等植物（绝大多数是被子植物）。植物上隶属几十个科，个别专家认为有67个科中含有多肉植物，但大多数专家认为只有50余科。&lt;/p&gt; &lt;br /&gt; &lt;/div&gt; &lt;!--bestseller end--&gt; &lt;!--footer begin--&gt; &lt;div class=&quot;shouhou&quot;&gt; 品质保障&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;七天无理由退换货&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;特色服务体验&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;帮助中心 &lt;br /&gt;&lt;br /&gt; &lt;/div&gt; &lt;div class=&quot;boss&quot;&gt; &lt;img src=&quot;images/tuxiang.gif&quot; alt=&quot;网上花店&quot; align=&quot;left&quot; /&gt; &lt;h3&gt;店主：Michael_唐僧&lt;/h3&gt; &lt;p&gt;飞舞的花儿像一首诗 ?写着秋天的心事 ?带着相思 ?轻轻、轻轻 ?飘向大地 ?&lt;/p&gt; &lt;p&gt;也许这只是秋季里的一场游戏 ?&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;/div&gt; &lt;!--footer end--&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类之闭包与回调]]></title>
    <url>%2F2019%2F09%2F18%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B8%8E%E5%9B%9E%E8%B0%83%2F</url>
    <content type="text"><![CDATA[闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。闭包广泛用于回调函数、函数式编程中。在JAVA中，闭包是通过“接口+内部类”实现，JAVA的内部类也可以有匿名内部类。 什么是闭包：闭包是指在匿名内部类，能够访问外部类的全部变量和方法，换句话说，就是这个类里面含有外部类的相关信息，能够调用到外部类中的全部属性和方法 闭包能够保护内部类里面的变量安全，不会被外部访问 闭包能够维持一个变量一直存活在内存中，不被CG（垃圾回收机制）回收掉 什么是回调:回调直接理解就是回头调用，先将相关的方法实现好，但是并不由我来决定什么时候来调用它，而是等到一个时候，程序自己回头调用这个方法，而实现回调机制，这可以说是一种设计模式，而不仅仅是一个语言上的特性 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263interface Incrementable&#123; void increment();&#125;class Callee1 implements Incrementable&#123; private int i = 0; public void increment()&#123; i++; System.out.println(i); &#125;&#125;class MyIncrementable &#123; public void increment()&#123; System.out.println(&quot;Other Operarion&quot;); &#125; static void f(MyIncrementable mi)&#123; mi.increment(); &#125;&#125;class Callee2 extends MyIncrementable&#123; private int i = 0; public void increment()&#123; super.increment(); i++; System.out.println(i); &#125; private class Closure implements Incrementable&#123; public void increment()&#123; Callee2.this.increment(); &#125; &#125; Incrementable getCallbackReference()&#123; return new Closure(); &#125;&#125;class Caller&#123; private Incrementable callbackReference; Caller(Incrementable cbn)&#123; callbackReference = cbn; &#125; void go()&#123; callbackReference.increment(); &#125;&#125;public class Callbacks &#123; public static void main(String[] args)&#123; Callee1 c1 = new Callee1(); Callee2 c2 = new Callee2(); MyIncrementable.f(c2); Caller caller1 = new Caller(c1); Caller caller2 = new Caller(c2.getCallbackReference()); caller1.go(); caller1.go(); caller2.go(); caller2.go(); &#125;&#125;/*Output:Other Operarion112Other Operarion2Other Operarion3*///:~ Callee1方法实现了接口Incrementable，在这里和下面做对比。在MyIncrement类中同样有一个increment()方法，但是这个方法与接口Incrementable中的方法没有关系。 Callee2继承了MyIncrement类，并且覆盖了父类的increment()方法。 接下里是一个内部类也就是闭包的具体实现了。内部类实现了接口Incrementable并且直接调用外部类的方法作为具体的实现。内部类实现Increment able接口很关键，这样就给外部留下了一个通道，能够接受这个内部类。 最后Callee2的后面留下了一个钩子，即getCallbackReference()方法，它返回一个内部类的对象，实现了内部与外部的链接，同时有保证了内部类的安全，因为只有Callee2的对象可以访问与调用这个内部类的方法，而其他的类都无权访问，即使是基类接口对象。而后面的Caller类起到的是一个唤醒作用，通过接受不同的接口对象，实现不同的操作，但还有一个作用是等待接受一个内部类对象，来产生回调。 在main()方法中，首先是创建对象与声明，然后是调用了一个MyIncrement的静态方法，传入的是一个Callee2对象，此时无法触发回调，所以只是正常的输出，然后，才Caller2的初始化时传入的是一个Closure对象从而产生了回掉。 参考 Java—内部类（二）—实现闭包与回调]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>闭包</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github个人博客：绑定二级域名]]></title>
    <url>%2F2019%2F09%2F15%2FGithub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9A%E7%BB%91%E5%AE%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[Github个人博客：绑定二级域名 购买域名，实名认证购买的阿里云的域名，绑定博客可以不需要备案的。 CNAME设置在blog/source目录下，新建名为CNAME的文件，没有后缀，添加blog.hongxigua.xyz 也可以直接编辑github中的文件 设置GitHub Pages进入博客的管理设置 向下拉会出现GitHub Pages设置的选项 Custom domain添加： blog.hongxigua.xyz 域名解析在域名后选择解析 出现解析设置 添加记录： 记录类型: CNAME- 将域名指向另外一个域名主机记录： blog解析路线：可默认记录值：yayaya99.github.ioTTL：10 (选择A时主机记录为www，记录值为ip地址，可通过pign博客的二级域名看到) 确定保存]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名内部类是否可以继承其它类，是否可以实现接口]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E5%AE%83%E7%B1%BB%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[匿名内部类是否可以继承其它类，是否可以实现接口 匿名内部类：必须继承一个父类或实现一个接口 实例1：不使用匿名内部类来实现抽象方法 1234567891011121314abstract class Person&#123; public abstract void eat();&#125;class Child extends Person&#123; public void eat()&#123; System.out.println(&quot;eat something&quot;); &#125;&#125;public class Demo&#123; public static void main(String[] args)&#123; Person p = new Child(); p.eat(); &#125;&#125; 运行结果：eat something 可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用 但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？ 这个时候就引入了匿名内部类 实例2：匿名内部类的基本实现 123456789101112131415abstract class Person &#123; public abstract void eat();&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; @Override //此处方法重载 说明是实现父类 即内部类可以继承其他类 而且是必须 public void eat() &#123; System.out.println(&quot;eat something&quot;); &#125; &#125;; p.eat(); &#125;&#125; 运行结果：eat something 可以看到，我们直接将抽象类Person中的方法在大括号中实现了 这样便可以省略一个类的书写 并且，匿名内部类还能用于接口上 实例3：在接口上使用匿名内部类 123456789101112131415interface Person &#123; public void eat();&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; @Override //此处方法重载 说明是实现父类 即内部类可以实现其他类 而且是必须 public void eat() &#123; System.out.println(&quot;eat something&quot;); &#125; &#125;; p.eat(); &#125;&#125; 运行结果：eat something 由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现 最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java嵌套类]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E5%B5%8C%E5%A5%97%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java嵌套类 如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为其嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它地外围类对象。然而，当内部类是static的时，就不是这样了。嵌套类意味着： 1、要创建嵌套类的对象，并不需要外围类的对象。 2、不能从嵌套类的对象中访问非静态的外围类对象。 嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西： 123456789101112131415161718192021222324252627282930313233public class Parcel11&#123; private static class ParcelContents implements Contents&#123; private int i = 11; @Override public int value() &#123;return i;&#125; &#125; protected static class ParcelDestination implements Destination&#123; private String label; private ParcelDestination(String whereTo) &#123; label = whereTo; &#125; @Override public String readLabel() &#123; return label; &#125; public static void f() &#123;&#125; static int x = 10; static class AnotherLevel&#123; public static void f() &#123;&#125; static int x = 10; &#125; &#125; public static Destination destination(String s) &#123; return new ParcelDestination(s); &#125; public static Contents contents() &#123; return new ParcelContents(); &#125; public static void main(String[] args) &#123; Contents c = contents(); Destination d = destination(&quot;Tasmania&quot;); &#125;&#125; 在main()中，没有任何Parcel11的对象是必需的；而是使用选取static成员的普通语法来调用方法——这些方法返回对Contents和Destination的引用。 就像你在本章前面看到的那样，在一个普通的（非static）内部类中，通过一个特殊的this引用可以链接到其外围类对象。嵌套类就没有这个特殊的this的引用，这使得它类似于一个static方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>嵌套类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java匿名内部类实现工厂化生产]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%8E%82%E5%8C%96%E7%94%9F%E4%BA%A7%2F</url>
    <content type="text"><![CDATA[Java匿名内部类实现工厂化生产 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface Service&#123; void method1(); void method2();&#125;interface ServiceFactory&#123; Service getService();&#125;class Implementation1 implements Service&#123; private Implementation1()&#123;&#125; //构造器私有，禁止new public void method1() &#123;System.out.println(&quot;Implementation1 method1&quot;);&#125; public void method2() &#123;System.out.println(&quot;Implementation1 method2&quot;);&#125; public static ServiceFactory factory = new ServiceFactory() &#123; @Override public Service getService() &#123; return new Implementation1(); &#125; &#125;;&#125;class Implementation2 implements Service&#123; private Implementation2()&#123;&#125; public void method1() &#123;System.out.println(&quot;Implementation2 method1&quot;);&#125; public void method2() &#123;System.out.println(&quot;Implementation2 method2&quot;);&#125; public static ServiceFactory factory = new ServiceFactory() &#123; @Override public Service getService() &#123; return new Implementation2(); &#125; &#125;;&#125;public class Factories&#123; public static void serviceConsumer(ServiceFactory fact) &#123; Service s = fact.getService(); s.method1(); s.method2(); &#125; public static void main(String[] args) &#123; serviceConsumer(Implementation1.factory); serviceConsumer(Implementation2.factory); &#125;&#125;/*Output:Implementation1 method1Implementation1 method2Implementation2 method1Implementation2 method2*///:~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455interface Game&#123;boolean move();&#125;interface GameFactory&#123;Game getGame();&#125;class Checkers implements Game&#123; private Checkers() &#123;&#125; private int moves = 0; private static final int MOVES = 3; @Override public boolean move() &#123; System.out.println(&quot;Checkers move &quot;+moves); return ++moves!=MOVES; &#125; public static GameFactory factory = new GameFactory() &#123; @Override public Game getGame() &#123; // TODO 自动生成的方法存根 return new Checkers(); &#125; &#125;;&#125;class Chess implements Game&#123; private Chess() &#123;&#125; private int moves = 0; private static final int MOVES =4; @Override public boolean move() &#123; System.out.println(&quot;Chess mpve &quot;+moves); return ++moves!=MOVES; &#125; public static GameFactory factory = new GameFactory() &#123; @Override public Game getGame() &#123; // TODO 自动生成的方法存根 return new Chess(); &#125; &#125;;&#125;public class Games&#123; public static void playGame(GameFactory factory) &#123; Game s = factory.getGame(); while(s.move()) ; &#125; public static void main(String[] args) &#123; playGame(Checkers.factory); playGame(Chess.factory); &#125;&#125;/*Output:Checkers move 0Checkers move 1Checkers move 2Chess mpve 0Chess mpve 1Chess mpve 2Chess mpve 3*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中类名+方法名（）{}什么意思]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E4%B8%AD%E7%B1%BB%E5%90%8D-%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%88%EF%BC%89-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%2F</url>
    <content type="text"><![CDATA[发现问题并解决它 1234567891011121314public class Parcel7b&#123; class MyContents implements Contents&#123; private int i = 11; public int value() &#123;return i;&#125; &#125; public Contents contents() &#123; //1 return new MyContents(); &#125; public static void main(String[] args) &#123; Parcel7b p = new Parcel7b(); Contents c = p.contents(); &#125;&#125; 在代码1处，使用了类名+方法名的方式创建方法，这样写有什么用？ —————————–分隔符————————————————————————————————————————————————————— 意思是这个方法的返回类型是某个类的实例。 上面的这种创建方式，说明此方法返回的是Contents的一个实例（对象） 那有什么好处？ 可以通过类名+方法名调用的方法叫静态方法，属于类级别方法，类方法可在不实例化对象的前提下调用，一般类的静态方法和静态变量都是通过static关键字修饰的，而且静态方法体里不能应用任何实例变量和实例方法。至于你那段程序，调用那个方法和new一个对象效果是一样的。不过只是把实例的创建封装在方法里，通过类名加方法来调用而已,让实例化代码简洁点外，无任何差别。不过，有些时候，有些类的设计，出于某种需要，不希望类的构造方法是public的，也就是用户无法直接new出来的，通常就会通过这么一个静态方法来调用获取实例。而且这些方法体里除了直接return 一个实例之外，可能还会做某些处理,这在java里许多类都有这种设计。如，j2me中的Image类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中静态代码块、构造代码块、构造函数、普通代码块]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%99%AE%E9%80%9A%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[转自 https://www.cnblogs.com/ysocean/p/8194428.html 静态代码块1、Java类中（方法中不能存在静态代码块） 12345public class Test&#123; static&#123; System.out.println(&quot;静态代码块&quot;); &#125;&#125; 2、执行时机 静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照书写顺序一次执行。 3、静态代码块的作用 一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。比如一个项目启动需要加载的很多配置文件等资源，我们就可以都放进静态代码块中。 4、静态代码块不能存在任何方法体中 这个应该很好理解，首先我们要明确静态代码块是在类加载的时候就要运行了。我们分情况讨论： 对于普通方法，由于普通方法是通过加载类，然后new出实例化对象，通过对象才能运行这个方法，而静态代码块只需要加载类之后就能运行了。 对于静态方法，在类加载的时候，静态方法也已经加载了，但是我们必须要通过类名或者对象名才能访问，也就是说相比于静态代码块，静态代码块是主动运行的，而静态方法是被动运行的。 不管是哪种方法，我们需要明确静态代码块的存在在类加载的时候就自动运行了，而放在不管是普通方法还是静态方法中，都是不能自动运行的。 5、静态代码块不能访问普通变量 这个理解思维同上，普通变量只能通过对象来调用，是不能放在静态代码块中的。 构造代码块1、格式 Java类中使用{}声明的代码块（和静态代码块的区别是少了static关键字）： 123456789public class CodeBlock&#123; static &#123; System.out.println(&quot;静态代码块&quot;); &#125; &#123; System.out.println(&quot;构造代码块&quot;); &#125; &#125; 2、执行时机 构造代码块在创建对象时被调出，每次创建对象都会调用一次，但是优先于构造函数执行。需要注意的是，听听名字我们就知道，构造代码块不是优先于构造函数执行，而是依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的。怎么理解呢？我们看看下面这段代码： 12345678910111213141516171819202122public class Test &#123; &#123; System.out.println(&quot;构造代码块&quot;); &#125; public Test()&#123; System.out.println(&quot;无参构造函数&quot;); &#125; public Test(String st)&#123; System.out.println(&quot;有参构造函数&quot;); &#125; public static void main(String[] args) &#123; new Test(); new Test(&quot;t&quot;); &#125;&#125;/*Output:构造代码块无参构造函数构造代码块有参构造函数*///:~ 如果存在多个构造代码块，则执行顺序按照书写顺序依次执行。 3、构造代码块的作用 和构造函数的作用类似，都能对对象进行初始化，并且只要创建一个对象，构造代码块都会执行一次。但是反过来，构造函数则不一定每个对象建立时都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数）。 利用每次创建对象的时候都会提前调用一次构造代码块特性，我们可以做诸如统计创建对象的次数等功能。 构造函数1、构造函数的命名必须和类名完全相同。在java中普通函数可以和构造函数同名，但是必须带有返回值； 2、构造函数的功能主要用于在类的对象创建时定义初始化的状态。它没有返回值，也不能用void来修饰。这就保证了它不仅什么也不用自动返回，而且根本不能有任何选择。而其他方法都有返回值，即使是void返回值。尽管方法体本身不会自动返回什么，但仍然可以让它返回一些东西，而这些东西可能是不安全的； 3、构造函数不能被直接调用，必须通过new运算符在创建对象时才会自动调用；而一般的方法是在程序执行到它的时候被调用的； 4、当定义一个类的时候，通常情况下都会显示该类的构造函数，并在函数中指定初始化的工作也可省略，不过Java编译器会提供一个默认的构造函数.此默认构造函数是不带参数的。而一般的方法不存在这一特点； 普通代码块普通代码块和构造代码块的区别是，构造代码块是在类中定义的，而普通代码块是在方法体中定义的。且普通代码块的执行顺序和书写顺序一致。 12345public void sayHello()&#123; &#123; System.out.println(&quot;普通代码块&quot;); &#125;&#125; 执行顺序静态代码块&gt;构造代码块&gt;构造函数&gt;普通代码块 1234567891011121314151617181920212223242526272829303132333435public class CodeBlock &#123; static&#123; System.out.println(&quot;静态代码块&quot;); &#125; &#123; System.out.println(&quot;构造代码块&quot;); &#125; public CodeBlock()&#123; System.out.println(&quot;无参构造函数&quot;); &#125; public void sayHello()&#123; &#123; System.out.println(&quot;普通代码块&quot;); &#125; &#125; public static void main(String[] args) &#123; System.out.println(&quot;执行了main方法&quot;); new CodeBlock().sayHello();; System.out.println(&quot;---------------&quot;); new CodeBlock().sayHello();; &#125;&#125;/*Output:静态代码块执行了main方法构造代码块无参构造函数普通代码块---------------构造代码块无参构造函数普通代码块*///:~ 我们创建了两个匿名对象，但是静态代码块只是调用了一次。 父类和子类执行顺序对象的初始化顺序： 首先执行父类静态内容，父类静态的内容执行完毕后，接着去执行子类的静态的内容，当子类的静态内容执行完毕之后，再去看父类有没有构造代码块，如果有就执行父类的构造代码块，父类的构造代码块执行完毕，接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有构造代码块，如果有就执行子类的构造代码块。子类的构造代码块执行完毕再去执行子类的构造方法。 总之一句话，静态代码块内容先执行，接着执行父类构造代码块和构造方法，然后执行子类构造代码块和构造方法。 123456789101112131415161718192021222324252627282930313233343536373839404142class SuperClass &#123; static&#123; System.out.println(&quot;父类静态代码块&quot;); &#125; &#123; System.out.println(&quot;父类构造代码块&quot;); &#125; public SuperClass()&#123; System.out.println(&quot;父类构造函数&quot;); &#125;&#125;public class SubClass extends SuperClass&#123; static&#123; System.out.println(&quot;子类静态代码块&quot;); &#125; &#123; System.out.println(&quot;子类构造代码块&quot;); &#125; public SubClass()&#123; System.out.println(&quot;子类构造函数&quot;); &#125; public static void main(String[] args) &#123; SubClass sb = new SubClass(); System.out.println(&quot;------------&quot;); SubClass sb1 = new SubClass(); &#125;&#125;/*Output:父类静态代码块子类静态代码块父类构造代码块父类构造函数子类构造代码块子类构造函数------------父类构造代码块父类构造函数子类构造代码块子类构造函数*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>静态代码块</tag>
        <tag>构造代码块</tag>
        <tag>构造函数</tag>
        <tag>普通代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 在方法和作用域内的内部类]]></title>
    <url>%2F2019%2F09%2F15%2FJava-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java 在方法和作用域内的内部类 10.5 在方法和作用域内的内部类 自己很难搞懂一些代码的作用，所以内部类这一章进行的很慢很慢，看的我头大 所以 先mark以下 在知乎上看到了这么一句话： 局部内部类是指内部类定义在方法或作用于内 局部内部类不能有访问说明符 局部内部类可以访问当前代码块内的常量以及此外围类的所有成员 内部类的语法覆盖了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任意的作用域内定义内部类。这么做有两个理由： 1、实现了某个类型的接口，于是可以创建并返回对其的引用。 2、要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。 在后面的例子中，以用来实现： 1、一个定义在方法中的类 2、一个定义在作用域内的类，此作用域在方法的内部 3、一个实现了接口的匿名类 4、一个匿名类，它扩展了有非默认构造器的类 5、一个匿名类，它执行字段初始化 6、一个匿名类，它通过实例化初始化实现构造（匿名类不可能有构造器） 第一个例子展示了在方法的作用域（而不是在其他类的作用域内）创建了一个完整的类。这被称作局部内部类： 12345678910111213141516public class Parcel5&#123; public Destination destination(String s) &#123; class PDestination implements Destination&#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123;return label;&#125; &#125; return new PDestination(s); &#125; public static void main(String[] args) &#123; Parcel5 p = new Parcel5(); Destination d = p.destination(&quot;Tasmania&quot;); &#125;&#125; 代码中内部类PDestination实现了Destination,??? 在网上没有找到这样写的原因，个人不太懂，唉 PDestination类是destination()方法的一部分，而不是Parcel5的一部分。所以，在destination()之外不能访问PDestination。注意出现在return语句中的向上转型——返回的是Destination的引用，它是PDestination的基类。当然，在destination()中定义了内部类PDestination，并不意味着一旦dest()方法执行完毕，PDestination就不可用了。 你可以在同一个子目录下的任意类中对某个内部类使用标识符PDestination，这并不会有命名冲突。 如何在任意的作用域内嵌入一个内部类： 12345678910111213141516171819202122public class Parcel6&#123; private void internalTracking(boolean b) &#123; if(b) &#123; class TrackingSlip&#123; private String id; TrackingSlip(String s)&#123; id = s; &#125; String getSlip() &#123;return id;&#125; &#125; TrackingSlip ts = new TrackingSlip(&quot;slip&quot;); String s = ts.getSlip(); &#125; //Can&apos;t use it here! Out of scope; //!TrackingSlip ts = new TrackingSlip(&quot;x&quot;); &#125; public void track() &#123;internalTracking(true);&#125; public static void main(String[] args) &#123; Parcel6 p = new Parcel6(); p.track(); &#125;&#125; TrackingSlip类被嵌入在if语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义TrackingSlip的作用域之外，它是不可用的；除此之外，它与普通的类一样。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当用protected访问修饰符修饰内部类时会怎样]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%BD%93%E7%94%A8protected%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BF%AE%E9%A5%B0%E5%86%85%E9%83%A8%E7%B1%BB%E6%97%B6%E4%BC%9A%E6%80%8E%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[在第十章的练习6中，遇到了这个问题。 在查找问题时，发现了下面这篇博文，内容通俗易懂，看过之后很受启发，但我文笔不好，所以直接引用过来学习。 哈哈我好无耻。。 转自 https://blog.csdn.net/clarkdu/article/details/334925 12345678910111213141516171819// in SuperClass.javapackage com.duwei.SuperClass; class SuperClass &#123; protected class InnerClass&#123; // 错误根源 &#125;&#125;// in SubClass.javapackage com.duwei.SubClassimport com.duwei.SuperClass.*;class SubClass extends SuperClass &#123; public void func() &#123; InnerClass ic = new InnerClass(); // 导致错误 &#125;&#125; 对protected访问修饰符理解的还不是很深刻的朋友会觉得这没什么程序很正常. 程序行为都很合乎情理. 其实不然, 程序在编译的时候会报错, 错误信息为InnerClass() has protected access in com.duwei.SuperClass.InnerClass. 这是为什么? 我的SuperClass类里的内部类InnerClass已经被定义为protected了, 而且Java保证了被protected所修饰的东西都可以在其子类中使用呀!!! 但, 请再仔细看看错误信息的内容, 原来并不是InnerClass类有什么问题, 而是InnerClass类中的InnerClass()方法出现了问题, InnerClass()这不是InnerClass类的构造函数吗!!! 看来问题找到一半了, 我们在学习Java的时候都知道, 如果一个类没定义任何形式的构造函数时, Java编译器会自动为类加上一个, 但问题就在这, 很多人不会重视这个自动被加上的构造函数的访问级别为何! 不过在此提到了可能大家也就都想起来了, 事实上这个被自动加上的构造函数的访问级别与类相同! 我们在回到刚才的问题上, 这时我们会发现原来InnerClass类在定义时并没有写构造函数, 编译时被自动加入的构造函数访问级别与类相同, 也就是protected. 这时我想大家应该明白为什么程序会出问题了吧!!! 原来在SubClass类中的func()方法里实例化InnerClass类时出了问题, 当然单从InnerClass的访问级别为protected来讲这样做没什么问题, 但实例化就得调用构造函数, 也就是在调用了InnerClass类的构造函数时, 由于这个被编译器自动加上的构造函数沿袭了InnerClass类的访问级别为protected, 所以这个构造函数只能在InnerClass的子类中或者同一个包中被调用, 而此时只是简单的实例化InnerClass类而并不存在什么子类而且又是在另一个包中, 再说Java只允许在同一个类中的内部类继承另一个内部类, 而且这种操作的允许范围仅此而以, 所以问题的终于要水落石出了, 由于InnerClass类的构造函数只允许其子类调用而不允许其它形式的调用, 所以此时对于InnerClass类来讲无法调用其构造函数来实例化对象. 至此问题找到了. 解决问题的方法也很简单, 只要在InnerClass类中定义一个public访问级别的构造函数就可以了. 由此我们可以看出, 有时候程序的某些特征是深藏不露, 如果你不去那样想是很难发现它的. 本文链接：https://blog.csdn.net/clarkdu/article/details/334925]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>protected</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 链接到外部类]]></title>
    <url>%2F2019%2F09%2F15%2FJava-%E9%93%BE%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java 链接到外部类 当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。 内部类还拥有其外围类的所有元素的访问权。 123456789101112131415161718192021222324252627282930313233interface Selector&#123; boolean end();Object current();void next();&#125;public class Sequence&#123; private Object[] items; private int next = 0; public Sequence(int size) &#123;items = new Object[size];&#125; public void add(Object x) &#123; if(next &lt; items.length) items[next++] = x; &#125; private class SequenceSelector implements Selector&#123; private int i = 0; public boolean end() &#123;return i == items.length;&#125; public Object current() &#123;return items[i];&#125; public void next() &#123; if(i &lt; items.length) i++; &#125; &#125; public Selector selector() &#123; return new SequenceSelector(); &#125; public static void main(String[] args) &#123; Sequence sequence = new Sequence(10); for(int i = 0;i&lt;10;i++) &#123;sequence.add(Integer.toString(i));&#125; //1 Selector selector = sequence.selector(); while(!selector.end()) &#123; System.out.print(selector.current()+&quot; &quot;); selector.next(); &#125; &#125;&#125; 程序中在1处的调用是这样写的，sequence.add(Integer.toString(i)，add函数为：public void add(Object x)。这里我有个疑问，如果写成sequence.add(1)结果是一样的，那么那样写是是那么意思呢？ 依照疑问下面引入了网友的回答： 1、sequence.add(Interger.toString(1))表示s里面加入的是个string值，内容是1sequence.add(1)表示s里面加入的是个int数字1因为public void add(Object x)中参数是Object所以string和int都能传入 2、Interger.toString(1) 是把数字用字符串的形式表示出来Object x 是所有java支持的对象sequence.add(1),,因为不管1是数字还是字符,都是java支持的对象所以直接add也可以]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java toString() 方法]]></title>
    <url>%2F2019%2F09%2F15%2FJava-toString-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java toString() 方法 toString()方法用于返回以一个字符串表示的Number对象值。 如果方法使用了原生的数据类型作为参数，返回原生数据类型的String对象值。 如果方法有两个参数，返回用第二个参数指定基数表示的第一个参数的字符串表示形式。 语法以String类为例，该方法有以下几种格式语法： String toString()static String toString(int i) 参数 i–转换的整数 返回值 toString():返回表示Integer值的String对象 toString(int i):返回表示指定int的String对象 实例： 12345678910public class Test&#123; public static void main(String[] args) &#123; Integer x = 5; System.out.println(x.toString()); System.out.println(Integer.toString(12)); &#125;&#125;/*Output:512*///:~ ———————————————————————分割线——————————————————————————————- 以下引自 https://blog.csdn.net/u013309870/article/details/72158054 Integer类的toString的基本用法123456789101112131415161718192021222324252627282930313233public class IntegerDemo&#123; public static void main(String[] args) &#123; Integer OUT_MAX_VALUE = new Integer(Integer.MAX_VALUE); Integer MAX_VALUE = new Integer(Integer.MAX_VALUE); Integer MIN_VALUE = new Integer(Integer.MIN_VALUE); Integer NOR_VALUE = new Integer(-128); Integer OUT_MIN_VALUE = new Integer(Integer.MIN_VALUE); System.out.println(&quot;max_val &quot;+MAX_VALUE.toString()); System.out.println(&quot;max_val :&quot;+MAX_VALUE); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;out_max :&quot;+OUT_MAX_VALUE.toString()); System.out.println(&quot;out_min :&quot;+OUT_MIN_VALUE.toString()); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;min_val :&quot;+MIN_VALUE.toString()); System.out.println(&quot;min_val :&quot;+MIN_VALUE); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;nor_val :&quot;+NOR_VALUE.toString()); System.out.println(&quot;nor_val :&quot;+NOR_VALUE); &#125;&#125;/*Output:max_val 2147483647max_val :2147483647-------------------------out_max :2147483647out_min :-2147483648-------------------------min_val :-2147483648min_val :-2147483648-------------------------nor_val :-128nor_val :-128*///:~ 由上面可知直接输出Integer的值和调用Integer类的toString方法是一样的，其实直接打印一个对象的时候就是调用了该对象的toString方法。调用toString方法的时候其实输出的是Integer的value值，toString方法就是把int类型的value值转化为string类型输出。注意一下几点： 1、Integer的value值从 Integer.MIN_VALUE 到 Integer.MAX_VALUE 如果超出了这个范围就会得到一些奇怪的结果。 2、在Integer.MAX_VALUE基础上加1输出的结果是个负值。 3、在Integer.MIN_VALUE基础上加1输出的结果是个正值。 Integer类的toString的源码分析123456789101112131415161718192021public String toString() &#123; return toString(value);&#125;//------------------------------public static String toString(int i) &#123; if (i == Integer.MIN_VALUE) return &quot;-2147483648&quot;; //如果是最小值直接返回其字符串因为Integer.MIN_VALUE=-2147483648 ，这样可以节省下面计算时间 //① int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); //获取整数值的长度10进制 char[] buf = new char[size]; //② getChars(i, size, buf); //得到整数中的每一个字符 //③ return new String(buf, true); //返回字符串值&#125; 上面的代码做几点说明：1、如果Integer的value值正好是 Integer.MIN_VALUE 直接返回 “-2147483648” 节省时间。2、得到integer值的十进制的长度，如果负数先求出绝对值的长度，然后再长度加1，因为负数的符号位占一位。3、得到integer的value值的每一个字符。4、得到的字符新建字符串返回。 … 先记到这里把，我脑子不够用了。。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>toString()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口与工厂]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[接口与工厂 接口是实现多重继承的途径，而生成遵循某个接口的对象的典例方式就是工厂方法设计模式。 工厂对象上调用的是创建方法，工厂对象将生成接口的某个实现的对象。 我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换为另一个实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243interface Service&#123; void method1(); void method2();&#125;interface ServiceFactory&#123; Service getService();&#125;class Implementation1 implements Service&#123; Implementation1()&#123;&#125; public void method1() &#123;System.out.println(&quot;Implementation1 method1&quot;);&#125; public void method2() &#123;System.out.println(&quot;Implementation1 method2&quot;);&#125;&#125;class Implementation1Factory implements ServiceFactory&#123; public Service getService()&#123; return new Implementation1(); &#125;&#125;class Implementation2 implements Service&#123; Implementation2()&#123;&#125; public void method1() &#123;System.out.println(&quot;Implementation2 method1&quot;);&#125; public void method2() &#123;System.out.println(&quot;Implementation2 method2&quot;);&#125;&#125;class Implementation2Factory implements ServiceFactory&#123; public Service getService() &#123; return new Implementation2(); &#125;&#125;public class Factories&#123; public static void serviceConsumer(ServiceFactory fact) &#123; Service s = fact.getService(); s.method1(); s.method2(); &#125; public static void main(String[] args) &#123; serviceConsumer(new Implementation1Factory()); serviceConsumer(new Implementation2Factory()); &#125;&#125;/*Output:Implementation1 method1Implementation1 method2Implementation2 method1Implementation2 method2*///:~ 如果不是用工厂方法，你的代码就必须在某处指定将要创建地Service的确切类型，以便调用合适的构造器。 为什么想要添加这种额外级别的间接性呢？一个常见的原因是想要创建框架：假设你正在创建一个对弈游戏，例如，在相同的棋盘上下国际象棋和西洋跳棋： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface Game&#123; boolean move();&#125;interface GameFactory&#123; Game getGame();&#125;class Checkers implements Game&#123; private int moves = 0; private static final int MOVES = 3; public boolean move() &#123; System.out.println(&quot;Checkers move &quot;+moves); return ++moves != MOVES; &#125;&#125;class CheckerFactory implements GameFactory&#123; public Game getGame() &#123; return new Checkers(); &#125;&#125;class Chess implements Game&#123; private int moves = 0; private static final int MOVES = 4; public boolean move() &#123; System.out.println(&quot;Chess move &quot;+moves); return ++moves != MOVES; &#125;&#125;class ChessFactory implements GameFactory&#123; public Game getGame() &#123; return new Chess(); &#125;&#125;public class Games&#123; public static void playGame(GameFactory factory) &#123; Game s = factory.getGame(); while(s.move()) ; &#125; public static void main(String[] args) &#123; playGame(new CheckerFactory()); playGame(new ChessFactory()); &#125;&#125;/*Output:Checkers move 0Checkers move 1Checkers move 2Chess move 0Chess move 1Chess move 2Chess move 3*///:~ 如果Games类表示一段复杂的代码，那么这种方式就允许你在不同类型的游戏中复用这段代码。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化接口中的域]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[在接口中定义的域不能是“空final”，但是可以被非常量表达式初始化。 例如： 123456789101112131415161718import java.util.Random;interface A&#123; Random RAND = new Random(47); int RANOOM_INT = RAND.nextInt(10); long RANOOM_LONG = RAND.nextLong()*10; float RANOOM_FLOAT = RAND.nextLong()*10; double RANOOM_DOUBLE = RAND.nextDouble()*10; &#125;public class Test&#123; public static void main(String[] args) &#123; System.out.println(A.RANOOM_INT); System.out.println(A.RANOOM_LONG); System.out.println(A.RANOOM_FLOAT); System.out.println(A.RANOOM_DOUBLE); &#125;&#125; 既然域是static的，就可以在类第一次被加载时初始化，这发生在任何首次被访问时。 这些域不是接口的一部分，它们的值被存储在该接口的静态存储区域内。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java接口中方法的默认访问修饰符为public]]></title>
    <url>%2F2019%2F09%2F15%2Fjava%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%BApublic%2F</url>
    <content type="text"><![CDATA[java接口中方法的默认访问修饰符为public 接口，比抽象类还要抽象的类: 1、接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。 2、接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误。） 3、接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 注： 接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字。 接口中的方法都是公有的( public ) ！！！ 不是 default 啦]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>默认修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模式(适配器模式)]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[学习到适配接口时不是很理解，书上的例子自己也看不懂，就找到博友的文章来学习一下吧。 转自 https://blog.csdn.net/elegant_shadow/article/details/5006175 首先，先来讲讲适配器。适配就是又“源”到“目标”的适配，而当中连接两者的关系就是适配。它负把“源”过度到“目标”。举个简单的例子，比如有一个“源”是一个对象人，他拥有2种技能分别是说日语和说英语，而某个岗位（目标）需要你同时回说日语、英语、和法语，好了，现在我们的任务就是要将人这个“源”适配的这个岗位中，如何适配呢？显而易见地我们需要为人添加一个说法语的方法，这样才能满足目标的需要。 接着讨论如何加说法语这个方法，也许你会说，为什么不直接在“源”中直接添加方法，我的理解是，适配是为了实现某种目的而为一个源类暂时性的加上某种方法，所以不能破坏原类的结构。同时不这么做也符合Java的高内聚，低耦合的原理。既然不能直接加，接着我们就来说该怎么来实现为人这个“源”添加一个方法，而又不破坏“源”的本身结构。 适配器模式有2种，第一种是“面向类的适配器模式”，第二种是“面向对象的适配器模式”。 先说“面向类的适配器模式”。顾名思义，这类适配器模式就是主要用于，单一的为某个类而实现适配的这样一种模式，为什么说只为某个类去实现，一会提到，我们先展示这种类适配模式的代码实现。 源代码如下： 123456789101112131415public class Person &#123; private String name; private String sex; private int age; public void speakJapanese()&#123; System.out.println(&quot;I can speak Japanese!&quot;); &#125; public void speakEnglish()&#123; System.out.println(&quot;I can speak English!&quot;); &#125; ...//以下省略成员变量的get和set方法&#125; 目标接口的代码如下： 1234567public interface Job &#123; public abstract void speakJapanese(); public abstract void speakEnglish(); public abstract void speakFrench(); &#125; 适配器的代码如下： 1234567public class Adapter extends Person implements Job&#123; public void speakFrench() &#123; &#125; &#125; 好了，代码看完然后要做一些说明了，之前遗留的一个问题，为什么称其为类适配模式呢？很显然的，Adapter类继承了Person类，而在Java这种单继承的语言中也就意味着，他不可能再去继承其他的类了，这样也就是这个适配器只为Person这一个类服务。所以称其为类适配模式。 说完类的适配模式，我们要开始说第2种对象的适配器模式了。对象适配器模式是把“源”作为一个对象聚合到适配器类中。同样的话不多说，贴上代码： 源的代码以及目标代码同上，再次不再赘述。 仅贴出适配器代码： 12345678910111213141516171819202122public class Adapter implements Job &#123; Person person; public Adapter(Person person) &#123; this.person = person; &#125; public void speakEnglish() &#123; person.speakEnglish(); &#125; public void speakJapanese() &#123; person.speakJapanese(); &#125; //new add public void speakFrench() &#123; &#125;&#125; 对象的适配器模式，把“源”作为一个构造参数传入适配器，然后执行接口所要求的方法。这种适配模式可以为多个源进行适配。弥补了类适配模式的不足。 现在来对2种适配模式做个分析： 1.类的适配模式用于单一源的适配，由于它的源的单一话，代码实现不用写选择逻辑，很清晰；而对象的适配模式则可用于多源的适配，弥补了类适配模式的不足，使得原本用类适配模式需要写很多适配器的情况不复存在，弱点是，由于源的数目可以较多，所以具体的实现条件选择分支比较多，不太清晰。 2.适配器模式主要用于几种情况：（1）系统需要使用现有的类，但现有的类不完全符合需要。（2）讲彼此没有太大关联的类引进来一起完成某项工作（指对象适配）。 最后，再来顺带谈谈默认适配器模式：这种模式的核心归结如下：当你想实现一个接口但又不想实现所有接口方法，只想去实现一部分方法时，就用中默认的适配器模式，他的方法是在接口和具体实现类中添加一个抽象类，而用抽象类去空实现目标接口的所有方法。而具体的实现类只需要覆盖其需要完成的方法即可。代码如下： 接口类： 12345678public interface Job &#123; public abstract void speakJapanese(); public abstract void speakEnglish(); public abstract void speakFrench(); public abstract void speakChinese(); &#125; 抽象类： 1234567891011121314151617public abstract class JobDefault implements Job&#123; public void speakChinese() &#123; &#125; public void speakEnglish() &#123; &#125; public void speakFrench() &#123; &#125; public void speakJapanese() &#123; &#125; 实现类： 1234567public class JobImpl extends JobDefault&#123; public void speakChinese()&#123; System.out.println(&quot;I can speak Chinese!&quot;); &#125; &#125; 本文链接：https://blog.csdn.net/elegant_shadow/article/details/5006175]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过继承来扩展接口]]></title>
    <url>%2F2019%2F09%2F15%2F%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[通过继承，可以容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。 这两种情况都可以获得新的接口，就像在下例中所看到的： 123456789101112131415161718192021222324252627282930313233343536373839404142interface Monster&#123;void menace();&#125;interface DangerousMonster extends Monster&#123; void destory();&#125;interface Lethal&#123; void Kill();&#125;class DragonZillz implements DangerousMonster&#123; public void menace() &#123;System.out.println(&quot;DragonZillz.menace() &quot;);&#125; public void destory() &#123;System.out.println(&quot;DragonZillz.destory() &quot;);&#125;&#125;interface Vampire extends DangerousMonster,Lethal&#123; void drinkBlood();&#125;class VerBadVampire implements Vampire&#123; public void menace() &#123;System.out.println(&quot;VerBadVampire.menace() &quot;);&#125; public void destory() &#123;System.out.println(&quot;VerBadVampire.destory() &quot;);&#125; public void Kill() &#123;System.out.println(&quot;VerBadVampire.kill() &quot;);&#125; public void drinkBlood() &#123;System.out.println(&quot;VerBadVampire.drinkBlood() &quot;);&#125;&#125;public class HorrorShow&#123; static void u(Monster b) &#123;b.menace();&#125; static void v(DangerousMonster d) &#123; d.menace();d.destory(); &#125; static void w(Lethal l) &#123;l.Kill();&#125; public static void main(String[] args) &#123; DangerousMonster barney = new DragonZillz(); u(barney);v(barney); Vampire vlad = new VerBadVampire(); u(vlad);v(vlad);w(vlad); &#125;&#125;/*Output:DragonZillz.menace() DragonZillz.menace() DragonZillz.destory() VerBadVampire.menace() VerBadVampire.menace() VerBadVampire.destory() VerBadVampire.kill() *///:~ 我看过之后有些许懵逼。。 DangerousMonster是Monster的直接扩展，它产生了一个新接口。DragonZilla中实现了这个接口。 在Vampire中使用的语法仅适用于接口继承。一般情况下，只可以将extends用于单一类，但是可以引用多个基类接口。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多重继承]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[Java中的多重继承 1234567891011121314151617181920212223242526272829interface CanFight&#123; void fight();&#125;interface CanSwim&#123; void swim();&#125;interface CanFly&#123; void fly();&#125;class ActionCharacter&#123; public void fight() &#123;&#125;&#125;class Hero extends ActionCharacter implements CanFight,CanSwim,CanFly&#123; public void swim() &#123;&#125; public void fly() &#123;&#125;&#125;public class Adventure&#123; public static void t(CanFight x) &#123;x.fight();&#125; public static void u(CanSwim x) &#123;x.swim();&#125; public static void v(CanFly x) &#123;x.fly();&#125; public static void w(ActionCharacter x) &#123;x.fight();&#125; public static void main(String[] args) &#123; Hero h = new Hero(); t(h); u(h); v(h); w(h); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class.getName()和class.getSimpleName()的区别]]></title>
    <url>%2F2019%2F09%2F15%2Fclass-getName-%E5%92%8Cclass-getSimpleName-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[class.getName()和class.getSimpleName()的区别 Class.getName()：以String的形式，返回Class对象的“实体”名称； Class.getSimpleName()：获取源代码中给出的“底层类”简称。 123456789101112public class Main &#123; private static final String TAG1 = Main.class.getName(); private static final String TAG2 = Main.class.getSimpleName(); public static void main(String[] args) &#123; System.out.println(&quot;getName ----- &quot; + TAG1 + &quot;\n&quot; + &quot;getSimpleName ----- &quot; + TAG2); &#125;&#125;/*Output:getName ---- com.se7en.test.MaingetSimpleName ---- Main*///:~ getName —-“实体名称” —- com.se7en.test.Main getSimpleName —- “底层类简称” —- Main getName() 获取包名+类名;getSimpleName() 获取类名。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>getName()</tag>
        <tag>getSimpleName()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程思想第九章练习]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[编程思想第九章练习 练习1：（1）修改第八章练习9中的Rodnet，使其成为一个抽象类。只要有能，就将Rodent的方法声明为抽象方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String[] args) &#123; Rodent rodents[] = &#123;new Mouse(),new Gerbil(),new Hamster()&#125;; for(Rodent r: rodents) &#123; r.hop(); r.run(); System.out.println(r); &#125; &#125;&#125;abstract class Rodent&#123; public abstract void hop(); public abstract void run(); public String toString() &#123;return &quot;Rodent&quot;;&#125;&#125;class Mouse extends Rodent&#123; public void hop() &#123;System.out.println(&quot;Mouse hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Mouse run&quot;);&#125; public String toString() &#123;return &quot;Mouse&quot;;&#125;&#125;class Gerbil extends Rodent&#123; public void hop() &#123;System.out.println(&quot;Gerbil hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Gerbil run&quot;);&#125; public String toString() &#123;return &quot;Gernil&quot;;&#125;&#125;class Hamster extends Rodent&#123; public void hop() &#123;System.out.println(&quot;Hamster hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Hamster run&quot;);&#125; public String toString() &#123;return &quot;Hamster&quot;;&#125;&#125;/*Output:Mouse hopMouse runMouseGerbil hopGerbil runGernilHamster hopHamster runHamster*///:~ 练习2：（1）创建一个不包含任何抽象方法的抽象类，并验证我们不能为该类创建任何实例。 12345678public class Test &#123; public static void main(String[] args) &#123; Rodent r = new Rodent(); //不能实例化 &#125;&#125;abstract class Rodent&#123;&#125; 练习3：（2）创建一个基类，让它包含抽象方法print()，并在导出类中覆盖该方法。覆盖后的方法版本可以打印导出类中定义的某个整型变量的值。在定义该变量之处，赋予它非零值。在基类的构造器中调用这个方法。现在，在main()方法中，创建一个导出列对象，然后调用它的print()方法。请解释发生的情形。 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; B b =new B(); b.print(); &#125;&#125;abstract class A&#123; abstract void print(); A() &#123; print(); &#125;&#125;class B extends A&#123; int i = 2; void print() &#123; System.out.println(&quot;B.print() &quot;+i); &#125;&#125;/*Output:B.print() 0 //“构造器内部的多态方法的行为”一文中有解释B.print() 2*///:~ 练习4：(3)创建一个不包含任何方法的抽象类，从它那里导出一个类，并添加一个方法。创建一个静态方法，它可以接受指向基类的引用，将其向下转型到导出类，然后再调用该静态方法。再main()中，展示它的运行情况。然后，为基类中的方法加上abstract声明，这样就不再需要进行向下转型。 1234567891011121314151617181920public class TestAbstract &#123; public static void main(String[] args) &#123; Dog animal = new Dog(); aniamlShout(animal); &#125; static void aniamlShout(Animal animal) &#123; Dog dog = (Dog)animal; dog.eat(); &#125;&#125;abstract class Animal &#123; &#125;class Dog extends Animal &#123; void eat() &#123; System.out.println(&quot;Dog.eat() food&quot;); &#125;&#125;/*Output:Dog.eat() food*///:~ 12345678910111213141516171819public class TestAbstract &#123; public static void main(String[] args) &#123; Dog animal = new Dog(); aniamlShout(animal); &#125; static void aniamlShout(Animal animal) &#123; animal.eat(); &#125;&#125;abstract class Animal &#123; abstract void eat();&#125;class Dog extends Animal &#123; void eat() &#123; System.out.println(&quot;Dog.eat() food&quot;); &#125;&#125;/*Output:Dog.eat() food*///:~ 练习5：（2）在某个包内一个接口，内含三个方法，然后在另一个包中实现此接口。 1234567package cn.testone;public interface A&#123; void one(); void two(); void three();&#125; 1234567891011121314151617package cn.testtwo;import cn.testone.*;public class Test implements A&#123; @Override public void one() &#123; // TODO 自动生成的方法存根 &#125; @Override public void two() &#123; // TODO 自动生成的方法存根 &#125; @Override public void three() &#123; // TODO 自动生成的方法存根 &#125;&#125; 练习6：(2)证明接口内所有的方法都自动是public的。 练习7：(1)修改第8章中的练习9，使Rodent成为一个接口。 12345678910111213141516171819202122232425262728293031323334353637383940interface Rodent&#123; public void hop(); public void run(); public String toString();&#125;class Mouse implements Rodent&#123; public void hop() &#123;System.out.println(&quot;Mouse hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Mouse run&quot;);&#125; public String toString() &#123;return &quot;Mouse&quot;;&#125;&#125;class Gerbil implements Rodent&#123; public void hop() &#123;System.out.println(&quot;Gerbil hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Gerbil run&quot;);&#125; public String toString() &#123;return &quot;Gernil&quot;;&#125;&#125;class Hamster implements Rodent&#123; public void hop() &#123;System.out.println(&quot;Hamster hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Hamster run&quot;);&#125; public String toString() &#123;return &quot;Hamster&quot;;&#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Rodent rodents[] = &#123;new Mouse(),new Gerbil(),new Hamster()&#125;; for(Rodent r: rodents) &#123; r.hop(); r.run(); System.out.println(r); &#125; &#125;&#125;/*Output:Mouse hopMouse runMouseGerbil hopGerbil runGernilHamster hopHamster runHamster*///:~ 练习8：(2)在polymorphism.Sandwich.java中，创建接口FastFood并添加合适的方法，然后修改Sandwith以实现FastFood接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Meal &#123; Meal() &#123; System.out.println(&quot;Meal()&quot;); &#125;&#125;class Bread &#123; Bread() &#123; System.out.println(&quot;Bread()&quot;); &#125;&#125;class Cheese &#123; Cheese() &#123; System.out.println(&quot;Cheese()&quot;); &#125;&#125;class Lettuce &#123; Lettuce() &#123; System.out.println(&quot;Lettuce()&quot;); &#125;&#125;class Lunch extends Meal &#123; Lunch() &#123; System.out.println(&quot;Lunch()&quot;); &#125;&#125;class PortableLunch extends Lunch &#123; PortableLunch() &#123; System.out.println(&quot;PortableLunch()&quot;); &#125;&#125;interface FastFood &#123; void first(); void second(); void third();&#125;public class Test extends PortableLunch implements FastFood &#123; private Bread b = new Bread(); private Cheese c = new Cheese(); private Lettuce l = new Lettuce(); // public Sandwich() &#123; print(&quot;Sandwich()&quot;); &#125; public void first() &#123; System.out.println(&quot;first()&quot;); &#125; public void second() &#123; System.out.println(&quot;second()&quot;); &#125; public void third() &#123; System.out.println(&quot;third()&quot;); &#125; public static void main(String[] args) &#123; Test ja = new Test(); ja.first(); ja.second(); ja.third(); &#125;&#125;/*Output:Meal()Lunch()PortableLunch()Bread()Cheese()Lettuce()first()second()third()*///:~ 练习9：(3)重构Music5.java，将在Wind、Percussion和Stringed中的公共方法移入一个抽象类中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081enum Note &#123; MIDDLE_C, C_SHARP, B_FLAT;&#125;abstract class Instrument &#123; public void play(Note n) &#123; System.out.println(this + &quot;.play() &quot; + n); &#125; public void adjust() &#123; System.out.println(this + &quot;.adjust()&quot;); &#125; public abstract String toString();&#125;class Wind extends Instrument &#123; @Override public String toString() &#123; return &quot;Wind&quot;; &#125;&#125;class Percussion extends Instrument &#123; @Override public String toString() &#123; return &quot;Percussion&quot;; &#125;&#125;class Stringed extends Instrument &#123; @Override public String toString() &#123; return &quot;Stringed&quot;; &#125;&#125;class Brass extends Wind &#123; @Override public String toString() &#123; return &quot;Brass&quot;; &#125;&#125;class Woodwind extends Wind &#123; @Override public String toString() &#123; return &quot;Woodwind&quot;; &#125;&#125;public class Test &#123; static void tune(Instrument i) &#123; i.adjust(); i.play(Note.MIDDLE_C); &#125; static void tuneAll(Instrument[] e) &#123; for (Instrument instrument : e) &#123; tune(instrument); &#125; &#125; public static void main(String[] args) &#123; Instrument[] ins = &#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind() &#125;; tuneAll(ins); &#125;&#125;/*Output:Wind.adjust()Wind.play() MIDDLE_CPercussion.adjust()Percussion.play() MIDDLE_CStringed.adjust()Stringed.play() MIDDLE_CBrass.adjust()Brass.play() MIDDLE_CWoodwind.adjust()Woodwind.play() MIDDLE_C*///:~ 练习10：(3)修改Music5.java，添加Playable接口。将play()的声明从Instrument中移到Playable中。通过将Playable包括在implements列表中，把Playable添加到导出类中。修改tune()，使它接受Playable而不是Instrumnet作为参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697enum Note &#123; MIDDLE_C, C_SHARP, B_FLAT;&#125;interface Instrument &#123; void adjust();&#125;interface Playable &#123; void play(Note n);&#125;class Wind implements Instrument, Playable &#123; @Override public void play(Note n) &#123; System.out.println(this + &quot;.play() &quot; + n); &#125; @Override public void adjust() &#123; System.out.println(this + &quot;.adjust()&quot;); &#125; @Override public String toString() &#123; return &quot;Wind&quot;; &#125;&#125;class Percussion implements Instrument, Playable &#123; @Override public void play(Note n) &#123; System.out.println(this + &quot;.play() &quot; + n); &#125; @Override public void adjust() &#123; System.out.println(this + &quot;.adjust()&quot;); &#125; @Override public String toString() &#123; return &quot;Percussion&quot;; &#125;&#125;class Stringed implements Instrument, Playable &#123; @Override public void play(Note n) &#123; System.out.println(this + &quot;.play() &quot; + n); &#125; @Override public void adjust() &#123; System.out.println(this + &quot;.adjust()&quot;); &#125; @Override public String toString() &#123; return &quot;Stringed&quot;; &#125;&#125;class Brass extends Wind &#123; @Override public String toString() &#123; return &quot;Brass&quot;; &#125;&#125;class Woodwind extends Wind &#123; @Override public String toString() &#123; return &quot;Woodwind&quot;; &#125;&#125;public class Test &#123; static void tune(Playable p) &#123; p.play(Note.MIDDLE_C); &#125; static void tuneAll(Playable[] e) &#123; for (Playable playable : e) &#123; tune(playable); &#125; &#125; public static void main(String[] args) &#123; Playable[] ps = &#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind() &#125;; tuneAll(ps); &#125;&#125;/*Output:Wind.play() MIDDLE_CPercussion.play() MIDDLE_CStringed.play() MIDDLE_CBrass.play() MIDDLE_CWoodwind.play() MIDDLE_C*///:~ 练习12：(2)在Adventure.java中，按照其他接口的样式，增加一个CanClimb接口。 1234567891011121314151617181920212223242526272829303132333435interface CanFight&#123; void fight();&#125;interface CanSwim&#123; void swim();&#125;interface CanFly&#123; void fly();&#125;interface CanClimb&#123; void play();&#125;class ActionCharacter&#123; public void fight() &#123;&#125;&#125;class Hero extends ActionCharacter implements CanFight,CanSwim,CanFly,CanClimb&#123; public void swim() &#123;&#125; public void fly() &#123;&#125; public void play() &#123;&#125;&#125;public class Adventure&#123; public static void t(CanFight x) &#123;x.fight();&#125; public static void u(CanSwim x) &#123;x.swim();&#125; public static void v(CanFly x) &#123;x.fly();&#125; public static void w(ActionCharacter x) &#123;x.fight();&#125; public static void p(CanClimb x) &#123;x.play();&#125; public static void main(String[] args) &#123; Hero h = new Hero(); t(h); u(h); v(h); w(h); p(h); &#125;&#125; 练习13：(2)创建一个接口，并从该接口继承两个接口，然后从后面两个接口多重继承第三个接口。 123456789101112131415161718192021222324252627282930interface A&#123; void aa();&#125;interface B extends A&#123; void bb();&#125;interface C extends A&#123; void cc();&#125;interface D extends B,C&#123; void dd();&#125;public class Test implements D&#123; public void bb() &#123;System.out.println(&quot;bb&quot;);&#125; public void aa() &#123;System.out.println(&quot;aa&quot;);&#125; public void cc() &#123;System.out.println(&quot;cc&quot;);&#125; public void dd() &#123;System.out.println(&quot;dd&quot;);&#125; public static void main(String[] args) &#123; Test test = new Test(); test.bb(); test.aa(); test.cc(); test.dd(); &#125;&#125;/*Output:bbaaccdd*///:~ 练习14：(2)创建三个接口，每个接口都包含两个方法。继承出一个接口，它组了这三个接口并添加了一个新方法。创建一个实现了该新接口并且继承了某个具体类的类。现在编写四个方法，每一个狗接受这四个接口之一作为参数。在main()方法中，创建这个类的对象，并将其传递给这四个方法。 练习15：(2)将前一个练习修改为：创建一个抽象类，并将其继承到一个导出类中。 练习16：(3)创建一个类，它将生成一个char序列，适配这个类，使其可以称为Scanner对象的一种输入。 123456789101112131415161718192021222324252627import java.nio.CharBuffer;import java.util.Random;import java.util.Scanner;class RandomChars&#123; private static Random rd = new Random(); public char next() &#123; return (char)(rd.nextInt(100)+2); &#125;&#125;public class Test extends RandomChars implements Readable&#123; private int count; public Test(int count) &#123;this.count=count;&#125; public int read(CharBuffer cb) &#123; if(count--==0) &#123;return -1;&#125; String result=Character.toString(next())+&quot; &quot;; cb.append(result); return result.length(); &#125; public static void main(String[] args) &#123; Scanner s = new Scanner(new Test(7)); while(s.hasNext()) &#123; System.out.println(s.next()+&quot; &quot;); &#125; &#125;&#125; 练习17：(2)证明在接口中的域隐式地为static和final的。 123456789interface A&#123; int a = 1,b =2;&#125;public class Test implements A&#123; public static void main(String[] args) &#123; System.out.println(a+&quot; &quot;+b); //a=2; //不能对final字段 A.a 赋值 &#125;&#125; 练习18:(2)创建一个Cycle接口及其Unicycle、Bicycle和Tricycle实现。对每种类型的Cycle都创建相应的工厂，然后编写代码使用这些工厂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface Cycle&#123; void f();&#125;interface CycleFactory&#123; Cycle getCycle();&#125;class Unicycle implements Cycle&#123; public void f() &#123; System.out.println(&quot;Unicycle.f() &quot;); &#125;&#125;class UnicycleFactory implements CycleFactory&#123; public Cycle getCycle() &#123; return new Unicycle(); &#125;&#125;class Bicycle implements Cycle&#123; public void f() &#123; System.out.println(&quot;Bicycle.f() &quot;); &#125;&#125;class BicycleFactory implements CycleFactory&#123; public Cycle getCycle() &#123; return new Bicycle(); &#125;&#125;class Tricycle implements Cycle&#123; public void f() &#123; System.out.println(&quot;Tricycle.f() &quot;); &#125;&#125;class TricycleFactory implements CycleFactory&#123; public Cycle getCycle() &#123; return new Tricycle(); &#125;&#125;public class Games&#123; public static void playGame(CycleFactory factory) &#123; Cycle s = factory.getCycle(); s.f(); &#125; public static void main(String[] args) &#123; playGame(new UnicycleFactory()); playGame(new BicycleFactory()); playGame(new TricycleFactory()); &#125;&#125;/*Outpur:Unicycle.f() Bicycle.f() Tricycle.f() *///:~ 练习19：(3)使用工厂方法来创建一个框架，它可以执行抛硬币和掷骰子功能。 123456789101112131415161718192021222324252627282930313233343536373839interface Game&#123; void print();&#125;interface GameFactory&#123; Game getGame();&#125;class Coin implements Game&#123; public void print() &#123; System.out.println(&quot;toss a coin &quot;); &#125;&#125;class CoinFactory implements GameFactory&#123; public Game getGame() &#123; return new Coin(); &#125;&#125;class Dice implements Game&#123; public void print() &#123; System.out.println(&quot;dice &quot;); &#125;&#125;class DiceFactory implements GameFactory&#123; public Game getGame() &#123; return new Dice(); &#125;&#125;public class Games&#123; public static void playGame(GameFactory factory) &#123; Game s = factory.getGame(); s.print(); &#125; public static void main(String[] args) &#123; playGame(new CoinFactory()); playGame(new DiceFactory()); &#125;&#125;/*Output:toss a coin dice *///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和抽象方法]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[抽象类和抽象方法 什么是抽象类？用abstract定义类 什么是抽象方法？用absctract定义方法 1、包含抽象方法的类叫做抽象类 2、抽象类不能直接实例化，也就是不能直接使用new关键字产生对象 如果继承了一个抽象类，并想创建新类的对象，那么就必须为基类中所有抽象方法提供方法定义。 如果不提供，编译器会强制用abstract关键字来限定这个导出类，使导出类也变为抽象类。 如果基类中的方法有方法体，那么导出类就可以不提供对方法的定义。 代码如下 12345678abstract class A&#123; abstract void f();&#125;class B extends A&#123; void f() &#123; &#125;&#125; 123456abstract class A&#123; abstract void f();&#125;abstract class B extends A&#123;&#125; 12345678abstract class A&#123; void f() &#123; &#125;&#125;abstract class B extends A&#123;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>抽象类</tag>
        <tag>抽象方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向下转型]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，所以也可以通过向下转型——也就是在继承层次中向下移动——应该能够获取类型信息。 12345678910111213141516171819202122232425class Useful&#123; public void f() &#123;&#125; public void g() &#123;&#125;&#125;class MoreUseful extends Useful&#123; public void f() &#123;&#125; public void g() &#123;&#125; public void u() &#123;&#125; public void v() &#123;&#125; public void w() &#123;&#125;&#125;public class RTTI&#123; public static void main(String[] args) &#123; Useful[] x = &#123; new Useful(), new MoreUseful() &#125;; x[0].f(); x[1].g(); //Compile time: method not found in Useful: //! x[1].u(); ((MoreUseful)x[1]).u(); //Downcast/RTTI ((MoreUseful)x[0]).u(); //Exception thrown &#125;&#125; MoreUseful接口扩展了Useful接口；数组中的两个对象都属于Useful类，所以可以用f()和g()这两个方法。如果试图调用u()方法（它只存在于MoreUseful），就会返回一条编译时出错消息。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>向下转型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协变返回类型]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[协变返回类型 百度了一下，有一种说法是： 在Java1.4及以前，子类方法如果要覆盖超类的某个方法，必须具有完全相同的方法签名，包括返回值也必须完全一样。 Java5.0放宽了这一限制，只要子类方法与超类方法具有相同的方法签名，或者子类方法的返回值是超类方法的子类型，就可以覆盖。 注意：”协变返回(covariant return)”，仅在subclass（子类）的返回类型是superclass（父类）返回类型的extension（继承）时才被容许。 ———————————-分割线————————————————- Java SE5中添加了协变返回类型，它表示在导出类中被覆盖方法可以返回基类方法的返回类型的某种导出类型： 12345678910111213141516171819202122232425class Grain&#123; public String toString() &#123;return &quot;Grain&quot;;&#125;&#125;class Wheat extends Grain&#123; public String toString() &#123;return &quot;Wheat&quot;;&#125;&#125;class Mill&#123; Grain process() &#123;return new Grain();&#125;&#125;class WheatMill extends Mill&#123; Wheat process() &#123;return new Wheat();&#125;&#125;public class CovariantReturn&#123; public static void main(String[] args) &#123; Mill m = new Mill(); Grain g = m.process(); System.out.println(g); m = new WheatMill(); g = m.process(); System.out.println(g); &#125;&#125;/*Output:GrainWheat*///:~ Java SE5与较早版本之间的主要差异就是较早的版本将强制process()的覆盖版本必须返回Grain()，而不能返回Wheat()，尽管Wheat是从Grain导出的，因而应该是以一种合法的返回类型。协变返回类型允许返回更具体的Wheat类型。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>协变返回</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造器内部的多态方法的行为]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%9E%84%E9%80%A0%E5%99%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[构造器内部的多态方法的行为 12345678910111213141516171819202122232425262728class Glyph&#123; void draw() &#123;System.out.println(&quot;Glyph.draw()&quot;);&#125; Glyph()&#123; System.out.println(&quot;Glyph() before draw()&quot;); draw(); System.out.println(&quot;Glyph() after draw()&quot;); &#125;&#125;class RoundGlyph extends Glyph&#123; private int radius = 1; RoundGlyph(int r) &#123; radius = r; System.out.println(&quot;RoundGlyph.RoundGlyph().radius = &quot;+radius); &#125; void draw() &#123; System.out.println(&quot;RoundGlyph.draw().radius = &quot;+radius); &#125;&#125;public class PolyConstructors&#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125;/*Output:Glyph() before draw()RoundGlyph.draw().radius = 0 //1Glyph() after draw()RoundGlyph.RoundGlyph().radius = 5*///:~ 为什么在1处输出的为0？ Glyph.draw()方法设计为将要覆盖，这种覆盖是在RoundGlyph中发生的。但是Glyph构造器会调用这个方法，结果导致了对RoundGlyph.draw()的调用。 但输出结果不是默认值1，而是0。 初始化的实际过程：1、在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。 2、如果所述那样调用基类构造器。此时，调用被覆盖后的draw()方法（要在调用RoundGlyph构造器之前调用），由于步骤1的缘故，我们此使会发现radius的值为0。 3、按照声明的顺序调用成员的初始化。 4、调用导出类的构造器主题 在构造器内唯一能够安全调用的哪些方法是基类的final方法（也适用于private方法，它们自动属于final方法）。这些方法不能被覆盖，因此也就不会出现上述令人惊讶的问题。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protected关键字]]></title>
    <url>%2F2019%2F09%2F15%2Fprotected%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[如果希望超类中的某些方法允许被子类访问，或者允许子类的方法访问超类的某个域，为此需要将这些方法或域设置为protected。 下面是编程思想中的一段代码 12345678910111213141516171819202122232425262728293031class Villain&#123; private String name; protected void set(String nm) &#123;name = nm;&#125; public Villain(String name) &#123;this.name=name;&#125; public String toString() &#123; return &quot;I&apos;m a Villain and my name is &quot;+name; &#125;&#125;public class Orc extends Villain&#123; private int orcNumber; public Orc(String name,int orcNumber) &#123; super(name); this.orcNumber = orcNumber; &#125; public void change(String name,int orcNumber) &#123; set(name); this.orcNumber = orcNumber; &#125; public String toString() &#123; return &quot;Orc &quot;+orcNumber+&quot;: &quot;+super.toString(); &#125; public static void main(String[] args) &#123; Orc orc = new Orc(&quot;Limburger&quot;,12); System.out.println(orc); orc.change(&quot;Bob&quot;,19); System.out.println(orc); &#125;&#125;/*Output:Orc 12: I&apos;m a Villain and my name is LimburgerOrc 19: I&apos;m a Villain and my name is Bob*///:~ change()可以访问set(),这是因为它是protected。 但是我换成public后依然可以运行，不懂为什么要用protected。 ———————————–分割线———————————————————————————————————————————-]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>protected</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与清理]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B8%85%E7%90%86%2F</url>
    <content type="text"><![CDATA[继承与清理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Characteristic&#123; private String s; Characteristic(String s) &#123; this.s = s; System.out.println(&quot;Creating Characteristic &quot;+s); &#125; protected void dispose() &#123; System.out.println(&quot;disposing Characteristic &quot;+s); &#125;&#125;class Description&#123; private String s; Description(String s) &#123; this.s = s; System.out.println(&quot;Creating Descripion &quot;+s); &#125; protected void dispose() &#123; System.out.println(&quot;disposing Description &quot;+s); &#125;&#125;class LivingCreature&#123; private Characteristic p= new Characteristic(&quot;is alive&quot;); private Description t = new Description(&quot;Basic Living Creature&quot;); LivingCreature()&#123; System.out.println(&quot;LivingCreature()&quot;); &#125; protected void dispose() &#123; System.out.println(&quot;LivingCreature dispose&quot;); t.dispose(); p.dispose(); &#125;&#125;class Animal extends LivingCreature&#123; private Characteristic p = new Characteristic(&quot;has heart&quot;); private Description t = new Description(&quot;Animal not Vegetable&quot;); Animal()&#123;System.out.println(&quot;Animal()&quot;);&#125; protected void dispose() &#123; System.out.println(&quot;Animal dispose&quot;); t.dispose(); p.dispose(); super.dispose(); &#125;&#125;class Amphibian extends Animal&#123; private Characteristic p = new Characteristic(&quot;can live in water&quot;); private Description t = new Description(&quot;Both water and land&quot;); Amphibian()&#123; System.out.println(&quot;Amphibian()&quot;); &#125; protected void dispose() &#123; System.out.println(&quot;Amphibian dispose&quot;); t.dispose(); p.dispose(); super.dispose(); &#125;&#125;public class Frog extends Amphibian&#123; private Characteristic p = new Characteristic(&quot;Croaks&quot;); private Description t = new Description(&quot;Eats Bugs&quot;); public Frog() &#123;System.out.println(&quot;Frog()&quot;);&#125; protected void dispose() &#123; System.out.println(&quot;Frog dispose&quot;); t.dispose(); p.dispose(); super.dispose(); &#125; public static void main(String[] args) &#123; Frog frog = new Frog(); System.out.println(&quot;Bye!&quot;); frog.dispose(); &#125;&#125;/*Output:Creating Characteristic is aliveCreating Descripion Basic Living CreatureLivingCreature()Creating Characteristic has heartCreating Descripion Animal not VegetableAnimal()Creating Characteristic can live in waterCreating Descripion Both water and landAmphibian()Creating Characteristic CroaksCreating Descripion Eats BugsFrog()Bye!Frog disposedisposing Description Eats Bugsdisposing Characteristic CroaksAmphibian disposedisposing Description Both water and landdisposing Characteristic can live in waterAnimal disposedisposing Description Animal not Vegetabledisposing Characteristic has heartLivingCreature disposedisposing Description Basic Living Creaturedisposing Characteristic is alive*///:~ 总结：1、java中进行清理时要小心，在清理函数dispose()中数据成员的销毁顺序应该与声明的顺序相反，并且记得要调用基类的清理函数对基类进行清理（采用super.dispose()语句实现）； 2、对于字段，与声明的顺序相反进行清理；对于基类，应该首先对其导出类进行清理，然后才是基类（这是因为导出类的清理可能会调用基类中的某些方法，所以需要基类中的构件仍起作用而不应该过早地销毁它们。） 3、对象的所有部分都是按照创建的逆序进行销毁。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承中的构造方法执行顺序]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[查阅资料时发现了这段代码，当我想搞明白它的执行顺序时，出现了问题。 12345678910111213141516171819202122232425262728293031class FatherClass &#123; public FatherClass() &#123; System.out.println(1); &#125; public FatherClass(int age) &#123; System.out.println(age); &#125;&#125;public class SonClass extends FatherClass &#123; public SonClass() &#123; &#125; public SonClass(int c) &#123; System.out.println(2); &#125; public SonClass(int a, int b) &#123; super(a); System.out.println(b); &#125; public static void main(String[] args) &#123; new SonClass(); new SonClass(10); new SonClass(10, 11); &#125;&#125;/*Output:1121011*///:~ 为什么会输出两个1呢？ 知识学不牢靠就是，真是懵逼。。 ————————————————————–分割线——————————————- 转自 https://blog.csdn.net/weixin_44706512/article/details/89349076 在子类的构造方法的第一行代码如果没有调用父类的构造或者没有调用子类的其他构造，则默认调用父类无参构造。为什么要调用父类构造？ 因为需要给父类的成员变量初始化。肯定会先把父类的构造执行完毕，再去执行子类构造中的其他代码。 super(实参列表); 在子类的构造方法中使用,用来调用父类中的构造方法(具体哪一个由传递的参数决定),并且只能在构造方法第一行使用 this(实参列表); 语 在类的构造方法中使用,用来调用本类中的其它构造方法(具体哪一个由传递的参数决定),并且只能在构造方法的第一行使用 例如：下面这个例子中，首先调用子类的无参构造，因为第一行是this语句，所以这里不调用父类的无参构造。（第一行是this或super都不调用），然后执行this(1),调用的子类的有参构造，但是子类的有参构造第一行代码没有调用父类的构造或子类的其他构造，所以默认调用父类的无参构造。所以最终的输出结果为：“我是父类的无参构造”—&gt;“我是子类的有参构造”—&gt;“我是子类无参构造” 12345678910111213141516171819202122232425262728package com.itheima; public class ExtendsDemo6 &#123; public static void main(String[] args) &#123; Zi z=new Zi(); &#125;&#125; class Die &#123; public Die() &#123; System.out.println(&quot;我是父类无参构造&quot;); &#125; public Die(int num) &#123; System.out.println(&quot;我是父类有参构造&quot;); &#125;&#125; class Zi extends Die &#123; public Zi() &#123; this(1); System.out.println(&quot;我是子类无参构造&quot;); &#125; public Zi(int num) &#123; System.out.println(&quot;我是子类有参构造&quot;); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>构造方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[学习多态时只是了解了多态应该怎样写，怎样用，但对多态的内在理解并不充分。 转自 https://blog.csdn.net/github_37022917/article/details/59600916 多态是面向对象程序设计三大特性之一，封装、继承、多态。 什么是多态主要体现在方法调用上，同一个方法根据其对象类型的不同而采取不同的方法行为。 得益于继承，对象既可以作为自己本身的类型使用，也可以作为它的基类使用（向上转型），因此对基类型对象起作用的方法就可以用于其所有的导出类对象中并因为导出类对象的不同而有不同的方法行为。 1234567891011121314151617181920212223242526272829class Animals &#123; public void sound()&#123; System.out.println(&quot;动物叫声&quot;); &#125;&#125;class Dog extends Animals&#123; public void sound()&#123; System.out.println(&quot;汪汪汪&quot;); &#125;&#125;class Cat extends Animals&#123; public void sound()&#123; System.out.println(&quot;喵喵喵&quot;); &#125;&#125;public class Test2&#123; public static void animalsSound(Animals a)&#123; a.sound(); &#125; public static void main(String[] args) &#123; Animals dog = new Dog(); Animals cat = new Cat(); animalsSound(dog); animalsSound(cat); &#125;&#125;/*Output:汪汪汪喵喵喵*///：~ 如上述示例，对于animalsSound(Animals a)方法，虽然传入的是Animals类型的引用Dog与Cat实例，调用其sound()方法，但是却根据Dog与Cat类型的不同而有不同的sound()方法实现，这就是表现出来的多态特性 如何使用多态特性1、通过继承重写相应方法 2、通过实现接口 为什么要使用多态（多态的好处）1、可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。 2、可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。3、接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。 4、灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。 5、简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 如何判断是否呈现出多态（多态的存在前提）1、要有继承关系2、子类重写父类的方法3、父类引用指向子类实例 为什么说静态成员无多态特性？其实，在分别弄清楚stiatc与多态的本质后，已经不难回答这个问题了。首先，要明确，static成员，不管是static变量还是static方法，都是属于类的，不与任何对象实例相关联，而多态最起码得要有多个对象的存在，从面向对象的角度就可以解释这个问题。其次，static方法不允许被重写，也就不存在动态绑定之类的一系列问题。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 向上转型之后调用子类的同名变量和方法的问题（多态）]]></title>
    <url>%2F2019%2F09%2F15%2Fjava-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E4%B9%8B%E5%90%8E%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%9A%E6%80%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在学习向上转型时遇到的一些疑问 12345678910111213141516class A&#123; int i=0; void f1() &#123; System.out.println(&quot;A.f1()&quot;); f2(); &#125; public void f2() &#123; System.out.println(&quot;A.f2()&quot;); &#125;&#125;class B extends A&#123; int i=1; public void f2() &#123; System.out.println(&quot;B.f2()&quot;); &#125;&#125; 123456789public class Test&#123; public static void main(String[] args) &#123; A a = new B(); //(1) a.f1(); //(2) &#125;&#125;/*Output:A.f1()B.f2()*///:~ 在（1）处为向上转型（a实际上指向的是一个子类对象），之后调用了a.f1();,以为会打印A.f1();A.f2();,但结果却不是。 个人理解：B继承了A，也就是B有了A的方法，a.f1()是调用B里的f1()，然后f1()又调用了B里f2()。 123456public class Test&#123; public static void main(String[] args) &#123; A a = new B(); //（1） System.out.println(a.i); &#125;&#125; 然后又出现疑问，为什么（1）后输出的i值为0 突然脑子短路。。 ———————————分割线——————————————————————————————————————————– 在网上查看了好多类似的问题，发现某位兄台整理的比较好，就厚颜无耻的引用过来了。 https://blog.csdn.net/kavensu/article/details/8079460 123456789101112131415161718192021class Father &#123; String name = &quot;父&quot;; void f()&#123;System.out.print(&quot;父类&quot;);&#125;&#125;class Son extends Father&#123; String name = &quot;儿子&quot;; void f() &#123; System.out.print(&quot;儿子&quot;); &#125; void f2() &#123; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Father s = new Son(); System.out.println(s.name); //1 s.f(); //2 s.f2(); //3 &#125;&#125; 疑问：不是说类型是由new决定的而不是由声明决定的吗？即Father s=new Son()此时s的具体类型是什么？若是Father 那上面的2就应该输出“父类”而不是“儿子”？若是Son类那就应该能调用f2()呀？另外还有name疑问，s.name怎么会是”父”呢？ 分析： Father s = new Son(); 表示定义了一个Father类型的引用，指向新建的Son类型的对象。由于Son是继承自它的父类Father，所以Father类型的引用是可以指向Son类型的对象的。那么这样有什么意义？因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特。 定义一个父类类型的引用之指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，它是无可奈何的； 因此s.name调用父类的属性! f2方法父类没有，出错！ 同时，父类中的一个方法只有在在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。因此s.f()调用子类的方法! 对于多态，可以总结它为： 一、使用父类类型的引用指向子类的对象； 二、该引用只能调用父类中定义的方法和变量； 三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用） 四、变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>向上转型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程思想第八章练习]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[编程思想第八章练习 练习1：创建一个Cycle类，它具有子类Unicycle，Bicycle和TriCycle.演示每一个类型的实例都可以经由ride（）向上转型为Cycle。 12345678910111213141516171819202122232425262728293031323334353637class Cycle&#123; public void ride() &#123; System.out.println(&quot;Cycle.ride()&quot;); &#125;&#125;class Unicycle extends Cycle&#123; public void ride() &#123; System.out.println(&quot;Unicycle.ride()&quot;); &#125;&#125;class Bicycle extends Cycle&#123; public void ride() &#123; System.out.println(&quot;Bicycle.ride()&quot;); &#125;&#125;class Tricycle extends Cycle&#123; public void ride() &#123; System.out.println(&quot;Tricycle.ride()&quot;); &#125;&#125;public class Test&#123; public static void f(Cycle c) &#123; c.ride(); &#125; public static void main(String[] args) &#123; Unicycle un = new Unicycle(); Bicycle bi = new Bicycle(); Tricycle tr = new Tricycle(); f(un); f(bi); f(tr); &#125;&#125;/*Output:Unicycle.ride()Bicycle.ride()Tricycle.ride()*///:~ 练习2：在几何图形的示例中添加@Override注解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Shape&#123; public void draw() &#123;&#125; public void erase() &#123;&#125;&#125;class Circle extends Shape&#123; @Override public void draw() &#123;System.out.println(&quot;Circle.draw()&quot;);&#125; @Override public void erase() &#123;System.out.println(&quot;Circle.erase()&quot;);&#125;&#125;class Square extends Shape&#123; @Override public void draw() &#123;System.out.println(&quot;Square.draw()&quot;);&#125; @Override public void erase() &#123;System.out.println(&quot;Square.erase()&quot;);&#125;&#125;class Triangle extends Shape&#123; @Override public void draw() &#123;System.out.println(&quot;Triangle.draw()&quot;);&#125; @Override public void erase() &#123;System.out.println(&quot;Triangle.erase()&quot;);&#125;&#125;class RandomShapeGenerator&#123; private Random rand = new Random(47); public Shape next() &#123; switch(rand.nextInt(3)) &#123; default: case 0:return new Circle(); case 1:return new Square(); case 2:return new Triangle(); &#125; &#125;&#125;public class Shapes&#123; private static RandomShapeGenerator gen = new RandomShapeGenerator(); public static void main(String[] args) &#123; Shape[] s = new Shape[9]; for(int i = 0;i&lt;s.length;i++) &#123; s[i] = gen.next(); &#125; for(Shape shp : s) &#123; shp.draw(); &#125; &#125;&#125;/*Output:Triangle.draw()Triangle.draw()Square.draw()Triangle.draw()Square.draw()Triangle.draw()Square.draw()Triangle.draw()Circle.draw()*///:~ 练习3：在基类Shape（）.java中添加一个新方法，用于打印一条消息，但导出类中不要覆盖这个方法。请解释发生了什么。现在，在其中一个导出类中覆盖该方法，而在其他的导出类不予覆盖，观察又有什么发生。最后，在所有的导出类中覆盖这个方法。 1234567public class Circle extends Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Circle.draw()&quot;); &#125; @Override public void erase() &#123;System.out.println(&quot;Circle.erase()&quot;); &#125; public void msg() &#123; System.out.println(&quot;Circle.msg&quot;); &#125; &#125; 1234567public class Square extends Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Square.draw()&quot;); &#125; @Override public void erase() &#123; System.out.println(&quot;Square.erase()&quot;); &#125; public void msg() &#123; System.out.println(&quot;Square.msg&quot;); &#125; &#125; 1234567public class Triangle extends Shape &#123; @Override public void draw() &#123;System.out.println(&quot;Triangle.draw()&quot;); &#125; @Override public void erase() &#123; System.out.println(&quot;Triangle.erase()&quot;); &#125; public void msg() &#123; System.out.println(&quot;Triangle.msg&quot;); &#125; &#125; 1234567public class Shape &#123; public void draw() &#123;&#125; public void erase() &#123;&#125; public void msg() &#123; System.out.println(&quot;Shape.msg()&quot;); &#125; &#125; 1234567891011121314151617public class Shapes &#123; private static RandomShapeGenerator gen = new RandomShapeGenerator(); public static void main(String[] args) &#123; Shape[] s = new Shape[9]; // Fill up the array with shapes: for(int i = 0; i &lt; s.length; i++) s[i] = gen.next(); // Make polymorphic method calls: for(Shape shp : s) &#123; shp.draw(); shp.msg(); &#125; &#125; &#125; 练习4：向Shape.java中添加一个新的Shape类型，并在main（）方法中验证：多态对新类型的作用是否与在旧类型中的一样。 练习5：以练习1为基础，在Cycle中添加wheels（）方法，它将返回轮子的数量。修改ride（）方法，并验证多态起作用了。 12345678910111213141516171819202122232425262728293031323334class Cycle&#123; public int wheels() &#123; return 0; &#125;&#125;class Unicycle extends Cycle&#123; public int wheels() &#123; return 1; &#125;&#125;class Bicycle extends Cycle&#123; public int wheels() &#123; return 2; &#125;&#125;class Tricycle extends Cycle&#123; public int wheels() &#123; return 3; &#125;&#125;public class Test&#123; public static void ride(Cycle c) &#123; System.out.println(&quot;Number of wheels: &quot;+c.wheels()); &#125; public static void main(String[] args) &#123; ride(new Unicycle()); ride(new Bicycle()); ride(new Tricycle()); &#125;&#125;/*Output:Number of wheels: 1Number of wheels: 2Number of wheels: 3*///:~ 练习6：修改Music3.java，使what（）方法成为根Object的toString方法.试用System.out.Printfln()方法打印Instrucment对象（不用向上转型） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859enum Note&#123; MIDDLE_C,C_SHARP,B_FLAT;&#125;class Instrument&#123; void play(Note n) &#123;System.out.println(&quot;Instrument.paly() &quot;+n);&#125; public String toString() &#123;return &quot;Insrument&quot;;&#125; void adjust() &#123;System.out.println(&quot;Adjusting Insrument&quot;);&#125;&#125;class Wind extends Instrument&#123; void play(Note n) &#123;System.out.println(&quot;Wind.play() &quot;+n);&#125; public String toString() &#123;return &quot;Wind&quot;;&#125; void adjust() &#123;System.out.println(&quot;Adjustring Wind&quot;);&#125;&#125;class Percussion extends Instrument&#123; void play(Note n) &#123;System.out.println(&quot;Percussion.play() &quot;+n);&#125; public String toString() &#123;return &quot;Percussion&quot;;&#125; void adjust() &#123;System.out.println(&quot;Adjustring Percussion&quot;);&#125;&#125;class Stringed extends Instrument&#123; void play(Note n) &#123;System.out.println(&quot;Stringed.play() &quot;+n);&#125; public String toString() &#123;return &quot;Stringed&quot;;&#125; void adjust() &#123;System.out.println(&quot;Adjusting Stringed&quot;);&#125;&#125;class Brass extends Wind&#123; void play(Note n) &#123;System.out.println(&quot;Brass.play() &quot;+n);&#125; void adjust() &#123;System.out.println(&quot;Adjusting Brass&quot;);&#125;&#125;class Woodwind extends Wind&#123; void play(Note n) &#123;System.out.println(&quot;Woodwind.play() &quot;+n);&#125; public String toString() &#123;return &quot;Woodwind&quot;;&#125;&#125;public class Music3&#123; public static void tune(Instrument i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tuneAll(Instrument[] e) &#123; for(Instrument i:e) &#123; //tune(i); System.out.println(i.toString()); &#125; &#125; public static void main(String[] args) &#123; Instrument[] orchestra = &#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind() &#125;; tuneAll(orchestra); &#125;&#125;/*Output:WindPercussionStringedWindWoodwind*///:~ 练习7：想Music3.java添加一个新的类型Instrument，并验证多态性是否作用于所添加的新类型。 123456789101112131415161718192021222324252627class Electronic extends Wind&#123; void play(Note n) &#123; System.out.println(&quot;Electronic.play() &quot; + n); &#125; public String toString() &#123; return &quot;Electronic&quot;; &#125;&#125;public class Music3&#123; public static void tune(Instrument i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tuneAll(Instrument[] e) &#123; for(Instrument i:e) &#123; tune(i); &#125; &#125; public static void main(String[] args) &#123; Instrument[] orchestra = &#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind(), new Electronic() &#125;; tuneAll(orchestra); &#125;&#125; 练习8：修改Music3.java，使其可以像Shapes.java中的方式那样可以随机创建Instrument对象 12345678910111213141516171819202122class InstrumentGenerator&#123; Random random = new Random(47); public Instrument next() &#123; switch(random.nextInt(6)) &#123; default: case 0:return new Wind(); case 1:return new Percussion(); case 2:return new Stringed(); case 3:return new Brass(); case 4:return new Woodwind(); case 5:return new Electronic(); &#125; &#125;&#125;public class Music3&#123; public static void main(String[] args) &#123; InstrumentGenerator generator = new InstrumentGenerator(); for(int i=0;i&lt;20;i++) &#123; System.out.println(generator.next()); &#125; &#125;&#125; 练习9：创建Rodent（啮齿动物）：Mnouse（老鼠），Gerbil（鼹鼠），Hamster（大颊鼠），等等这样一个的继承层次结构。在基类中，提供对所有的Rodent都通用的方法，在导出类中，根据特定的Rodent类型覆盖这些方法，以便它们执行不同的行为。创建一个Robent数组，填充不同的Rodent类型，然后调用基类方法，观察发生什么情况。 12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String[] args) &#123; Rodent rodents[] = &#123;new Mouse(),new Gerbil(),new Hamster()&#125;; for(Rodent r: rodents) &#123; r.hop(); r.run(); System.out.println(r); &#125; &#125;&#125;class Rodent&#123; public void hop() &#123;System.out.println(&quot;Rodent hopping&quot;);&#125; public void run() &#123;System.out.println(&quot;Rodent scurrying&quot;);&#125; public String toString() &#123;return &quot;Rodent&quot;;&#125;&#125;class Mouse extends Rodent&#123; public void hop() &#123;System.out.println(&quot;Mouse hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Mouse run&quot;);&#125; public String toString() &#123;return &quot;Mouse&quot;;&#125;&#125;class Gerbil extends Rodent&#123; public void hop() &#123;System.out.println(&quot;Gerbil hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Gerbil run&quot;);&#125; public String toString() &#123;return &quot;Gernil&quot;;&#125;&#125;class Hamster extends Rodent&#123; public void hop() &#123;System.out.println(&quot;Hamster hop&quot;);&#125; public void run() &#123;System.out.println(&quot;Hamster run&quot;);&#125; public String toString() &#123;return &quot;Hamster&quot;;&#125;&#125;/*Output:Mouse hopMouse runMouseGerbil hopGerbil runGerbilHamster hopHamster runHamster*///:~ 练习10:创建一个包含两个方法的基类。在第一个方法中可以调用第二个方法。然后产生一个继承自该基类的导出类，且覆盖基类中的第二个方法。为该导出类创建一个对象，将他向上转型到基类并调用第一个方法，解释发生的情况。 1234567891011121314151617181920212223class A&#123; void f1() &#123; System.out.println(&quot;A.f1()&quot;); f2(); &#125; void f2() &#123; System.out.println(&quot;A.f2()&quot;); &#125;&#125;class B extends A&#123; void f2() &#123; System.out.println(&quot;B.f2()&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; A a = new B(); a.f1(); &#125;&#125;/*Output:A.f1()B.f2()*///:~ 练习11：向Sandwich.java中添加 Pickle类。 12345678910111213141516171819202122232425262728293031323334353637383940class Pickle&#123; Pickle()&#123;System.out.println(&quot;Pickle()&quot;);&#125;&#125;class Meal&#123; Meal()&#123;System.out.println(&quot;Meal()&quot;);&#125;&#125;class Bread&#123; Bread()&#123;System.out.println(&quot;Bread()&quot;);&#125;&#125;class Cheese&#123; Cheese()&#123;System.out.println(&quot;Cheese()&quot;);&#125;&#125;class Lettuce&#123; Lettuce()&#123;System.out.println(&quot;Lettuce()&quot;);&#125;&#125;class Lunch extends Meal&#123; Lunch()&#123;System.out.println(&quot;Lunch()&quot;);&#125;&#125;class PortableLunch extends Lunch&#123; PortableLunch()&#123;System.out.println(&quot;PortableLunch&quot;);&#125;&#125;public class Sandwich extends PortableLunch&#123; private Bread b = new Bread(); private Cheese c = new Cheese(); private Lettuce l = new Lettuce(); private Pickle p = new Pickle(); public Sandwich() &#123;System.out.println(&quot;Sandwinch()&quot;);&#125; public static void main(String[] args) &#123; new Sandwich(); &#125;&#125;/*Output:Meal()Lunch()PortableLunchBread()Cheese()Lettuce()Pickle()Sandwinch()*///:~ 练习12：修改练习9，使其能够演示基类和导出类的初始化顺序。然后向基类和导出类中添加成员对象，并说明构造期间初始化发生的顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142class Member&#123; public Member(String id) &#123; System.out.println(&quot;Member contructor&quot;+id); &#125;&#125;class Rodent&#123; Member m1 = new Member(&quot;r1&quot;); Member m2 = new Member(&quot;r2&quot;); Rodent()&#123;System.out.println(&quot;Rodent Conteuctor&quot;);&#125; void hop() &#123;System.out.println(&quot;Rodent hop&quot;);&#125; void run() &#123;System.out.println(&quot;Rodent run&quot;);&#125; public String toString() &#123;return &quot;Rodent&quot;;&#125;&#125;class Mouse extends Rodent&#123; Member m1 = new Member(&quot;m1&quot;); Member m2 = new Member(&quot;m2&quot;); Mouse()&#123;System.out.println(&quot;Mouse Conteuctor&quot;);&#125; void hop() &#123;System.out.println(&quot;Mouse hop&quot;);&#125; void run() &#123;System.out.println(&quot;Mouse run&quot;);&#125; public String toString() &#123;return &quot;Mouse&quot;;&#125;&#125;class Gerbil extends Rodent&#123; Member m1 = new Member(&quot;g1&quot;); Member m2 = new Member(&quot;g2&quot;); Gerbil()&#123;System.out.println(&quot;Gerbil Conteuctor&quot;);&#125; void hop() &#123;System.out.println(&quot;Gerbil hop&quot;);&#125; void run() &#123;System.out.println(&quot;Gerbil run&quot;);&#125; public String toString() &#123;return &quot;Gerbil&quot;;&#125;&#125;class Hamster extends Rodent&#123; Member m1 = new Member(&quot;h1&quot;); Member m2 = new Member(&quot;h2&quot;); Hamster()&#123;System.out.println(&quot;Hamster Conteuctor&quot;);&#125; void hop() &#123;System.out.println(&quot;Hamster hop&quot;);&#125; void run() &#123;System.out.println(&quot;Hamster run&quot;);&#125; public String toString() &#123;return &quot;Hamster&quot;;&#125;&#125;public class Music3&#123; public static void main(String[] args) &#123; new Hamster(); &#125;&#125; 练习15：在PolyConstructors.java中添加一个RectangularGlyph，并证明会出现本节所描述的问题 123456789101112131415161718192021222324252627282930313233343536373839404142class Glyph&#123; void draw() &#123;System.out.println(&quot;Glyph.draw()&quot;);&#125; Glyph()&#123; System.out.println(&quot;Glyph() before draw()&quot;); draw(); System.out.println(&quot;Glyph() after draw()&quot;); &#125;&#125;//class RoundGlyph extends Glyph&#123;// private int radius = 1;// RoundGlyph(int r) &#123;// radius = r;// System.out.println(&quot;RoundGlyph.RoundGlyph().radius = &quot;+radius);// &#125;// void draw() &#123;// System.out.println(&quot;RoundGlyph.draw().radius = &quot;+radius);// &#125;//&#125;class RectangularGlyph extends Glyph&#123; private int width = 1; private int height = 5; public RectangularGlyph(int width,int height) &#123; this.width = width; this.height = height; System.out.println(&quot;RectangularGlyph.width = &quot;+width+&quot; height = &quot;+height); &#125; public void draw() &#123; System.out.println(&quot;RectangularGlyph.area = &quot;+(width*height)); &#125;&#125;public class PolyConstructors&#123; public static void main(String[] args) &#123; //new RoundGlyph(5); new RectangularGlyph(2, 2); &#125;&#125;/*Output:Glyph() before draw()RectangularGlyph.area = 0Glyph() after draw()RectangularGlyph.width = 2 height = 2*///:~ 练习16：遵循Transmogrify.java这个例子，创建一个Starship类，包含一个AlertStatus引用，此引用可以指示三种不同的状态。纳入一些可以改变这些状态的方法 1234567891011121314151617181920212223242526272829303132333435class AlertStatus&#123; public String getStatus() &#123;return &quot;None&quot;;&#125;&#125;class RedAlertStatus extends AlertStatus&#123; public String getStatus() &#123;return &quot;Red&quot;;&#125;&#125;class YellowAlertStatus extends AlertStatus&#123; public String getStatus() &#123;return &quot;Yellow&quot;;&#125;&#125;class GreenAlertStatus extends AlertStatus&#123; public String getStatus() &#123;return &quot;Green&quot;;&#125;&#125;class Starship&#123; private AlertStatus alertStatus = new GreenAlertStatus(); public void change(AlertStatus iStatus) &#123; alertStatus = iStatus; &#125; public String toString() &#123; return alertStatus.getStatus(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Starship starship = new Starship(); System.out.println(starship); starship.change(new YellowAlertStatus()); System.out.println(starship); starship.change(new RedAlertStatus()); System.out.println(starship); &#125;&#125;/*Output:GreenYellowRed*///:~ 练习17：使用练习1中的Cycle的层次结构哦，在Unicycle 和Bicycle中添加balance方法，而Tricycle中国不添加。创建这三种类型的实例，并将他们向上转型为Cycle数组。在该数组的每一个元素上都尝试调用balance，并观察结果。然后将他们向下转型，再次调用balance（），并观察将所发生什么。 1234567891011121314151617181920212223242526272829303132class Cycle&#123;&#125;class Unicycle extends Cycle&#123; void balance()&#123;System.out.println(&quot;Unicycle&quot;);&#125;&#125;class Bicycle extends Cycle&#123; void balance()&#123;System.out.println(&quot;Bicycle&quot;);&#125;&#125;class Tricycle extends Cycle&#123;&#125;public class Test&#123; public static void main(String[] args) &#123; Cycle[] cycle = &#123; new Unicycle(), new Bicycle(), new Tricycle() &#125;;// cycle[0].balance();// cycle[1].balance();// cycle[2].balance(); ((Unicycle)cycle[0]).balance(); ((Bicycle)cycle[1]).balance(); // ((Tricycle)cycle[3]).balance(); &#125;&#125;/*Output:UnicycleBicycle*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_多态_再论向上转型]]></title>
    <url>%2F2019%2F09%2F15%2FJava-%E5%A4%9A%E6%80%81-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java_多态_再论向上转型 123456789101112131415161718192021222324252627enum Note&#123; MIDDLE_C,C_SHARP,B_FLAT;&#125;class Instrument&#123; public void play(Note n) &#123; System.out.println(&quot;Instrument.play()&quot;); &#125;&#125;class Wind extends Instrument&#123; public void play(Note n) &#123; System.out.println(&quot;Wind.play() &quot;+n); &#125;&#125;public class Music&#123; static void tune(Instrument i) &#123; i.play(Note.MIDDLE_C); &#125; public static void main(String[] args) &#123; Wind flute = new Wind(); tune(flute); &#125;&#125;/*Output:Wind.play() MIDDLE_C*///:~ Music.tune()方法接受一个Instrument引用，同时也接受任何导出自Instrumnet的类。在main()方法中，当一个Wind引用传递到tune()方法时，就会出现这种情况，而不需要任何类型转换。这样做是允许的-因为Wind从Instrument继承而来，所以Instrument的接口必定存在于Wind中。 但为什么不让tune()方法直接接受一个Wind引用作为自己的参数呢。如果那样做，就需要为系统内Instrument的每种类型都编写新的tune()方法。 按照这种假设，再加入Stringed（弦乐）和Brass（管乐）两种Instrument(乐器)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647enum Note&#123; MIDDLE_C,C_SHARP,B_FLAT;&#125;class Instrument&#123; public void play(Note n) &#123; System.out.println(&quot;Instrument.play()&quot;); &#125;&#125;class Wind extends Instrument&#123; public void play(Note n) &#123; System.out.println(&quot;Wind.play() &quot;+n); &#125;&#125;class Stringed extends Instrument&#123; public void play(Note n) &#123; System.out.println(&quot;Stringes.play() &quot;+n); &#125;&#125;class Brass extends Instrument&#123; public void play(Note n) &#123; System.out.println(&quot;Brass.play() &quot;+n); &#125;&#125;public class Music2&#123; public static void tune(Wind i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tune(Stringed i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tune(Brass i) &#123; i.play(Note.MIDDLE_C); &#125; public static void main(String[] args) &#123; Wind flute = new Wind(); Stringed violin = new Stringed(); Brass frenchHorn = new Brass(); tune(flute); tune(violin); tune(frenchHorn); &#125;&#125;/*Output:Wind.play() MIDDLE_CStringes.play() MIDDLE_CBrass.play() MIDDLE_C*///:~ 虽然行得通，但必须为添加的每一个新Instrument类编写特定类型的方法。如果想添加类似tune()的新方法，或者添加自Instrument导出的新类，仍需要做大量工作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>向上转型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承与初始化]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[转自 https://blog.csdn.net/fengjianbang/article/details/50938569 在Java中，每一个类的编译代码都存在于它自己的独立文件中。该文件只有在需要时才会被加载，一般是在类初次使用时加载，这通常是指创建类的第一个对象或者第一次访问类中的静态方法或者静态块。 当JVM要加载一个类A时，如果发现这个类有父类B，那么JVM首先加载其父类B，如果这个父类B还有其自身的父类C，那么首先加载类C，一次类推。这个过程是必须要进行的，即使我们有没有创建类A的对象。看下面这段代码，执行之后的输出结果为，在这段代码中，main函数中并没有任何语句，但是却产生了输出，这是因为在执行这段代码的时候，第一件事是试图访问B.main函数（由于main函数是属于类B的一个静态函数，根据上述内容，这时候需要加载类B的编译代码），于是加载器启动，并找出类B的编译代码（在名为B.class的文件中），在加载的过程中，发现它继承与类A，于是转而先加载类A。在类的加载过程中，加载器会对类的static 变量进行初始化，加载类中的静态块。 123456789101112131415161718192021package testOOP;class A&#123; static&#123; System.out.println(&quot;this is father&apos;s static&quot;); &#125; A()&#123; System.out.println(&quot;this is father&quot;); &#125; &#125;public class B extends A&#123; static&#123; System.out.println(&quot;this is child&apos;s static&quot;); &#125; B()&#123; System.out.println(&quot;this is child&quot;); &#125; public static void main(String [] args)&#123; &#125;&#125; 在上述的代码中，如果main函数中有明确创建B对象的语句，并且类A，和类B都有自己的成员变量和非静态初始化块时，类A，类B的初始化顺序是怎么样的呢？我们首先看一下这段代码，运行后的输出为。根据输出我们可以看出，在创建类B的对象时，首先会加载父类A，然后加载类B，加载完这两个类之后，开始进行初始化操作：首先执行父类的非静态块的初始化操作，然后执行父类的构造方法，再执行子类的非静态块初始化操作，最后执行子类的构造方法。 123456789101112131415161718192021222324252627package testOOP;class A&#123; static&#123; System.out.println(&quot;this is father&apos;s static&quot;); &#125; &#123; System.out.println(&quot;这是父类的非静态初始化块&quot;); &#125; A()&#123; System.out.println(&quot;this is father&quot;); &#125; &#125;public class B extends A&#123; static&#123; System.out.println(&quot;this is child&apos;s static&quot;); &#125; &#123; System.out.println(&quot;这是子类的非静态初始化块&quot;); &#125; B()&#123; System.out.println(&quot;this is child&quot;); &#125; public static void main(String [] args)&#123; new B(); &#125;&#125; 由上述分析内容可以知道，当需要创建一个类A的对象时，其执行顺序是：1、加载父类，2、加载类A，3、执行父类的非静态初始化块，4、执行父类的构造方法，5、执行子类的非静态初始化块，6、执行子类的构造方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中@Override的作用]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E4%B8%ADOverride%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[转自 https://blog.csdn.net/zht666/article/details/7869383 @Override是伪代码,表示重写(当然不写也可以)，不过写上有如下好处: 1、可以当注释用,方便阅读； 2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。 举例：在重写父类的onCreate时，在方法前面加上@Override 系统可以帮你检查方法的正确性。 @Overridepublic void onCreate(Bundle savedInstanceState) {…….}这种写法是正确的，如果你写成： @Overridepublic void oncreate(Bundle savedInstanceState){…….} 编译器会报如下错误：The method oncreate(Bundle) of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。而如果你不加@Override，则编译器将不会检测出错误，而是会认为你为子类定义了一个新方法：oncreate]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Override</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空白fianl]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%A9%BA%E7%99%BDfianl%2F</url>
    <content type="text"><![CDATA[Java允许生成“空白fianl”，所谓空白fianl是指被声明为fianl但又未给定初值的域。编译器会确保空白fianl在使用前必须被初始化。 1234567891011121314151617181920212223242526class Poppet&#123; private int i; Poppet(int ii)&#123;i=ii;&#125;&#125;public class BlankFianl&#123; private final int i=0; private final int j; private final Poppet p; public BlankFianl() &#123; j = 1; p = new Poppet(1); &#125; public BlankFianl(int x) &#123; j = x; p = new Poppet(x); &#125; public String toString() &#123; return &quot;i,j,p:&quot;+i+j+p; &#125; public static void main(String[] args) &#123; new BlankFianl(); new BlankFianl(47); &#125;&#125; 必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。 练习19 ：创建一个含有指向某对象的空白final引用类。在所有构造器内部都执行空白final的初始化操作。说明Java确保final在使用前必须初始化，且一旦被初始化即无法改变]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>fianl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之向上转型]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E4%B9%8B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java之向上转型 由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。Instrument类具有一个play()方法，那么Wind类也同样具备。可以说Windui对象也是一种类型的Instrument。 123456789101112class Instrument&#123; public void play() &#123;&#125; static void tune(Instrument i) &#123; i.play(); &#125;&#125;public class Wind extends Instrument&#123; public static void main(String[] args) &#123; Wind flute = new Wind(); Instrument.tune(flute); &#125;&#125; 在例中，tune()方法可以接受Instrument引用。但在Wind.main()中，传递给tune()方法的是一个Wind引用。在tune()中，程序代码可以对Instrument和它所有的导出类起作用，这种将Wind引用转换为Instrument引用的动作，我们称之为向上转型。 父类类型的变量来引用一个子类类型的对象。1234567891011121314151617interface Animal&#123; void shout();&#125;class Cat implements Animal&#123; public void shout() &#123; System.out.println(&quot;喵喵&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Animal animal = new Cat(); animalShout(animal); &#125; public static void animalShout(Animal an) &#123; an.shout(); &#125;&#125; Animal animal = new Cat() //将Cat对象当作Animal类型来使用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>向上转型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之代理]]></title>
    <url>%2F2019%2F09%2F15%2FJava%E4%B9%8B%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java并没有提供对它的直接支持。这是继承与组合之间的中庸之道，因为我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该对象的所有方法（就像继承）。例如，太空船需要一个控制模块： 123456789public class SpaceShipCotrols&#123; void up(int velocity) &#123;&#125; void down(int velocity) &#123;&#125; void left(int velocity) &#123;&#125; void right(int velocity) &#123;&#125; void forward(int velocity) &#123;&#125; void back(int velocity) &#123;&#125; void turBoost(int velocity) &#123;&#125;&#125; 构造太空船的一种方式是使用继承： 123456789public class SpaceShip extends SpaceShipCotrols&#123; private String name; public SpaceShip(String name) &#123;this.name=name;&#125; public String toString() &#123;return name;&#125; public static void main(String[] args) &#123; SpaceShip protector = new SpaceShip(&quot;NSEA Protector&quot;); protector.forward(100); &#125;&#125; 然而，SpaceShip并非真正的SpaceShipControls类型，即便你可以“告诉”SpaceShip向前运动（forward()）。更准确地讲，SpaceShip包含SpaceShipControls，与此同时，SpaceShipControls的所有方法在SpaceShip中都暴露了出来。代理解决了此难题： 1234567891011121314151617181920212223242526272829303132public class SpaceShipDelegation&#123; private String name; private SpaceShipControls controls = new SpaceShipControls(); public SpaceShipDelegation(String name) &#123; this.name = name; &#125; public void back(int velocity) &#123; controls.back(velocity); &#125; public void down(int velocity) &#123; controls.down(velocity); &#125; public void forward(int velocity) &#123; controls.forward(velocity); &#125; public void left(int velocity) &#123; controls.left(velocity); &#125; public void right(int velocity) &#123; controls.right(velocity); &#125; public void turBoost(int velocity) &#123; controls.turBoost(velocity); &#125; public void up(int velocity) &#123; controls.up(velocity); &#125; public static void main(String[] args) &#123; SpaceShipDelegation protector = new SpaceShipDelegation(&quot;NSEA Protector&quot;); protector.forward(100); &#125;&#125; 可以看到，上面的方法是如何传递给了底层的controls对象，而其接口由此也就与使用继承得到的接口相同了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text汉化教程]]></title>
    <url>%2F2019%2F09%2F13%2FSublime-Text%E6%B1%89%E5%8C%96%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[发现一款Sublime Text编辑器，界面非常简洁，官方简介“A sophisticated text editor forcode, markup and prose” 应用界面： 安装Sublime Text官网点击DOWNLOAD下载 汉化英文界面用着不习惯那就汉化，另外Sublime Text也支持很多语言 打开Sublime Text的控制台（Ctrl+~） 粘贴代码到控制台进入Package Control官方网站 打开后，将适用于您的Sublime Text版本的Python代码粘贴到控制台中。 可以直接粘贴下面的代码： SUBLIME TEST 3 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) SUBLIME TEST 2 1import urllib2,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 粘贴后回车 选择语言 稍微等一会就会出现中文界面 切换语言 Help-&gt;Language 参考 Sublime text如何汉化]]></content>
      <categories>
        <category>Sublime Test</category>
      </categories>
      <tags>
        <tag>汉化</tag>
        <tag>Sublime Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我要工作]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%88%91%E8%A6%81%E4%B8%8A%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[中秋节到了，又不能好好工作了。 什么！！三天小长假！！ No 没有工作的我该怎么活！！ 看来只能用电影音乐游戏苹果香蕉巧克力来减轻没有工作的痛苦了 、]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客next主题添加文章阅读量统计功能]]></title>
    <url>%2F2019%2F09%2F13%2FHexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[添加文章阅读量统计有很多方法，因为我已经注册了LeanCloud，所以就直接采用了LeanCloud。 注册LeanCloud 创建应用储存-&gt;数据-&gt;创建Class 创建名为Counter的class用来存储访问博客的数据，例如：访问次数，最新访问时间等信息。class类名必须为Counter，主要为了与next主题相兼容，否则无法接收到相关数据。为了避免后续因为权限的问题导致次数统计显示不正常，ACL权限选择无限制。 获取ID和Key设置-&gt;应用Key 会得到App ID和App Key 修改next主题配置文件打开_config.yml，搜索leancloud_visitors，更改为true，并添加id和key 保存文件 最后生成部署hexo博客 效果如图： 参考 Hexo博客next主题添加文章阅读量统计功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从多层嵌套类中访问外部类的成员]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%BB%8E%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[一个内部类被嵌套多少层并不重要—它能透明地访问所有它所嵌入地外围类的所有成员，如下所示： 1234567891011121314151617181920class MNA&#123; private void f() &#123;&#125; class A&#123; private void g() &#123;&#125; public class B&#123; void h() &#123; g(); f(); &#125; &#125; &#125;&#125;public class MultiNetingAccess&#123; public static void main(String[] args) &#123; MNA mna = new MNA(); MNA.A mnaa = mna.new A(); MNA.A.B mnaab = mnaa.new B(); mnaab.h(); &#125;&#125; 可以看到在MNA.A.B中，调用方法g()和f()不需要任何条件（即使它们被定义为private）。这个例子同时展示了如何从不同的类里创建多层嵌套类的内部类对象的基本语法。“.new”语法能产生正确的作用域，所以不必在调用构造器时限定类名。 内容取自《Java编程思想》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加Valine评论系统]]></title>
    <url>%2F2019%2F09%2F12%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Valine 诞生于2017年8月7日，是一款基于LeanCloud的快速、简洁且高效的无后端评论系统。 理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo、Ghost 等博客程序在使用Valine。 注册LeancloudLeancloud官网 创建应用创建应用，名字随便，然后进入设置-&gt;应用Key 会获得App ID和App Key 设置安全域名设置-&gt;安全中心-&gt;Web 安全域名 添加域名 配置主题文件打开next主题配置文件，找到Valine 添加App ID和App Key 保存 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 然后刷刷刷 添加成功 参考 为你的Hexo加上评论系统-Valine]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python命令下载视频]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%88%A9%E7%94%A8Python%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[Python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。 1、电脑需要安装Python3 2、window+r 打开cmd输入python来检查环境： python 3、输入下面的代码回车： pip3 install you-get 安装you-get，它是python3的一个下载工具 4、下载视频时可以选择文件路径 you-get -o F:\k 文件地址 默认下载到C盘 5、下载视频选择清晰度 you-get -i 文件地址 显示下载时会有多种：超清、高清、标清 然后我们下载想要下载的视频样式，比如下载高清的，高清的是：-format=mp4sd 那么我们在cmd中输入： you-get –format=mp4sd 视频地址 网站视频下载基本上都支持 下载国外视频需要科学上网]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在云服务器下部署Java Web项目]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E9%83%A8%E7%BD%B2Java-Web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[在服务器下手动部署Java Web项目 在云服务下部署Java的三种方法 Java镜像部署 一键安装包部署 手动部署 手动部署的准备Java jdk:Java jdk官方（下载“jdk-序号-linux-x64.tar.gz”版本） Tomcat：Tomcat官方下载链接（点击首页左侧Tomcat 8，下载“tar.gz (pgp, md5, sha1)”） 安装jdk1、打开Xshell和Xftp，用Xftp在云服务器创建文件夹 2、将jdk安装包和tomcat安装包复制粘贴到云服务器对应的文件夹下 3、在Xshell输入指令，解压jdk安装包到指定文件夹 #tar-zxvf jdk-版本编号-linux-x64.tar.gz-C/usr/java/jdk/ 4、解压完毕后jdk文件夹里会有对应文件，开始配置环境变量 #vi /etc/profileexport JAVA_HOME=/usr/java/jdk/jdk版本编号_121export JRE_HOME=/usr/java/jdk/jdk版本编号_121/jreexport CLASSPATH=.:$JAVA_HOME/lib$:JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin/$JAVA_HOME:$PATH 5、编辑完内容后，按下Esc键，并输入“:wq”，然后回车可以保存退出 6、保存完毕后输入下面指令 #source /etc/profile 7、验证是否成功 #java -version 安装Tomcat1、解压tomcat，解压指令如下： #tar -xvf apache-tomcat-版本编号.tar.gz -C /usr/java/tomcat/ 2、进入解压文件夹下的bin文件夹，指令如下： #cd/usr/java/tomcat/apache-tomcat-版本编号/bin/ 3、编辑setclasspath.sh 脚本，指令如下： #vi setclasspath.sh 4、添写如下内容： export JAVA_HOME=/usr/java/jdk/jdk版本编号export JRE_HOME=/usr/java/jdk/jdk版本编号/jre 5、保存编辑内容，按下Esc键，并输入“:wq”，然后回车可以保存退出。 6、启动tomcat，指令如下： #./startup.sh 7、jdk和tomcat都弄好了，接下来可以用浏览器访问我的云服务器吗？ 当然可以！你可以从浏览器访问，输入http://云服务器的ip:8080就能访问啦！ 部署项目将项目上传到 Tomcat文件夹下的 Webapps 文件夹里就行。上传好了后，浏览器访问即可。例如：http://云服务器ip地址:8080/index/one.html等。 怎么通过我的域名访问我的网站呢解析域名域名直接访问 参考 阿里云ECS建网站（建站）超详细全套完整图文教程！菜鸟必看！]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress建站]]></title>
    <url>%2F2019%2F09%2F11%2FWordPress%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[最近想让博客绑定域名，逛了阿里云，脑子一热又买了服务器，学生认证也挺优惠的，趁机会学习以下建站。因为个人没有基础，所以就从网上搜集教程，结合了多篇文章进行学习。 教程讲解了WordPress建站流程，从服务器配置、域名解析、宝塔面板、Wordpress建站、网站优化等操作讲解建站方法。 转自 https://blog.csdn.net/aliyunguide/article/details/86664703 前期准备 域名：实名认证 服务器：内存512M以上Linux服务器，推荐使用1G内存、Centos7系统。国内服务器需要备案才可以用 其他：Wordpress主题、插件等，免费或者付费都可以，免费的可以查看我们推荐的WordPress免费主题，付费的可以到Themeforest挑选 服务器LNMP环境搭建想要运行Wordpress网站程序，必须要有对应的软件，也就是服务器环境，比如我们常说的LNMP就是 Linux + Nginx + Mysql + PHP 环境，最常见的网站程序，Wordpress程序就是结合这些语言开发出来的。 其实环境里面安装LNMP是众所周知的，这里我要说的是软件的版本，服务器不同于虚拟主机，我们可以自主控制各种程序的参数和版本，这将让网站的配置非常灵活。为了wordpress兼容和性能，关于软件版本的选择有一个很好的标准就是wordpress官方推荐环境，官方的建议是PHP7.2版本及以上，Mysql5.6版本及以上，还有就是https，安装软件的的原则就是版本越接近推荐的越好 接下来就让我们从使用服务器命令开始，搭建Wordpress网站的LNMP环境 安装Xshell由于Windows是不能直接连接到Linux服务器的，需要一个SSH的软件，推荐使用Xshell作为远程连接软件，它对于个人和学校是免费使用的，可以在Xshell官网直接下载。 连接到服务器安装好了Xshell软件之后，就可以开始连接到服务器了，提前准备好服务器的IP、账号、密码 打开Xshell软件，选择文件 – 新建，添加一个连接 图1-1为连接成功 安装宝塔面板接下来我们在服务器安装宝塔面板，输入下面的命令并执行(最新宝塔面板需要在centos7系统用，其他系统的命令查看这里) yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh 安装中途会脚本询问是否将网站安装在www目录，直接选择y，然后确认即可，大概会需要几分钟的时间 安装成功后会出现图1-2的信息 最后得到了宝塔面板的登陆信息，将这些保存下来 宝塔面板为了提升安全，已将面板路径在之前的8888端口增加了随机入口，所以最好将登录信息长期保存，以后面板的管理都需要用到这些信息 安装网站环境使用刚刚获得到的信息，访问你的ip:8888，登陆宝塔面板，比如刚刚我的就是访问 http://45.76.48.16:8888，账号密码也就是刚刚安装完显示的 (注意：如果使用的是阿里云之类的云服务器提前开放安全端口) 首次登陆宝塔面板后台，会弹出一键安装环境，在这里我们需要耐心设置一遍 仔细看下图中的设置，安装环境主要有3个点 选择LNMP环境，节省资源 调整Mysql和PHP版本 安装方式选择为编译安装 最好是按照上图的配置安装，可能有朋友会问为什么不选择 PHP7.2，这里主要是考虑到各种主题和插件的最大兼容，如果选择PHP7.2的话可能会有一些奇怪的问题，当然如果后期主题和插件都兼容了也可以切换到7.2。还有一点就是如果服务器为512M内存要选择Mysql5.5，不然压力会很大 LNMP环境编译安装过程大概为半小时左右，视服务器性能而定 搭建Wordpress网站当服务器LNMP环境安装完成之后，我们就可以开始着手搭建Wordpress网站了，这里就是建站的主要步骤，用过虚拟主机的朋友应当非常熟悉 新建站点选择网站 – 添加站点，首先填入自己的域名，一般是 domain.com 和 www.domain.com 两种格式都要绑定，并创建FTP和数据库 创建完成后会在网站列表中显示，这里面的密码记不记无所谓，可以随时查看，后期还要通过这里进行网站管理 域名解析服务器已经绑定了域名，接下来就是添加解析了，其实就是添加2条A记录，非常简单，这里我用的是腾讯云域名，其他的服务商可能稍微有些不同 登陆控制台，选择域名注册 – 找到自己的域名 – 解析 和服务器绑定一致，域名也是添加2条记录，一个是www对应 www.domain.com，另一个是@，对应domain.com，全部解析到服务器的ip地址 解析完成后访问域名，如果显示 恭喜, 站点创建成功，就证明解析完成，可以进入下一步的网站搭建了，如果还不能访问，稍等几分钟再尝试 注意，有些国外域名解析的话生效较慢，需要等待一天左右时间 下载Wordpress安装包因为需要到wordpress官网下载程序，就采用的是宝塔的远程下载功能，先教大家如何使用 我们进入宝塔后台 – 文件，可以看到这就是服务器的文件系统，默认的/www目录就是所有网站的目录，可以看到刚刚我们创建的网站 wpwp.xyz，我们点击就能就入网站里面 可以看到网站下还很空，可以先把2个没用的 index.html 和 404.html 删除 在文件的上方，我们可以看到在上传的右边有一个远程下载的按钮，点击会弹出一个对话框 这里我们就填入wordpress最新版的下载地址，确定之后就会下载到当前的目录 有的朋友可能不知道如何获取下载地址，打开wordpress中文下载，在下载按钮上右键 – 复制链接地址 等待一会下载完成后，点击一下刷新按钮，就能看到Wordpress程序的压缩包 选择右键 – 解压，直接确定 解压完成后网站根目录会多出一个wordpress的文件夹 但这样不能直接使用的，我们还要继续将wordpress文件夹内的所有文件移动到网站的根目录 选中所有文件，然后剪切，然后到网站根目录粘贴所有 最后的目录结构如下图就行了 WordPress安装环境和程序都就绪了，接下来就可以开始安装Wordpress网站了 访问 www.domain.com(自己购买的域名)，进入程序安装界面，第一步选择 现在就开始]]></content>
      <categories>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress搭建</tag>
        <tag>WordPress优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程思想第七章练习]]></title>
    <url>%2F2019%2F09%2F04%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[编程思想第七章练习 练习1:创建一个简单的类。第二个类中，将一个引用定义为第一个类的对象。运用惰性初始化来实例化 这个对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Test &#123; public static void main(String[] args) &#123; Second second = new Second(&quot;Init String&quot;); second.chenked(); System.out.println(second.getSimple()); second.chenked(); System.out.println(second); second.setSimple(&quot;New String&quot;); System.out.println(second); &#125;&#125;class Simple&#123; String s; public Simple(String si) &#123; s = si; &#125; public String toString() &#123; return s; &#125; public void setString(String sNew) &#123; s = sNew; &#125;&#125;class Second&#123; Simple simple; String s; public Second(String si) &#123; s = si; &#125; public void chenked() &#123; if(simple==null) &#123; System.out.println(&quot;not initialized&quot;); &#125;else &#123; System.out.println(&quot;initialized&quot;); &#125; &#125; private Simple lazy() &#123; if(simple==null) &#123; System.out.println(&quot;Creating simple&quot;); simple = new Simple(s); &#125; return simple; &#125; public Simple getSimple() &#123; return lazy(); &#125; public String toString() &#123; return lazy().toString(); &#125; public void setSimple(String sNew) &#123; lazy().setString(sNew); &#125;&#125;/*Output:not initializedCreating simpleInit StringinitializedInit StringNew String*///:~ 练习2：从Detergent中继承产生一个新的类。覆盖scrub()并添加一个名为sterilize()的新方法。 12345678910111213141516171819202122232425262728293031323334class Cleanser &#123; private String s = &quot;Cleanser&quot;; public void append(String a) &#123; s += a; &#125; public void dilute() &#123; append(&quot; dilute()&quot;); &#125; public void apply() &#123; append(&quot; apply()&quot;); &#125; public void scrub() &#123; append(&quot; scrub()&quot;); &#125; public String toString() &#123; return s; &#125; public static void main(String[] args) &#123; Cleanser x = new Cleanser(); x.dilute(); x.apply(); x.scrub(); System.out.println(x); &#125; &#125; public class Detergent extends Cleanser &#123; // Change a method: public void scrub() &#123; append(&quot; Detergent.scrub()&quot;); super.scrub(); // Call base-class version &#125; // Add methods to the interface: public void foam() &#123; append(&quot; foam()&quot;); &#125; // Test the new class: public static void main(String[] args) &#123; Detergent x = new Detergent(); x.dilute(); x.apply(); x.scrub(); x.foam(); System.out.println(x); System.out.println(&quot;Testing base class:&quot;); Cleanser.main(args); &#125; &#125; 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; NewDetergent newDetergent = new NewDetergent(); newDetergent.dilute(); newDetergent.scrub(); newDetergent.sterilize(); System.out.println(newDetergent); &#125;&#125;class NewDetergent extends Detergent&#123; public void scrub() &#123; append(&quot;new Detergent.scrub&quot;); super.scrub(); &#125; public void sterilize() &#123; append(&quot;sterilize&quot;); &#125;&#125; 练习3：证明前面两句话（即使你不为Cartoon创建构造器，编译器也为会你合成一个默认的构造器，该构造器将调用基类的构造器） 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; new Cartoon(); &#125;&#125;class Art&#123; Art()&#123; System.out.println(&quot;Art constructor&quot;); &#125;&#125;class Drawing extends Art&#123; Drawing()&#123; System.out.println(&quot;Drawing Contructor&quot;); &#125;&#125;class Cartoon extends Drawing&#123;// public Cartoon() &#123;// System.out.println(&quot;Cartoon Contructor&quot;);// &#125;&#125;/*Output:Art constructorDrawing Contructor*///:~ 练习4：证明基类构造器总是会被调用，在导出类构造器之前被调用。 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; new Derived2(); &#125;&#125;class Base1&#123; public Base1() &#123; System.out.println(&quot;Base1&quot;); &#125;&#125;class Derived1 extends Base1&#123; public Derived1() &#123; System.out.println(&quot;Derived&quot;); &#125;&#125;class Derived2 extends Derived1&#123; public Derived2() &#123; System.out.println(&quot;Derived2&quot;); &#125;&#125; 练习5：创建两个带有默认构造器（空参数列表）的类A和类B。从A中继承产生一个名为C的新，并在C内创建一个B类的成员。不要给C编写构造器。创建一个C类的对象并观察其结果。 12345678910111213141516171819202122class A&#123; A() &#123; System.out.println(&quot;A()&quot;); &#125;&#125;class B&#123; B() &#123; System.out.println(&quot;B()&quot;); &#125;&#125;class C extends A&#123; B b = new B();&#125;public class Test &#123; public static void main(String[] args) &#123; new C(); &#125;&#125;/*Output:A()B()*///:~ 练习7：修改练习5，使A和B以带参数的构造器取代默认的构造器。为C写一个构造器，并在其中执行所有初始化。 12345678910111213141516171819202122class A&#123; A(int i) &#123; System.out.println(&quot;A()&quot;); &#125;&#125;class B&#123; B(String i) &#123; System.out.println(&quot;B()&quot;); &#125;&#125;class C extends A&#123; C()&#123; super(1); B b = new B(&quot;s&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new C(); &#125;&#125; 练习8：创建一个基类，它仅有一个非默认构造器；再创建一个导出类，它带有默认构造器和非默认构造器。在导出类的构造器中调用基类的构造器。 123456789101112131415161718class A&#123; A(int i)&#123; System.out.println(&quot;A()&quot;); &#125;&#125;public class Test extends A&#123; Test()&#123; super(1); &#125; Test(int i)&#123; super(i); &#125; public static void main(String[] args) &#123; new Test(); new Test(2); &#125;&#125; 练习9：创建一个Root类，令其含有名为Component1、Component 2、Component3的类的各一个实例（这些也由你写）。从Root中派生一个类Stem，也含有上述各“组成部分”。所有的类都应带有可打印出类的相关信息的默认构造器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Component1&#123; Component1()&#123; System.out.println(&quot;Component1&quot;); &#125;&#125;class Component2&#123; Component2()&#123; System.out.println(&quot;Component2&quot;); &#125;&#125;class Component3&#123; Component3()&#123; System.out.println(&quot;Component3&quot;); &#125;&#125;class Root &#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Root()&#123; System.out.println(&quot;Root()&quot;); &#125;&#125;class Stem extends Root&#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Stem()&#123; System.out.println(&quot;Stem()&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Stem s = new Stem(); &#125;&#125;/*Output:Component1Component2Component3Root()Component1Component2Component3Stem()*///:~ 练习10：修改练习9，使每个类都仅具有非默认的构造器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Component1&#123; Component1()&#123; System.out.println(&quot;Component1&quot;); &#125;&#125;class Component2&#123; Component2()&#123; System.out.println(&quot;Component2&quot;); &#125;&#125;class Component3&#123; Component3()&#123; System.out.println(&quot;Component3&quot;); &#125;&#125;class Root &#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Root(int i)&#123; System.out.println(&quot;Root()&quot;); &#125;&#125;class Stem extends Root&#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Stem(int i)&#123; super(i); System.out.println(&quot;Stem()&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Stem s = new Stem(1); &#125;&#125;/*Output:Component1Component2Component3Root()Component1Component2Component3Stem()*///:~ 练习12：将一个适当的dispose()方法的层次结构添加到练习9的所有类中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Component1&#123; Component1()&#123; System.out.println(&quot;Component1&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Componentc1.dispose()&quot;); &#125;&#125;class Component2&#123; Component2()&#123; System.out.println(&quot;Component2&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Componentc2.dispose()&quot;); &#125;&#125;class Component3&#123; Component3()&#123; System.out.println(&quot;Component3&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Componentc3.dispose()&quot;); &#125;&#125;class Root &#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Root()&#123; System.out.println(&quot;Root()&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Root.dispose()&quot;); c1.dispose(); c2.dispose(); c3.dispose(); &#125;&#125;class Stem extends Root&#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Stem()&#123; System.out.println(&quot;Stem()&quot;); &#125; public void dispose() &#123; System.out.println(&quot;Stem.dispose()&quot;); c1.dispose(); c2.dispose(); c3.dispose(); super.dispose(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new Stem().dispose(); &#125;&#125;/*Output:Component1Component2Component3Root()Component1Component2Component3Stem()Stem.dispose()Componentc1.dispose()Componentc2.dispose()Componentc3.dispose()Root.dispose()Componentc1.dispose()Componentc2.dispose()Componentc3.dispose()*///:~ 练习13:创建一个类，它应带有一个被重载了三次的方法。继承产生一个新类，并添加一个该方法的新的重载定义，展示这四个方法在导出类中都是可以使用的。 1234567891011121314151617181920212223242526272829class A&#123; void Overload(int i) &#123; System.out.println(&quot;A1&quot;); &#125; void Overload(String i) &#123; System.out.println(&quot;A2&quot;); &#125; void Overload(float i) &#123; System.out.println(&quot;A3&quot;); &#125;&#125;public class Test extends A&#123; void Overload(char i) &#123; System.out.println(&quot;Test&quot;); &#125; public static void main(String[] args) &#123; Test test = new Test(); test.Overload(1); test.Overload(&quot;1&quot;); test.Overload(1f); test.Overload(&apos;1&apos;); &#125;&#125;/*Output:A1A2A3Test*///:~ 练习14：在Car.java中给Engine添加一个service(),并在main()中调用该方法。 123456789101112131415161718192021222324252627282930313233343536class Engine&#123; public void start() &#123;&#125; public void rev() &#123;&#125; public void stop() &#123;&#125; public void service() &#123;&#125;&#125;class Wheel&#123; public void inflate(int psi) &#123;&#125;&#125;class Window&#123; public void rollup() &#123;&#125; public void rolldown() &#123;&#125;&#125;class Door&#123; public Window window = new Window(); public void open() &#123;&#125; public void close() &#123;&#125;&#125;public class Car&#123; private Engine engine = new Engine(); private Wheel[] wheel = new Wheel[4]; public Door left = new Door(), right = new Door(); public Car() &#123; for(int i=0;i&lt;4;i++) &#123; wheel[i] = new Wheel(); &#125; &#125; public static void main(String[] args) &#123; Car car = new Car(); car.left.window.rollup(); car.wheel[0].inflate(72); car.engine.service(); &#125;&#125; 练习15：在包中编写一个类，类应具备一个protected方法。在包外部，试着调用protede方法并解释其结果。然后，从你的类中继承产生一个类，并从该导出类的方法内部调用该protected方法 1234567package test1982;public class A&#123; protected void f() &#123; System.out.println(&quot;f()&quot;); &#125;&#125; 12345678910111213package test;import test1982.*;class B extends A&#123; public void g() &#123; f(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; new B().g(); &#125;&#125; 练习16：创建一个名为Amphibian的类，由此继承产生一个成为Frog的类，在基类中设置适当的方法，在main（）中，创建一个Frog向上转型至Amphibian， 然后说明所有方法都可工作。 1234567891011121314class Amphibian&#123; public void f() &#123; System.out.println(&quot;f()&quot;); &#125;&#125;class Frog extends Amphibian&#123; &#125;public class Test&#123; public static void main(String[] args) &#123; Amphibian am =new Frog(); am.f(); &#125;&#125; 练习17：修改练习16，使Frog覆盖基类中方法的定义。请留心main中都发生了什么 12345678910111213141516class Amphibian&#123; public void f() &#123; System.out.println(&quot;Amphibian.f()&quot;); &#125;&#125;class Frog extends Amphibian&#123; public void f() &#123; System.out.println(&quot;Frog.f()&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Amphibian am =new Frog(); am.f(); &#125;&#125; 练习18：创建一个含有static final域和final域的类，说明二者间的区别。 123456789101112131415161718192021222324252627282930313233public class Exercise7_18 &#123; public static void main(String[] args) &#123; System.out.println(&quot;First Object&quot;); System.out.println(new WithFinalFields()); System.out.println(&quot;Second Object&quot;); System.out.println(new WithFinalFields()); &#125;&#125;class SelfCounter &#123; private static int count; private int id = count++; public String toString() &#123; return &quot;Selfcounter&quot; + id; &#125;&#125;class WithFinalFields &#123; final SelfCounter selfCounter = new SelfCounter(); static final SelfCounter s = new SelfCounter(); public String toString() &#123; return &quot;selfcounter = &quot; + selfCounter + &quot; \ns = &quot; + s; &#125;&#125;/*Output:First Objectselfcounter = Selfcounter1 s = Selfcounter0Second Objectselfcounter = Selfcounter2 s = Selfcounter0*///:~ 练习20：展示@Override注解可以解决本节中的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class WithFinals &#123; // Identical to &quot;private&quot; alone: private final void f() &#123; System.out.println(&quot;WithFinals.f()&quot;); &#125; // Also automatically &quot;final&quot;: private void g() &#123; System.out.println(&quot;WithFinals.g()&quot;); &#125;&#125;class OverridingPrivate extends WithFinals &#123; private final void f() &#123; System.out.println(&quot;OverridingPrivate.f()&quot;); &#125; private void g() &#123; System.out.println(&quot;OverridingPrivate.g()&quot;); &#125;&#125;class OverridingPrivate2 extends OverridingPrivate &#123; public final void f() &#123; System.out.println(&quot;OverridingPrivate2.f()&quot;); &#125; public void g() &#123; System.out.println(&quot;OverridingPrivate2.g()&quot;); &#125;&#125;public class FinalOverridingIllusion &#123; public static void main(String[] args) &#123; OverridingPrivate2 op2 = new OverridingPrivate2(); op2.f(); op2.g(); // You can upcast: OverridingPrivate op = op2; // But you can&apos;t call the methods: // ! op.f(); // ! op.g(); // Same here: WithFinals wf = op2; // ! wf.f(); // ! wf.g(); &#125;&#125; 12345678910111213141516171819202122232425262728293031public class Exercise7_20 &#123; public static void main(String[] args) &#123; OverridingPrivate20 oPrivate = new OverridingPrivate20(); // oPrivate.f(); // oPrivate.g(); &#125;&#125;class OverridingPrivate20 extends WithFinals &#123; @Override private final void f() &#123; System.out.println(&quot;OverridingPrivate.f()&quot;); &#125; @Override private void g() &#123; System.out.println(&quot;OverridingPrivate.g()&quot;); &#125;&#125;class OverridingPrivate30 extends OverridingPrivate20 &#123; @Override public void f() &#123; System.out.println(&quot;OverridingPrivate2.f()&quot;); &#125; @Override public void g() &#123; System.out.println(&quot;OverridingPrivate2.g()&quot;); &#125;&#125; 练习21：创建一个但final方法的类。由此继承产生一个类并尝试覆盖该方法 1234567891011121314public class Exercise7_21 extends WithFinalMethod &#123;// void f() &#123;// // &#125; public static void main(String[] args) &#123; &#125;&#125;class WithFinalMethod &#123; final void f() &#123; &#125;&#125; 练习23：请证明加载类的动作仅发生一次。证明该类的第一个实体的创建者或者对static成员的访问都有可能引起加载 1234567891011121314public class Exercise7_23 &#123; public static void main(String[] args) &#123; System.out.println(&quot;Calling static member&quot;); LoadTest.staticMember(); System.out.println(&quot;Creating an object&quot;); new LoadTest(); &#125;&#125;class LoadTest&#123; static&#123; System.out.println(&quot;Loading loadTest&quot;); &#125; static void staticMember() &#123;&#125;;&#125; 练习24：在Beetle.java中，从Beetle类继承产生一个具体类型的“甲壳虫”。其形式与现有类相同，跟踪并解释其输出结果]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java惰性初始化]]></title>
    <url>%2F2019%2F08%2F19%2FJava%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Java惰性初始化 在书中第七章中提到了引用的初始化，编译器并不是简单地为每一个引用都创建默认对象，减少不必要的负担 1、在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。2、在类的构造器中。3、就在正要使用这些对象之前，这种方式称为惰性初始化。在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担。4、使用实例初始化。 惰性初始化的目的是延迟对象的初始化，直到程序真正使用它，同时确保它只初始化一次。 /*惰性初始化：当需要一个实例的时候才初始化一个对象。新建两个简单的类，第二个类中包含第一个类的一个引用，当需要第一个类的对象是调用Lazy()方法即可获得第一个类的对象。*/ 123456789101112131415161718class First&#123; First()&#123; System.out.print(&quot;First()&quot;); &#125;&#125;public class Lazy&#123; First f; public void print()&#123; if(f==null) f = new First(); &#125; public static void main(String[] args)&#123; Lazy z = new Lazy(); z.print(); &#125;&#125;/*Output:First()*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程思想第五章练习]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[编程思想第五章练习 练习1：创建一个类,它包含一个未初始化的String引用.验证该引用被Java初始化成null 12345678910class Test&#123; public String string;&#125;public class E1 &#123; public static void main(String[] args) &#123; Test test = new Test(); System.out.println((test.string == null)); &#125;&#125; 练习2：创建一个类，它包含一个在定义时就被初始化了的String域，以及另一个通过构造器初始化的String域。这两种方式有何差异。 12345678910111213public class Test &#123; String s1=&quot;Initialized at definition&quot;; String s2; public Test(String s) &#123; s2 = s; &#125; public static void main(String[] args) &#123; Test test = new Test(&quot;Initialized at constructor&quot;); System.out.println(&quot;s1= &quot;+test.s1); System.out.println(&quot;s2= &quot;+test.s2); &#125;&#125; 练习3：创建一个带默认构造器（即无参构造器）的类，在构造器中打印一条消息。为这个类创建一个对象。 12345678910class T1&#123; T1()&#123; System.out.println(&quot;无参构造器&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new T1(); &#125;&#125; 练习4：为前一个练习中的类添加一个重载构造器，令其接受一个字符参数，并在构造器中把你自己的信息和接受的参数一起打印出来。 1234567891011121314151617class T1&#123; T1()&#123; System.out.println(&quot;这是无参构造器&quot;); &#125; T1(String s)&#123; System.out.println(&quot;这是&quot;+s); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new T1(); new T1(&quot;重载构造器&quot;); &#125;&#125;/*Output:这是无参构造器这是重载构造器*///:~ 练习5：创建一个名为Dog的类，它具有重载的bark（）方法。此方法应根据不同的基本数据类型进行重载，并根据被调用的版本，打印出不同类型的狗吠（barking）、咆哮（howling）等信息，编写main（）来调用所有不同版本的方法。 123456789101112131415161718class Dog&#123; void bark() &#123; System.out.println(&quot;barking&quot;); &#125; void bark(int i) &#123; System.out.println(&quot;howling&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.bark(); dog.bark(1); &#125;&#125;/*Output:barkinghowling*///:~ 练习6：修改前一个练习的程序，让两个重载方法各自接受两个类型的不同的参数，但二者顺序相反。验证其是否工作。 123456789101112131415161718class Dog&#123; void bark(float f,int i) &#123; System.out.println(&quot;barking&quot;); &#125; void bark(int i,float f) &#123; System.out.println(&quot;howling&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.bark(1.1f,1); dog.bark(1,1.1f); &#125;&#125;/*Output:barkinghowling*///:~ 练习7：创建一个没有构造器的类，并在main（）中创建其对象，用以验证编译器是否真的自动加入了默认构造器。 12345678class Dog&#123; &#125;public class Test &#123; public static void main(String[] args) &#123; new Dog(); &#125;&#125; 练习8：编写具有两个方法的类，在第一个方法内调用第二个方法两次：第一次调用时不使用this关键字，第二次调用时使用this关键字————这里只是为了验证它是起作用的，你不应该在实践中使用这种方法。 12345678910111213141516public class Test&#123; void t1() &#123; t2(); this.t2(); &#125; void t2() &#123; System.out.println(&quot;t2()&quot;); &#125; public static void main(String[] args) &#123; new Test().t1(); &#125;&#125;/*Output:t2()t2()*///:~ 练习14：编写一个类，拥有两个静态字符串域，其中一个在定义处初始化，另一个在静态块中初始化。现在，加入一个静态方法用以打印出两个字段值。请证明它们都会在被使用之前完成初始化动作。 12345678910111213141516public class Test&#123; static String a = &quot;a&quot;; static String b; static &#123; b = &quot;b&quot;; &#125; void print() &#123; System.out.println(a); System.out.println(b); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 练习15：编写一个含有字符串域的类，并采用实例初始化方式进行初始化。 123456789101112131415class Test&#123; String s; &#123; s = new String(&quot;s&quot;); &#125; Test ()&#123; System.out.println(s); &#125; &#125;public class Mugs&#123; public static void main(String[] args) &#123; Test test = new Test(); &#125;&#125; 练习16：创建一个String对象数据，并为每一个元素都赋值一个String。用for循环来打印该数组。 1234567891011121314public class Test&#123; public static void main(String[] args) &#123; String[] arrayString = &#123;&quot;1111&quot;,&quot;2222&quot;,&quot;3333&quot;,&quot;4444&quot;&#125;; for(String s:arrayString) &#123; System.out.println(s); &#125; &#125;&#125;/*Output:1111222233334444*///:~ 练习17、18：创建一个类，它有一个构造器，这个构造器接收一个String类型的参数。在构造阶段，打印此参数。创建一个该类对象的引用数组，但是不实际地创建对象赋值给该数组。试着运行程序。再试着通过创建对象，再赋值给引用数组，从而完成程序。 12345678910111213141516class TestString&#123; TestString(String string)&#123; System.out.println(string); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; TestString[] tests = new TestString[] &#123; new TestString(&quot;a&quot;), new TestString(&quot;b&quot;) &#125;; &#125;&#125;/*Output:ab*///:~ 练习19：写一个类，他接受一个可变参数的String数组，验证你可以向该方法传递一个用逗号分隔的String列表，或是一个String[] 123456789101112public class Test&#123; static void printString(String... args) &#123; for(String s:args) &#123; System.out.print(s+&quot; &quot;); &#125; &#125; public static void main(String[] args) &#123; printString(new String[] &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;); &#125;&#125;/*Output:a b c *///:~ 练习20：创建一个使用可变参数列表而不是用普通main()语法的主函数main()，打印args数组的传入的命令行参数。 1234567public class Test&#123; public static void main(String... args) &#123; for(String s:args) &#123; System.out.println(s); &#125; &#125;&#125; 练习21：创建一个enum，它包含纸币中最小面值的6种类型。通过values()循环并打印每一个值及其ordinal() 12345678910111213141516enum Money&#123; One,Five,Ten,Twe,Fif&#125;public class Test&#123; public static void main(String[] args) &#123; for(Money s:Money.values()) &#123; System.out.println(s+&quot;,ordinal:&quot;+s.ordinal()); &#125; &#125;&#125;/*Output:One,ordinal:0Five,ordinal:1Ten,ordinal:2Twe,ordinal:3Fif,ordinal:4*///:~ 练习22：在前面的例子中，为enum写一个switch语句，对于每一个case，输出该特定货币的描述。 123456789101112131415161718192021222324252627282930313233343536373839404142enum Money&#123; One,Five,Ten,Twe,Fif&#125;class A&#123; void describe(Money s)&#123; switch(s) &#123; case One: System.out.println(&quot;1&quot;); break; case Five: System.out.println(&quot;5&quot;); break; case Ten: System.out.println(&quot;10&quot;); break; case Twe: System.out.println(&quot;20&quot;); break; case Fif: System.out.println(&quot;30&quot;); break; default: break; &#125; &#125; &#125;public class Test&#123; public static void main(String[] args) &#123; A a = new A(); for(Money s:Money.values()) &#123; System.out.print(s +&quot;:&quot;); a.describe(s); &#125; &#125;&#125;/*Output:One:1Five:5Ten:10Twe:20Fif:30*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组初始化]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数组初始化 数组初始化123456789101112131415161718public class Test&#123; public static void main(String[] args) &#123; int[] a1 = &#123;1,2,3,4,5&#125;; int[] a2; a2=a1; for(int i =0;i&lt;a2.length;i++) a2[i]=a2[i]+1; for(int i =0;i&lt;a2.length;i++) System.out.print(a1[i]+&quot; &quot;); System.out.println(); for(int i =0;i&lt;a2.length;i++) System.out.print(a2[i]+&quot; &quot;); &#125;&#125;/*Output:2 3 4 5 6 2 3 4 5 6 *///:~ a1赋值给了a2，a2赋值后，发现a1数组改变，输出a1和a2后发现相等]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java主函数的调用]]></title>
    <url>%2F2019%2F08%2F10%2FJava%E4%B8%BB%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java主函数的调用 一个java文件里可以存在多个class，但是只能有一个public class 你可以创建一个String对象数组，将其传递给另一个main（）方法，以提供参数，用来替换传递给该main（）方法的命令行参数。 12345678910111213141516public class DynamicArray&#123; public static void main(String[] args) &#123; Other.main(new String[] &#123;&quot;fiddle&quot;,&quot;de&quot;,&quot;dum&quot;&#125;); &#125;&#125;class Other&#123; public static void main(String[] args) &#123; for(String s:args) &#123; System.out.println(s+&quot; &quot;); &#125; &#125;&#125;/*Output:fiddle de dum *///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造器初始化]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[构造器初始化 初始化顺序在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。 123456789101112131415161718192021222324252627282930class Window&#123; Window(int marker)&#123; System.out.println(&quot;Window(&quot;+marker+&quot;)&quot;); &#125;&#125;class House&#123; Window w1 = new Window(1); House()&#123; System.out.println(&quot;House()&quot;); w3 = new Window(33); &#125; Window w2 = new Window(2); void f() &#123; System.out.println(&quot;f()&quot;); &#125; Window w3 = new Window(3);&#125;public class Flower&#123; public static void main(String[] args) &#123; House h = new House(); h.f(); &#125;&#125;/*Output:Window(1)Window(2)Window(3)House()Window(33)f()*///:~ w3这个引用会被初始化两次：一次在调用构造器前，一次在调用期间（第一次引用的对象将被丢弃，并作为垃圾回收） 静态数据的初始化1、无论创建多少个对象，静态数据都只占用一份存储区域。2、static关键字不能应用于局部变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Bowl&#123; Bowl(int marker)&#123; System.out.println(&quot;Bowl(&quot;+marker+&quot;)&quot;); &#125; void f1(int marker) &#123; System.out.println(&quot;f1(&quot;+marker+&quot;)&quot;); &#125;&#125;class Table&#123; static Bowl bowl1 = new Bowl(1); Table()&#123; System.out.println(&quot;Table()&quot;); bowl2.f1(1); &#125; void f2(int marker) &#123; System.out.println(&quot;f2(&quot;+marker+&quot;)&quot;); &#125; static Bowl bowl2 = new Bowl(2);&#125;class Cupboard&#123; Bowl bowl3 = new Bowl(3); static Bowl bowl4 = new Bowl(4); Cupboard()&#123; System.out.println(&quot;Cupboard()&quot;); bowl4.f1(2); &#125; void f3(int marker) &#123; System.out.println(&quot;f3(&quot;+marker+&quot;)&quot;); &#125; static Bowl bowl5 = new Bowl(5);&#125;public class Flower&#123; public static void main(String[] args) &#123; System.out.println(&quot;Creating new Cupboard() in main&quot;); new Cupboard(); System.out.println(&quot;Creating new Cupboard() in main&quot;); new Cupboard(); table.f2(1); cupboard.f3(1); &#125; static Table table = new Table(); static Cupboard cupboard = new Cupboard();&#125;/*Output:Bowl(1)Bowl(2)Table()f1(1)Bowl(4)Bowl(5)Bowl(3)Cupboard()f1(2)Creating new Cupboard() in mainBowl(3)Cupboard()f1(2)Creating new Cupboard() in mainBowl(3)Cupboard()f1(2)f2(1)f3(1)*///:~ 初始化时静态对象会先初始化，而后是非静态对象 总结对象的创建过程1、即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。2、然后载入Dog.class，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。3、当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。4、这块存储空间会被清零，这就自动地将Dog对象中地所有基本类型数据设置成了默认值（对数字来说就是0，对布尔型和字符型也相同），而引用则被设置成了null。5、执行所有出现于字段定义处地初始化动作。6、执行构造器。 显式的静态初始化（代码不理解，这里先做下标记把，有空再慢慢看）123456789101112131415161718192021222324252627282930class Cup&#123; Cup(int marker)&#123; System.out.println(&quot;Cup(&quot;+marker+&quot;)&quot;); &#125; void f(int marker) &#123; System.out.println(&quot;f(&quot;+marker+&quot;)&quot;); &#125;&#125;class Cups&#123; static Cup cup1; static Cup cup2; static &#123; cup1 = new Cup(1); cup2 = new Cup(2); &#125; Cups()&#123; System.out.println(&quot;Cups()&quot;); &#125;&#125;public class Flower&#123; public static void main(String[] args) &#123; System.out.println(&quot;Inside main()&quot;); Cups.cup1.f(99); &#125;&#125;/*Output:Inside main()Cup(1)Cup(2)f(99)*///:~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2F2019%2F08%2F09%2Fthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[编程思想第五章5.4中,这一段代码看着有点懵逼，记下来 12345678910111213141516171819202122class Person&#123; void eat(Apple apple) &#123; Apple peeled =apple.getPeeled(); System.out.println(&quot;Yummy&quot;); &#125;&#125;class Peeler&#123; static Apple peel(Apple apple) &#123; return apple; &#125;&#125;class Apple&#123; Apple getPeeled() &#123; return Peeler.peel(this); &#125;&#125;public class Leaf &#123; public static void main(String[] args) &#123; new Person().eat(new Apple()); &#125;&#125; Apple需要调用Peeler.peel（）方法，它是一个外部的工具方法，将执行由于某种原因而必须放在Apple外部的操作。为了将自身传递给外部方法，Apple必须使用this关键字。 在构造器中调用构造器1234567891011121314151617181920212223242526272829303132333435public class Flower&#123; int petalCount = 0; String s=&quot;initial value&quot;; Flower(int petals)&#123; petalCount = petals; System.out.println(&quot;Constructor w/ int arg only,petalCount= &quot;+petalCount); &#125; Flower(String ss)&#123; System.out.println(&quot;Constructor w/ String arg only,s= &quot;+ss); s=ss; &#125; Flower(String s,int petals)&#123; this(petals); //this(s); //Can&apos;t call two! this.s=s; System.out.println(&quot;String &amp; int args&quot;); &#125; Flower()&#123; this(&quot;hi&quot;,47); System.out.println(&quot;default constructor (no args)&quot;); &#125; void printPetalCount() &#123; //this(11); //Not inside non-constructor! System.out.println(&quot;petalCount = &quot;+petalCount+&quot; s= &quot;+s); &#125; public static void main(String[] args) &#123; Flower x = new Flower(); x.printPetalCount(); &#125;&#125;/*Output:Constructor w/ int arg only,petalCount= 47String &amp; int argsdefault constructor (no args)petalCount = 47 s= hi*///:~ this调用构造器不能调用两个。构造器调用必须置于起始值。调用构造器只能在构造器中调用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java方法重载]]></title>
    <url>%2F2019%2F08%2F08%2FJava%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Java方法重载 示范重载构造器和重载的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445class Tree&#123; int height; Tree()&#123; System.out.println(&quot;Planting a seedling&quot;); height= 0; &#125; Tree(int initialHeight)&#123; height = initialHeight; System.out.println(&quot;Creating new Tree that is &quot;+height+&quot; feet tall&quot;); &#125; void info() &#123; System.out.println(&quot;Tree is &quot;+height+&quot;feet tall&quot;); &#125; void info(String s) &#123; System.out.println(s+&quot;:Tree is &quot;+height+&quot;feet tall&quot;); &#125;&#125;public class Overloading &#123; public static void main(String[] args) &#123; for(int i=0;i&lt;5;i++) &#123; Tree t = new Tree(i); t.info(); t.info(&quot;overloaded method&quot;); &#125; new Tree(); &#125;&#125;/*Output:Creating new Tree that is 0 feet tallTree is 0feet talloverloaded method:Tree is 0feet tallCreating new Tree that is 1 feet tallTree is 1feet talloverloaded method:Tree is 1feet tallCreating new Tree that is 2 feet tallTree is 2feet talloverloaded method:Tree is 2feet tallCreating new Tree that is 3 feet tallTree is 3feet talloverloaded method:Tree is 3feet tallCreating new Tree that is 4 feet tallTree is 4feet talloverloaded method:Tree is 4feet tallPlanting a seedling*///:~ 涉及基本类型的重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179public class PrimitiveOverloading &#123; void f1(char x) &#123; System.out.println(&quot;f1(char) &quot;); &#125; void f1(byte x) &#123; System.out.println(&quot;f1(byte) &quot;); &#125; void f1(short x) &#123; System.out.println(&quot;f1(short) &quot;); &#125; void f1(int x) &#123; System.out.println(&quot;f1(int) &quot;); &#125; void f1(long x) &#123; System.out.println(&quot;f1(long) &quot;); &#125; void f1(float x) &#123; System.out.println(&quot;f1(float) &quot;); &#125; void f1(double x) &#123; System.out.println(&quot;f1(double) &quot;); &#125; void f2(byte x) &#123; System.out.println(&quot;f2(byte) &quot;); &#125; void f2(short x) &#123; System.out.println(&quot;f2(short) &quot;); &#125; void f2(int x) &#123; System.out.println(&quot;f2(int) &quot;); &#125; void f2(long x) &#123; System.out.println(&quot;f2(long) &quot;); &#125; void f2(float x) &#123; System.out.println(&quot;f2(float) &quot;); &#125; void f2(double x) &#123; System.out.println(&quot;f2(double) &quot;); &#125; void f3(short x) &#123; System.out.println(&quot;f3(short) &quot;); &#125; void f3(int x) &#123; System.out.println(&quot;f3(int) &quot;); &#125; void f3(long x) &#123; System.out.println(&quot;f3(long) &quot;); &#125; void f3(float x) &#123; System.out.println(&quot;f3(float) &quot;); &#125; void f3(double x) &#123; System.out.println(&quot;f3(double) &quot;); &#125; void f4(int x) &#123; System.out.println(&quot;f4(int) &quot;); &#125; void f4(long x) &#123; System.out.println(&quot;f4(long) &quot;); &#125; void f4(float x) &#123; System.out.println(&quot;f4(float) &quot;); &#125; void f4(double x) &#123; System.out.println(&quot;f4(double) &quot;); &#125; void f5(long x) &#123; System.out.println(&quot;f5(long) &quot;); &#125; void f5(float x) &#123; System.out.println(&quot;f5(float) &quot;); &#125; void f5(double x) &#123; System.out.println(&quot;f5(double) &quot;); &#125; void f6(float x) &#123; System.out.println(&quot;f6(float) &quot;); &#125; void f6(double x) &#123; System.out.println(&quot;f6(double) &quot;); &#125; void f7(double x) &#123; System.out.println(&quot;f7(double) &quot;); &#125; void testConstVal() &#123; System.out.println(&quot;5: &quot;); f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5); System.out.println(); &#125; void testChar() &#123; char x = &apos;x&apos;; System.out.println(&quot;char: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testByte() &#123; byte x =0; System.out.println(&quot;byte: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testShort() &#123; short x =0; System.out.println(&quot;short: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testInt() &#123; int x =0; System.out.println(&quot;int: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testLong() &#123; long x =0; System.out.println(&quot;long: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testFloat() &#123; float x =0; System.out.println(&quot;float: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; void testDouble() &#123; double x =0; System.out.println(&quot;double: &quot;); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); System.out.println(); &#125; public static void main(String[] args) &#123; PrimitiveOverloading p = new PrimitiveOverloading(); p.testConstVal(); p.testChar(); p.testByte(); p.testShort(); p.testInt(); p.testLong(); p.testFloat(); p.testDouble(); &#125;&#125;/*Output:5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double) short: f1(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double) int: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) long: f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double) float: f1(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double) double: f1(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double) *///:~ 如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。 如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。12345void testDouble() &#123; double x =0; System.out.println(&quot;double argument: &quot;); f1(x);f2((double)x);f3((long)x);f4((int)x);f5((short)x);f6((byte)x);f7((char)x); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
        <tag>重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java标签]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Java标签 Java标签,博文内容剽窃于Thinking in Java第四版四章4.7 (●’◡’●)12345678910111213label1:outer-iteration&#123; inner-iteration&#123; //... break; //(1) //... continue; //(2) //... continue label1; //(3) //... break label1; //(4) &#125;&#125; 在（1）中，break中断内部迭代。在（2）中，continue使执行点移回内部迭代的起始值。在（3）中，continue label1同时中断内部迭代以及外部迭代，直接转到label1处；随后，它实际上是继续迭代过程，但却从外部迭代开始。在（4）中，break label1也会中断所有迭代，并回到label1处，但并不重新进入迭代。也就是说，它实际是完全中止了两个迭代。 123456789101112131415161718192021222324252627282930313233343536public class Test&#123; public static void main(String[] args)&#123; int i=0; outer: for(;true;) &#123; inner: for(;i&lt;10;i++) &#123; System.out.println(&quot;i= &quot;+i); if(i==2) &#123; System.out.println(&quot;continue&quot;); continue; &#125; if(i==3) &#123; System.out.println(&quot;break&quot;); i++; //由于break跳过了递增表达式，所以这里添加了递增运算 break; &#125; if(i==7) &#123; System.out.println(&quot;continue outer&quot;); i++; //添加了递增运算 continue outer; &#125; if(i==8) &#123; System.out.println(&quot;break outer&quot;); break outer; &#125; for(int k=0;k&lt;5;k++) &#123; if(k==3) &#123; System.out.println(&quot;continue inner&quot;); continue inner; &#125; &#125; &#125; &#125; &#125;&#125; Output:i= 0continue inneri= 1continue inneri= 2continuei= 3breaki= 4continue inneri= 5continue inneri= 6continue inneri= 7continue outeri= 8break outer break和continue本身只能中断最内层的循环 带标签的break以及continue语句在while循环中的用法：1234567891011121314151617181920212223242526272829public class Test&#123; public static void main(String[] args)&#123; int i=0; outer: while(true) &#123; System.out.println(&quot;Outer while loop&quot;); while(true) &#123; i++; System.out.println(&quot;i= &quot;+i); if(i==1) &#123; System.out.println(&quot;continue&quot;); continue; &#125; if(i==3) &#123; System.out.println(&quot;continue outer&quot;); continue outer; &#125; if(i==5) &#123; System.out.println(&quot;break&quot;); break; &#125; if(i==7) &#123; System.out.println(&quot;break outer&quot;); break outer; &#125; &#125; &#125; &#125;&#125; Output:Outer while loopi= 1continuei= 2i= 3continue outerOuter while loopi= 4i= 5breakOuter while loopi= 6i= 7break outer 同样的规则亦适用于while:1、一般的continue会退出最内层循环开头（顶部），并继续执行。2、带标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。3、一般的break会中断并跳出当前循环。4、带标签的break会中断并跳出标签所指的循环。 在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想第四章练习]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Java编程思想第四章练习 第四章练习1：写一个程序，打印从1到100的值。 1234567public class Test&#123; public static void main(String[] args) &#123; for(int i=1;i&lt;=100;i++) &#123; System.out.println(i); &#125; &#125;&#125; 练习2：写一个程序,产生25个int类型的随机数.对于每一个随机值,使用if-else语句来讲其分类为大于，小于,或等于紧随它产生的值 1234567891011121314151617181920public class Test &#123; public static void main(String[] args)&#123; int num[] =new int[25]; for (int i=0;i&lt;25;i++)&#123; num[i]=(int)(Math.random()*100); &#125; for (int j=0;j&lt;num.length-1;j++)&#123;//一共产生了25个数，需要比较24次，所以j的循环次数是num.length-1次。 if (num[j]&gt;num[j+1])&#123; System.out.println(num[j]+&quot;大于&quot;+&quot;后面的数&quot;+num[j+1]); &#125; else if (num[j]&lt;num[j+1])&#123; System.out.println(num[j]+&quot;小于&quot;+&quot;后面的数&quot;+num[j+1]); &#125; else &#123; System.out.println(num[j]+&quot;等于&quot;+&quot;后面的数&quot;+num[j+1]); &#125; &#125; &#125;&#125; 运行及结果：39小于后面的数7070大于后面的数3030小于后面的数6161大于后面的数5757小于后面的数7676小于后面的数8383大于后面的数1313大于后面的数33小于后面的数3838小于后面的数6060大于后面的数5757小于后面的数7575大于后面的数1212小于后面的数5252小于后面的数6262小于后面的数8484大于后面的数5151大于后面的数1818小于后面的数5959小于后面的数6464大于后面的数4141小于后面的数9898大于后面的数5454大于后面的数51 练习4：写一个程序,使用两个嵌套的for循环和取余操作符来探测和打印素数 12345678910111213141516public class Test &#123; public static void main(String[] args)&#123; boolean flog; for(int i=2;i&lt;=100;i++) &#123; flog=true; for(int j=2;j&lt;i;j++) &#123; if(i%j==0) &#123; flog=false; &#125; &#125; if(flog==true) &#123; System.out.println(i+&quot; &quot;); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 练习5：重复第三章中的练习10，不要用Integer.toBinaryString()方法，而是用三元操作符和按位操作符来显示二进制0和1. 1emmmmmmmmmm 练习7：修改本章练习1，通过使用break关键词（或者return关键词），使其只输出范围为1~99的值。 123456789public class Test&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(i); if(i==99) break; //return &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中break和continue的区别]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E4%B8%ADbreak%E5%92%8Ccontinue%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java中break和continue的区别 在任何迭代语句的主体部分，都可用break和continue控制循环的流程break1、break用于强行退出循环。2、退出后不执行循环中剩余的语句 continue1、停止执行当前的迭代2、退回循环起始处，开始下一次迭代 123456789101112131415161718public class Test&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;=5;i++) &#123; if(i==3) &#123; break; &#125; System.out.println(i); &#125; System.out.println(&quot;===============&quot;); for(int i=0;i&lt;=5;i++) &#123; if(i==3) &#123; continue; &#125; System.out.println(i); &#125; &#125;&#125; 运行及结果：012分隔符01245]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>break</tag>
        <tag>continue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Foreach语句]]></title>
    <url>%2F2019%2F08%2F07%2FForeach%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[Foreach语句 java SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。123456789101112import java.util.Random;public class ForEachFloat&#123; public static void main(String[] args)&#123; Random rand = new Random(47); float f[] = new float[10]; for(int i = 0;i &lt; 10;i++) f[i]=rand.nextFloat(); for(float x:f) System.out.println(x); &#125;&#125; 运行及结果：0.727115750.399826350.53094540.05341220.160206560.577997570.188478650.41701370.516602040.73734957 123456public class ForEachFloat&#123; public static void main(String[] args)&#123; for(char c:&quot;An African Swallow&quot;.toCharArray()) System.out.print(c+&quot; &quot;); &#125;&#125; 运行及结果：A n A f r i c a n S w a l l o w]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Foreach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[截尾和舍入]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在执行窄化转换时，必须注意截尾与舍入问题。例如：如果将一个浮点值转换整形值，Java会如何处理？ 12345678910public class CastingNumbers &#123; public static void main(String[] args) &#123; double above = 0.7,below = 0.4; float fabove = 0.7f,fbelow = 0.4f; System.out.println(&quot;(int)above: &quot;+(int)above); System.out.println(&quot;(int)below: &quot;+(int)below); System.out.println(&quot;(int)fabove: &quot;+(int)fabove); System.out.println(&quot;(int)fbelow: &quot;+(int)fbelow); &#125;&#125; 运行及结果：(int)above: 0(int)below: 0(int)fabove: 0(int)fbelow: 0 运行结果发现，在将float和double转型为整数值时，总是对该数字执行截尾。如果想要得到舍入的结果，就需要使用java.lang.Math中的round()方法。 12345678910public class CastingNumbers &#123; public static void main(String[] args) &#123; double above = 0.7,below = 0.4; float fabove = 0.7f,fbelow = 0.4f; System.out.println(&quot;Math.round(above): &quot;+Math.round(above)); System.out.println(&quot;Math.round(below): &quot;+Math.round(below)); System.out.println(&quot;Math.round(fabove): &quot;+Math.round(fabove)); System.out.println(&quot;Math.round(fbelow): &quot;+Math.round(fbelow)); &#125;&#125; 运行及结果:Math.round(above): 1Math.round(below): 0Math.round(fabove): 1Math.round(fbelow): 0 由于round()是java.lang的一部分，因此在使用它时不需要额外地导入。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
        <tag>数据类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涉及按位操作的所有操作符（求二进制）]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%B6%89%E5%8F%8A%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[涉及按位操作的所有操作符（求二进制） 代码以下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Random;public class BitManipulation&#123; public static void main(String[] args) &#123; Random rand = new Random(47); int i = rand.nextInt(); int j = rand.nextInt(); printBinaryInt(&quot;-1&quot;,-1); printBinaryInt(&quot;+1&quot;,+1); int maxpos = 2147483647; printBinaryInt(&quot;maxpos&quot;,maxpos); int maxneg = -2147483648; printBinaryInt(&quot;maxpos&quot;,maxneg); printBinaryInt(&quot;i&quot;,i); printBinaryInt(&quot;~i&quot;,~i); printBinaryInt(&quot;-i&quot;,-i); printBinaryInt(&quot;j&quot;,j); printBinaryInt(&quot;i&amp;j&quot;,i&amp;j); printBinaryInt(&quot;i|j&quot;,i|j); printBinaryInt(&quot;i^j&quot;,i^j); //不同为1，相同为0 printBinaryInt(&quot;i&lt;&lt;5&quot;,i&lt;&lt;5); printBinaryInt(&quot;i&gt;&gt;5&quot;,i&gt;&gt;5); printBinaryInt(&quot;(~i)&gt;&gt;5&quot;,(~i)&gt;&gt;5); printBinaryInt(&quot;i&gt;&gt;&gt;5&quot;,i&gt;&gt;&gt;5); printBinaryInt(&quot;(~i)&gt;&gt;&gt;5&quot;,(~i)&gt;&gt;&gt;5); long l = rand.nextLong(); long m = rand.nextLong(); printBinaryLong(&quot;-1L&quot;,-1L); printBinaryLong(&quot;+1L&quot;,+1L); long ll = 9223372036854775807L; printBinaryLong(&quot;maxpos&quot;,ll); long lln = -9223372036854775808L; printBinaryLong(&quot;maxneg&quot;,lln); printBinaryLong(&quot;l&quot;,l); printBinaryLong(&quot;~l&quot;,~l); printBinaryLong(&quot;-l&quot;,-l); printBinaryLong(&quot;m&quot;,m); printBinaryLong(&quot;l&amp;m&quot;,l&amp;m); printBinaryLong(&quot;l|m&quot;,l|m); printBinaryLong(&quot;l^m&quot;,l^m); printBinaryLong(&quot;l&lt;&lt;5&quot;,l&lt;&lt;5); printBinaryLong(&quot;l&gt;&gt;5&quot;,l&gt;&gt;5); printBinaryLong(&quot;(~l)&gt;&gt;5&quot;,(~l)&gt;&gt;5); printBinaryLong(&quot;l&gt;&gt;&gt;5&quot;,l&gt;&gt;&gt;5); printBinaryLong(&quot;(~l)&gt;&gt;&gt;5&quot;,(~l)&gt;&gt;&gt;5); &#125; static void printBinaryInt(String s, int i) &#123; System.out.println(s+&quot;,int: &quot;+i+&quot;.binary:\n &quot;+Integer.toBinaryString(i)); &#125; static void printBinaryLong(String s, long l) &#123; System.out.println(s+&quot;,long: &quot;+l+&quot;.binary:\n &quot;+Long.toBinaryString(l)); &#125;&#125; 运行及结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364-1,int: -1.binary: 11111111111111111111111111111111+1,int: 1.binary: 1maxpos,int: 2147483647.binary: 1111111111111111111111111111111maxpos,int: -2147483648.binary: 10000000000000000000000000000000i,int: -1172028779.binary: 10111010001001000100001010010101~i,int: 1172028778.binary: 1000101110110111011110101101010-i,int: 1172028779.binary: 1000101110110111011110101101011j,int: 1717241110.binary: 1100110010110110000010100010110i&amp;j,int: 570425364.binary: 100010000000000000000000010100i|j,int: -25213033.binary: 11111110011111110100011110010111i^j,int: -595638397.binary: 11011100011111110100011110000011i&lt;&lt;5,int: 1149784736.binary: 1000100100010000101001010100000i&gt;&gt;5,int: -36625900.binary: 11111101110100010010001000010100(~i)&gt;&gt;5,int: 36625899.binary: 10001011101101110111101011i&gt;&gt;&gt;5,int: 97591828.binary: 101110100010010001000010100(~i)&gt;&gt;&gt;5,int: 36625899.binary: 10001011101101110111101011-1L,long: -1.binary: 1111111111111111111111111111111111111111111111111111111111111111+1L,long: 1.binary: 1maxpos,long: 9223372036854775807.binary: 111111111111111111111111111111111111111111111111111111111111111maxneg,long: -9223372036854775808.binary: 1000000000000000000000000000000000000000000000000000000000000000l,long: -8652529054300476342.binary: 1000011111101100000010101010101100001101101011000110110001001010~l,long: 8652529054300476341.binary: 111100000010011111101010101010011110010010100111001001110110101-l,long: 8652529054300476342.binary: 111100000010011111101010101010011110010010100111001001110110110m,long: 2955289354441303771.binary: 10100100000011010011000000001010010011111101111010011011011011l&amp;m,long: 72066398748419146.binary: 100000000000010000000001000000001101001000010010001001010l|m,long: -5769306098607591717.binary: 1010111111101111010011101010101110011111111111111110111011011011l^m,long: -5841372497356010863.binary: 1010111011101111010001101010100110011110010110111100101010010001l&lt;&lt;5,long: -179768631971968704.binary: 1111110110000001010101010110000110110101100011011000100101000000l&gt;&gt;5,long: -270391532946889886.binary: 1111110000111111011000000101010101011000011011010110001101100010(~l)&gt;&gt;5,long: 270391532946889885.binary: 1111000000100111111010101010100111100100101001110010011101l&gt;&gt;&gt;5,long: 306069219356533602.binary: 10000111111011000000101010101011000011011010110001101100010(~l)&gt;&gt;&gt;5,long: 270391532946889885.binary: 1111000000100111111010101010100111100100101001110010011101 注意高位表示符号：0为正，1为负。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>移位操作符</tag>
        <tag>二进制</tag>
        <tag>按位操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制转十进制快速方法]]></title>
    <url>%2F2019%2F08%2F05%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[转自 https://blog.csdn.net/xy2204/article/details/50522075 如果你是搞网络的，我觉得你一定要记住以下几种二进制数的转换值。你是一个网络工程 师，当看到一串二进制数时，你不要告诉我你会拿出笔纸或掰手指算半天才知道它转化成十进制的数值。要想快，那就记下下面几种常见的二进制–十进制转换： 以8位 来演示: 1.第一种: 00000001 1 00000010 2 00000100 4 00001000 8 00010000 16 00100000 32 01000000 64 10000000 128 2.第二种： 00000001 1 00000011 3 00000111 7 00001111 15 00011111 31 00111111 63 01111111 127 3.第三种： 10000000 128 11000000 192 11100000 224 11110000 240 11111000 248 11111100 252 11111110 254 举个例子： 11101011 可分为： 11100000（上面第三种类型） 224 00001000（上面第一种类型） 8 00000011（上面第二种类型） 3我们通过记住上面三种类型的转换，再用加 法（加法口算你会吧）立即得到结果：235 ================================================================================== 方法二： 熟记以下排列，其实很Easy了，从右往 左，依次是前一个数的2倍： 256 128 64 32 16 8 4 2 1 随便写个数字比如48 48 = 32 + 16,所以在32 和 16所在的位置为1，其余为0， 转为2进制就是 256 128 64 32 16 8 4 2 1 0 0 0 1 1 0 0 0 0 二进制转十进制就更简单了， 比如随便写的一串 01111101 先写上 ： 0 1 1 1 1 1 0 1 然后填充 128 64 32 16 8 4 2 1 十进制为 64+32+16+8+4+1=125 转载地址：http://blog.163.com/kongdelu2009@yeah/blog/static/111995207201037105051259/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二进制</tag>
        <tag>十进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java移位操作符]]></title>
    <url>%2F2019%2F08%2F04%2FJava%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java移位操作符 移位运算符和按位运算符一样，同属于位运算符，因此移位运算符的位指的也是二进制位。它包括以下几种：1.左移位（&lt;&lt;）：将操作符左侧的操作数向左移动操作符右侧指定的位数。移动的规则是在二进制的低位补0。 2.有符号右移位（&gt;&gt;）：将操作符左侧的操作数向右移动操作符右侧指定的位数。移动的规则是，如果被操作数的符号为正，则在二进制的高位补0；如果被操作数的符号为负，则在二进制的高位补1。 3.无符号右移位（&gt;&gt;&gt;）：将操作符左侧的操作数向右移动操作符右侧指定的位数。移动的规则是，无论被操作数的符号是正是负，都在二进制位的高位补0。 再来考虑一种情况，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，结果会是怎样呢？1、byte、short、char在做移位运算之前，会被自动转换为int类型，然后再进行运算。 2、byte、short、int、char类型的数据经过移位运算后结果都为int型。 3、long经过移位运算后结果为long型。 4、在左移位（&lt;&lt;）运算时，如果要移位的位数大于被操作数对应数据类型所能表示的最大位数，那么先将要求移位数对该类型所能表示的最大位数求余后，再将被操作数移位所得余数对应的数值，效果不变。比如1&lt;&lt;35=1&lt;&lt;(35%32)=1&lt;&lt;3=8。 5、对于有符号右移位（&gt;&gt;）运算和无符号右移位（&gt;&gt;&gt;）运算，当要移位的位数大于被操作数对应数据类型所能表示的最大位数时，那么先将要求移位数对该类型所能表示的最大位数求余后，再将被操作数移位所得余数对应的数值，效果不变。。比如100&gt;&gt;35=100&gt;&gt;(35%32)=100&gt;&gt;3=12。 在编程思想中有这么一句话：”移位“可与”等号“（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）组合使用但是在进行这样的移位赋值操作时，可能会遇到一个问题：如果byte或short值进行这样的移位运算，得到的可能不是正确的结果。 它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。 12345678910111213141516171819202122232425public class Test&#123; public static void main(String[] args) &#123; int i = -1; System.out.println(Integer.toBinaryString(i)); i &gt;&gt;&gt;=10; System.out.println(Integer.toBinaryString(i)); long l = -1; System.out.println(Long.toBinaryString(l)); l &gt;&gt;&gt;= 10; System.out.println(Long.toBinaryString(l)); short s = -1; System.out.println(Integer.toBinaryString(s)); s &gt;&gt;&gt;= 10; System.out.println(Integer.toBinaryString(s)); byte b = -1; System.out.println(Integer.toBinaryString(b)); b &gt;&gt;&gt;= 10; System.out.println(Integer.toBinaryString(b)); b = -1; System.out.println(Integer.toBinaryString(b)); System.out.println(Integer.toBinaryString(b&gt;&gt;&gt;10)); &#125;&#125; 运行及结果：111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 运行会发现s&gt;&gt;&gt;=10和b&gt;&gt;&gt;=10的输出结果是错误的。而没有赋值的b&gt;&gt;&gt;=10的输出正确。 内容转载于 http://blog.sina.com.cn/s/blog_6ca0f5eb0102vlha.html晚上纠结了很久这个问题，不懂为什么低5位才有用，怎么就2^5等于32位，跟int的32位挂上钩了，思考了很久终于明白了。 这段话有两个出处，一个是Java编程思想3.11移位操作符中出现，原话是“只有数值右端的低5位才有用”。一个是Java解惑中谜题27：变幻莫测的i值，原话是“移位操作符只使用其右操作数的低5位作为移位长度”。 弄清这句话首先需要弄清楚移位操作符，移位操作符是一个二元操作符，两个操作数分别位于移位操作两边形如：左操作数 移位操作符 右操作数 这样的结构，其含义是，将左操作数按照移位操作符指定的移位方向，进行右操作数指定的次数的移位。然后对照出处二，Java解惑中所描述的，就豁然开朗了。 首先，移位操作符能操作的数只有int类型和long类型，这个是指左操作数的类型。对于int类型而言，int在Java中占4字节，一共32位，也就是说，对于一个在Java中的int数据，做32次移位，那么这个int数据就完全变了，以左移为例，左移是补0，那么对于任意一个int类型数据，做32次移位，那么int数据变成32位全0的数据，Java不允许一次性移位左操作数的所有位，也就是右操作数不能大于32。于是回到上述的句子，其指的是右操作数的低5位，5位二进制所代表的最大值为2^5-1，为31，所以取右操作数的低5位，就是只看右操作数的二进制的低5位，其数值不会超过2^5次方，也就是int的32位。因此，移位操作符进行移位的实际次数，其实是右操作数2的次数。 对于Java编程思想中的翻译，“只有数值右端的低5位才有用”，真是莫名其妙了。其英语原文为：Only the five low-order bits of the right-hand side will be used.看到英文原文，可就明白了这句话的意思，鉴于现在的英译中的书籍参差不齐，建议阅读的时候配一本英文版的电子书在手边以备不时之需。 简而言之，移位操作符执行的次数，只取右操作数的低5位（其数值不会大于2^5=32，也就是移位次数不会超过32位，因为32位是int型的位数）作为移位的次数。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>移位操作符</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integer和int的区别]]></title>
    <url>%2F2019%2F08%2F04%2FInteger%E5%92%8Cint%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Integer和int的区别 内容转载于 https://www.cnblogs.com/guodongdidi/p/6953217.html Integer是int的包装类，int则是java的一种基本数据类型 Integer变量必需实例化后才能使用，而int变量不需要 Integer实际是对象的引用，当new一个integer时，实际上是生成一个指针指向对象；而int则是直接存储数据值 Integer的默认值是null，int的默认值是0 延伸：关于Integer和int的比较1.由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false 2.Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） Integer i = new Integer(100);int j = 100;System.out.print(i == j); //true 3.非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 4.对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false Integer i = 100;Integer j = 100;System.out.print(i == j); //true Integer i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因：java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下： 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= &gt;IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Integer</tag>
        <tag>int</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负数的二进制表示]]></title>
    <url>%2F2019%2F08%2F04%2F%E8%B4%9F%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[了解负数的二进制表示 计算机中，负数以其正值的补码形式表示 比如2的二进制为10，但int类型的数占用4字节（32位），就写为00000000 00000000 00000000 00000010 求-2的二进制就要求出原码、补码、反码 原码：将整数的绝对值大小转换为二进制，称为原码。 00000000 00000000 00000000 00000010 反码：将原码按位取反，所得为反码。（1变0，0变1）。 11111111 11111111 11111111 11111101 补码：反码加1为补码。 11111111 11111111 11111111 11111110 -2的二进制为11111111 11111111 11111111 11111110]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中使用逻辑操作符时遇到的短路现象]]></title>
    <url>%2F2019%2F08%2F04%2FJava%E7%9F%AD%E8%B7%AF%E4%B8%8E%2F</url>
    <content type="text"><![CDATA[Java短路与 Java中使用逻辑操作符时遇到的短路现象123456789101112131415161718192021222324// &amp;&amp;短路与public class ShortCircuit&#123; static boolean test1(int val) &#123; System.out.println(&quot;test(&quot;+val+&quot;)&quot;); System.out.println(&quot;result: &quot;+(val&lt;1)); return val&lt;1; &#125; static boolean test2(int val) &#123; System.out.println(&quot;test(&quot;+val+&quot;)&quot;); System.out.println(&quot;result: &quot;+(val&lt;2)); return val&lt;2; &#125; static boolean test3(int val) &#123; System.out.println(&quot;test(&quot;+val+&quot;)&quot;); System.out.println(&quot;result: &quot;+(val&lt;3)); return val&lt;3; &#125; public static void main(String[] args) &#123; boolean b=test1(0)&amp;&amp;test2(2)&amp;&amp;test3(2); System.out.println(&quot;expression is &quot;+b); &#125;&#125; 运行及结果：test(0)result: truetest(2)result: falseexpression is false 可以发现test1与test2比较后直接输出，不会对test3进行比较，这就是&amp;和&amp;&amp;的不同之处。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想第三章练习]]></title>
    <url>%2F2019%2F08%2F04%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Java编程思想第三章练习 第三章练习5：创建一个名为Dogde类，它包含两个String域：name和scruffy（它的叫声为“Ruff!”）,另一个名为scruffy（它的叫声为“Wurf！”）。然后显示它们的名字和叫声。练习6：创建一个新的Dog索引，并对其赋值为spot对象。测试用==和equals()方法比较所有引用的结果。 123456789101112131415161718192021222324252627class Dog&#123; String name; String says; void shows() &#123; System.out.println(&quot;name: &quot;+name+&quot; Says: &quot;+says); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Dog spot = new Dog(); spot.name=&quot;Spot&quot;; spot.says=&quot;Ruff!&quot;; Dog scruffy = new Dog(); scruffy.name=&quot;Sruffy&quot;; scruffy.says=&quot;Wufrf!&quot;; spot.shows(); scruffy.shows(); Dog newDog = new Dog(); newDog = spot; System.out.println(newDog==spot); System.out.println(newDog.equals(spot)); &#125;&#125; 运行及结果：name: Spot Says: Ruff!name: Sruffy Says: Wufrf!truetrue 练习7：编写一个程序，模拟扔硬币的结果。 12345678910111213import java.util.Random;class Coin&#123; static void test() &#123; Random r = new Random(); System.out.println(r.nextInt(2) == 1?&quot;正面&quot;:&quot;反面&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Coin.test(); &#125;&#125; 练习8：展示用16进制和8进制记数法（字面值）来操作long值（赋值），用Long.toBinaryString()来显示其结果。 123456789public class Test&#123; public static void main(String[] args) &#123; long l1=0xC2B; long l2=0777; System.out.println(Long.toBinaryString(l1)); System.out.println(Long.toBinaryString(l2)); &#125;&#125; 练习9：分别显示用float和double指数计数法所能表示的最大和最小的数字 1234567891011121314public class Test&#123; public static void main(String[] args) &#123; float floatmax = Float.MAX_VALUE; float floatmin = Float.MIN_VALUE; double doublemax = Double.MAX_VALUE; double doublemin = Double.MIN_VALUE; System.out.println(&quot;floatmax = &quot; + floatmax); System.out.println(&quot;floatmin = &quot; + floatmin); System.out.println(&quot;doublemax = &quot; + doublemax); System.out.println(&quot;doublemin = &quot; + doublemin); &#125;&#125; 运行及结果：floatmax = 3.4028235E38floatmin = 1.4E-45doublemax = 1.7976931348623157E308doublemin = 4.9E-324 练习10：编写一个具有两个常量值的程序,一个具有交替的二进制位1和0,其中最低有效位为0,另一个也具有交替的二进制位1和0,其中最低有效位为1.取这两个值,用按位操作符以所有可能的方式结合运算它们,然后用Integer.toBinaryString()显示 123456789101112131415161718public class Test&#123; public static void main(String[] args) &#123; int a = 0xaaaaaaaa; int b = 0x55555555; System.out.println(&quot; a: &quot;+Integer.toBinaryString(a)); System.out.println(&quot; b: &quot;+Integer.toBinaryString(b)); System.out.println(&quot; ~a: &quot;+Integer.toBinaryString(~a)); System.out.println(&quot; ~b: &quot;+Integer.toBinaryString(~b)); System.out.println(&quot;a&amp;a: &quot;+Integer.toBinaryString(a&amp;a)); System.out.println(&quot;a|a: &quot;+Integer.toBinaryString(a|a)); System.out.println(&quot;a^a: &quot;+Integer.toBinaryString(a^a)); System.out.println(&quot;a&amp;b: &quot;+Integer.toBinaryString(a&amp;b)); System.out.println(&quot;a|b: &quot;+Integer.toBinaryString(a|b)); System.out.println(&quot;a^b: &quot;+Integer.toBinaryString(a^b)); &#125;&#125; 运行及结果： a: 10101010101010101010101010101010 b: 1010101010101010101010101010101~a: 1010101010101010101010101010101~b: 10101010101010101010101010101010a&amp;a: 10101010101010101010101010101010a|a: 10101010101010101010101010101010a^a: 0a&amp;b: 0a|b: 11111111111111111111111111111111a^b: 11111111111111111111111111111111 练习11：以一个最高有效位为1的二进制数开始,用有符号右移操作符对其进行右移,直至所有的二进制位都被移出为止,每移一位都显示二进制字符串效果.练习12：以一个所有位都为1的二进制数字开始,先左移它,然后用无符号右移操作符对其进行右移,直至所有二进制位都移出为止,每移一位都要显示二进制字符串效果. 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; int number = 0xaaaaa; while(number != 0) &#123; number &gt;&gt;= 1; System.out.println(Integer.toBinaryString(number)); &#125; System.out.println(&quot;====================&quot;); int number2 = 0xff; number2 &lt;&lt;= 1; while(number2 != 0) &#123; number2 &gt;&gt;&gt;= 1; System.out.println(Integer.toBinaryString(number2)); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031运行及结果：10101010101010101011010101010101010101010101010101010110101010101010101010101010101011010101010101010101010101011010101010101010101010110101010101010101011010101010101011010101010110101011010====================1111111111111111111111111111111111110 练习13：编写一个方法,它以二进制形式显示char类型的值.使用多个不同的字符来展示它. 12345678910111213class TestChar&#123; static void Conversion(char c) &#123; System.out.println(Integer.toBinaryString((int)c)); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; TestChar.Conversion(&apos;a&apos;); TestChar.Conversion(&apos;b&apos;); TestChar.Conversion(&apos;c&apos;); TestChar.Conversion(&apos;$&apos;); &#125;&#125; 运行及结果：110000111000101100011100100]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thinking in Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中对象的赋值]]></title>
    <url>%2F2019%2F08%2F03%2FJava%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[记录以下学习Java对象赋值中出现的问题 在java中赋值使用操作符“=”。意思是“取右边的值，把它赋值给左边”。右值可以是任何常数、变量或者表达式（只要能生成一个值）。但左边必须是一个明确的、已命名的变量。但是不能把任何东西赋值给一个常数，常数不能作为左值（比如不能4=a;）。基本数据类型的赋值是直接将一个地方的内容复制到了另一个地方。例如，a=b,b的内容复制给a。接着又修改了a，而b并不会受a修改的影响。 但在为对象赋值的时候，情况却不一样。对一个对象进行操作时，我们真正操作的是对对象的引用。 123456789101112131415161718192021class Tank&#123; int level;&#125;public class Test&#123; public static void main(String[] arg) &#123; Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 9; t2.level = 47; System.out.println(&quot;1: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level); t1 = t2; System.out.println(&quot;2: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level); t1.level = 27; System.out.println(&quot;3: t1.level: &quot; + t1.level + &quot;,t2.level: &quot; + t2.level); &#125;&#125;/*Output:1: t1.level: 9,t2.level: 472: t1.level: 47,t2.level: 473: t1.level: 27,t2.level: 27*///:~ 每个Tank类对象的level域都赋予了一个不同的值，然后，将t2赋给t1。我们可能会期望t1和t2总是相互独立的。但由于赋值操作的是一个对象的引用，t1和t2包含的引用相同,所以修改t1的同时也改变了t2。这种特殊现象称为”别名现象“。 避免方式：t1.level = t2.level; 方法调用中的别名问题12345678910111213141516class Tank&#123; char c;&#125;public class Test&#123; static void f(Tank y) &#123; y.c = &apos;z&apos;; &#125; public static void main(String[] arg) &#123; Tank t = new Tank(); t.c = &apos;a&apos;; System.out.println(&quot;1: t.c: &quot; + t.c); f(t); System.out.println(&quot;2: t.c: &quot; + t.c); &#125;&#125; 运行及结果：1: t.c: a2: t.c: z]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中局部变量的初始化问题]]></title>
    <url>%2F2019%2F08%2F02%2Fjava%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[java中局部变量的初始化问题 Java中局部变量必须初始化但成员变量不必须初始化其实无论成员变量还是局部变量都要初始化，只是JVM帮我们初始化了成员变量。 JVM在初始化对象时就可以初始化成员变量。 在类的加载中，我们定义的成员变量进行了两次初始化，一次赋默认初值（0值，boolean赋为false），一次赋自定义的初值。而对于方法中的局部变量，需要进栈执行，这个过程是没有赋初值过程的。 还有种情况为：定义的局部变量没有赋值，也没有报错，是因为局部变量没有被调用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>局部变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql数据备份与还原]]></title>
    <url>%2F2019%2F07%2F21%2FMysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[Mysql数据备份与还原 数据备份 1.整库备份 利用mysqldump进行sql备份 语法：mysqldump.exe -hPup 数据库名字 &gt; 备份路径 mysqldump.exe -hlocalhost -P3306 -uroot -proot mydatabase C:/server/mydatabase.sql2.单表备份 语法：mysqldump.exe -hPup 数据库名字 表名 &gt; 备份路径 mysqldump -uroot -proot mydatabase my_int &gt; c:/server/int.sql3.多表备份 语法：mysqldump.exe -hPup 数据库名字 表名 表名 .. &gt; 备份路径 mysqldump -uroot -proot mydatabase my_student my_int &gt; c:/server/student_int.sq 数据还原 1.利用mysql.exe客户端 在cmd中直接对数据还原 语法：mysql -hPup 数据库 &lt; 文件路径 mysql -uroot -proot mydatabse &lt; c:/server/mydatabase.sql2.利用sql指令 登录mysql客户端并进入对应数据库 语法：source 文件路径（注意后面会有； 因为这里是在mysql中输入的sql指令） source c:/server/int.sql;3.复制粘贴]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客文章添加图片、音乐、视频]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[博客文章添加图片、音乐、视频 首先修改配置_config.yml 将post_asset_folder: false改为post_asset_folder: true 然后安装一个图片插件1npm install https://github.com/CodeFalling/hexo-asset-image -- save 新建一个博文后就会发现在/source/_posts目录下会生成同名文件夹将图片扔里面 添加本地图片 在博文中插入代码： 1![图片描述](文件夹/h1.jpg) 例: 添加外部连接1![图片描述](图片地址) 例: 插入音乐直接粘贴代码到博文： 123&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=5263408&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; 插入视频直接粘贴代码到博文： 12345&lt;iframe height=300 width=510 src=&quot;视频链接&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天天气真好 好就好在好个锤子]]></content>
  </entry>
</search>
